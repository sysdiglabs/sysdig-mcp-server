"""
This module provides tools for interacting with the Sysdig Secure Vulnerability Management API.
"""

import logging
import os
import time
from typing import List, Optional, Literal, Annotated
from pydantic import Field
from sysdig_client import VulnerabilityManagementApi
from sysdig_client.models.scan_result_response import ScanResultResponse
from sysdig_client.models.get_policy_response import GetPolicyResponse
from fastmcp.prompts.prompt import PromptMessage, TextContent
from fastmcp.exceptions import ToolError
from fastmcp.server.context import Context
from utils.app_config import AppConfig
from utils.query_helpers import create_standard_response



class VulnerabilityManagementTools:
    """
    A class to encapsulate the tools for interacting with the Sysdig Secure Vulnerability Management API.
    This class provides methods to list runtime vulnerabilities, accepted risks, registry scan results,
    and vulnerability policies.
    """

    def __init__(self, app_config: AppConfig):
        self.app_config = app_config
        # Configure logging
        self.log = logging.getLogger(__name__)


    def tool_list_runtime_vulnerabilities(
        self,
        ctx: Context,
        cursor: Annotated[Optional[str], Field(description="Cursor for pagination. If None, returns the first page.")] = None,
        filter: Annotated[
            Optional[str],
            Field(
                description=(
                    """
                    Sysdig Secure query filter expression to filter runtime vulnerability scan results.

                    Use the resource://filter-query-language to get the expected filter expression format.

                    Key fields include:
                        - asset.type
                        - aws.account.id
                        - aws.host.name
                        - aws.region
                        - cloudProvider
                        - cloudProvider.account.id
                        - cloudProvider.region
                        - gcp.instance.id
                        - gcp.instance.zone
                        - gcp.project.id
                        - gcp.project.numericId
                        - host.hostName
                        - kubernetes.cluster.name
                        - kubernetes.namespace.name
                        - kubernetes.node.name
                        - kubernetes.pod.container.name
                        - kubernetes.workload.name
                        - kubernetes.workload.type
                        - workload.name
                        - workload.orchestrator

                    The supported fields are all the fields of the Scope above, plus::
                        - freeText
                        - hasRunningVulns
                        - hasRunningVulns.
                    """
                ),
                examples=[
                    'asset.type = "host"',
                    'aws.region = "us-west-2"',
                    'kubernetes.cluster.name = "cluster1"',
                    'cloudProvider = "gcp" and gcp.project.id = "my-project"',
                    'host.hostName startsWith "web-"',
                ],
            ),
        ] = None,
        sort: Annotated[
            Optional[Literal["vulnTotalBySeverity", "runningVulnTotalBySeverity"]],
            Field(
                description=(
                    """
                    Field to sort by: 'vulnTotalBySeverity' for vulnerabilities by severity; 'runningVulnTotalBySeverity'
                    for vulnerabilities currently loaded in memory by severity.
                """
                ),
            ),
        ] = None,
        order: Annotated[Optional[Literal["asc", "desc"]], Field(description="Sort order: 'asc' or 'desc'.")] = None,
        limit: Annotated[int, Field(ge=1, description="Maximum number of results to return.")] = 50,
    ) -> dict:
        """
        Retrieves a list of assets with runtime vulnerabilities scan results.

        Args:
            ctx (Context): A context object containing configuration information.
            cursor (Optional[str]): Cursor for pagination. If None, returns the first page.
            filter (Optional[str]): Sysdig Secure query filter expression to filter runtime vulnerability scan results.
                Use the resource://filter-query-language to get the expected filter expression format.
                Supports operators: =, !=, in, exists, contains, startsWith.
                Combine with and/or/not.
                Examples:
                - asset.type = "host"
                - aws.region = "us-west-2"
                - kubernetes.cluster.name = "cluster1"
                - cloudProvider = "gcp" and gcp.project.id = "my-project"
                - host.hostName startsWith "web-"
            sort (Optional[str]): Field name to sort by.
            order (Optional[str]): Sort order, either 'asc' or 'desc'.
            limit (int): Maximum number of results to return.

        Returns:
            dict: A dictionary containing:
                - results: Serializable dict of runtime vulnerability scan results.
                - cursor (Optional[str]): Next page cursor, or None if no further pages.
                - execution_time_ms (float): Execution duration in milliseconds.
        """
        try:
            api_instances: dict = ctx.get_state("api_instances")
            vulnerability_api: VulnerabilityManagementApi = api_instances.get("vulnerability_management")
            # Record start time for execution duration
            start_time = time.time()
            api_response = vulnerability_api.scanner_api_service_list_runtime_results_without_preload_content(
                cursor=cursor, filter=filter, sort=sort, order=order, limit=limit
            )
            # Capture next page cursor if available
            duration_ms = (time.time() - start_time) * 1000
            self.log.debug(f"Execution time: {duration_ms:.2f} ms")

            response = create_standard_response(
                results=api_response,
                execution_time_ms=duration_ms,
            )
            return response
        except ToolError as e:
            self.log.error(f"Exception when calling VulnerabilityManagementApi->scanner_api_service_list_runtime_results: {e}")
            raise e

    def tool_list_accepted_risks(
        self,
        ctx : Context,
        filter: Optional[str] = None,
        limit: int = 50,
        cursor: Optional[str] = None,
        sort: Optional[str] = None,
        order: Optional[str] = None,
    ) -> dict:
        """
        Retrieve a paginated list of accepted vulnerability risks.

        Args:
            ctx (Context): A context object containing configuration information.
            filter (Optional[str]): Query expression to filter accepted risks.
            limit (int): Maximum number of risks to return.
            cursor (Optional[str]): Pagination cursor. If None, returns the first page.
            sort (Optional[str]): Field name to sort by.
            order (Optional[str]): Sort order, either 'asc' or 'desc'.

        Returns:
            dict: The API response as a dictionary, or an error dict on failure.
        """
        try:
            api_instances: dict = ctx.get_state("api_instances")
            vulnerability_api: VulnerabilityManagementApi = api_instances.get("vulnerability_management")
            start_time = time.time()
            api_response = vulnerability_api.get_accepted_risks_v1_without_preload_content(
                filter=filter, limit=limit, cursor=cursor, sort=sort, order=order
            )
            # Capture next page cursor if available
            duration_ms = (time.time() - start_time) * 1000
            self.log.debug(f"Execution time: {duration_ms:.2f} ms")

            response = create_standard_response(
                results=api_response,
                execution_time_ms=duration_ms,
            )
            return response
        except ToolError as e:
            self.log.error(f"Exception when calling VulnerabilityManagementApi->get_accepted_risks_v1: {e}")
            raise e

    def tool_get_accepted_risk(self, ctx: Context, accepted_risk_id: str) -> dict:
        """
        Retrieve details of a specific accepted risk by its ID.

        Args:
            ctx (Context): A context object containing configuration information.
            accepted_risk_id (str): The ID of the accepted risk to retrieve.

        Returns:
            dict: The accepted risk details as a dictionary, or an error dict on failure.
        """
        try:
            api_instances: dict = ctx.get_state("api_instances")
            vulnerability_api: VulnerabilityManagementApi = api_instances.get("vulnerability_management")

            response = vulnerability_api.get_accepted_risk_v1(accepted_risk_id)
            return response.model_dump_json() if hasattr(response, "dict") else response
        except ToolError as e:
            self.log.error(f"Exception when calling VulnerabilityManagementApi->get_accepted_risk_v1: {e}")
            raise e

    def tool_list_registry_scan_results(
        self,
        ctx: Context,
        filter: Annotated[
            Optional[str],
            Field(
                description=(
                    """
                    Sysdig Secure query filter expression to filter vulnerability scan results on registries.

                    Use the resource://filter-query-language to get the expected filter expression format.

                    The supported fields are:
                        - freeText
                        - vendor
                    """
                ),
                examples=[
                    'freeText = "alpine:latest" and vendor = "docker"',
                    'vendor = "ecr"',
                    'vendor = "harbor" and freeText in ("redis")',
                ],
            ),
        ] = None,
        limit: int = 50,
        cursor: Optional[str] = None,
    ) -> dict:
        """
        Retrieve a paginated list of vulnerability scan results on registries.

        Args:
            filter (Optional[str]): Sysdig Secure query filter expression to filter runtime vulnerability scan results.
                Use the resource://filter-query-language to get the expected filter expression format.
                Supports operators: =, !=, in, exists, contains, startsWith.
                Combine with and/or/not.
                Key selectors include: freeText (string), vendor (e.g., "docker", "ecr", "harbor").
                Examples:
                - freeText = "alpine:latest" and vendor = "docker"
                - vendor = "ecr"
                - vendor = "harbor" and freeText in ("redis")
            limit (int): Maximum number of results to return.
            cursor (Optional[str]): Pagination cursor. If None, returns the first page.

        Returns:
            dict: The registry scan results as a dictionary, or an error dict on failure.
        """
        try:
            api_instances: dict = ctx.get_state("api_instances")
            vulnerability_api: VulnerabilityManagementApi = api_instances.get("vulnerability_management")

            start_time = time.time()
            api_response = vulnerability_api.scanner_api_service_list_registry_results_without_preload_content(
                filter=filter, limit=limit, cursor=cursor
            )
            duration_ms = (time.time() - start_time) * 1000
            self.log.debug(f"Execution time: {duration_ms:.2f} ms")

            response = create_standard_response(
                results=api_response,
                execution_time_ms=duration_ms,
            )
            return response
        except ToolError as e:
            self.log.error(f"Exception when calling VulnerabilityManagementApi->scanner_api_service_list_registry_results: {e}")
            raise e

    def tool_get_vulnerability_policy(
        self, ctx: Context, policy_id: Annotated[int, Field(description="The unique ID of the vulnerability policy to retrieve.")]
    ) -> GetPolicyResponse | dict:
        """
        Retrieve a specific vulnerability policy by its ID.

        Args:
            policy_id (int): The ID of the vulnerability policy to retrieve.

        Returns:
            GetPolicyResponse: The policy details model.
            dict: An error dict on failure.
        """
        try:
            api_instances: dict = ctx.get_state("api_instances")
            vulnerability_api: VulnerabilityManagementApi = api_instances.get("vulnerability_management")

            response: GetPolicyResponse = vulnerability_api.secure_vulnerability_v1_policies_policy_id_get(policy_id)
            return response.model_dump_json() if hasattr(response, "dict") else response
        except ToolError as e:
            self.log.error(
                f"Exception when calling VulnerabilityManagementApi->secure_vulnerability_v1_policies_policy_id_get: {e}"
            )
            raise e

    def tool_list_vulnerability_policies(
        self,
        ctx: Context,
        cursor: Optional[str] = None,
        limit: int = 50,
        name: Optional[str] = None,
        stages: Optional[List[str]] = None,
    ) -> dict:
        """
        Retrieve a paginated list of vulnerability policies.

        Args:
            cursor (Optional[str]): Pagination cursor. If None, returns the first page.
            limit (int): Maximum number of policies to return.
            name (Optional[str]): Filter policies by name.
            stages (Optional[List[str]]): Filter policies by applied stages.

        Returns:
            dict: The list of policies as a dictionary, or an error dict on failure.
        """
        start_time = time.time()
        try:
            api_instances: dict = ctx.get_state("api_instances")
            vulnerability_api: VulnerabilityManagementApi = api_instances.get("vulnerability_management")
            api_response = vulnerability_api.secure_vulnerability_v1_policies_get_without_preload_content(
                cursor=cursor, limit=limit, name=name, stages=stages
            )
            # Capture next page cursor if available

            duration_ms = (time.time() - start_time) * 1000
            self.log.debug(f"Execution time: {duration_ms:.2f} ms")

            response = create_standard_response(
                results=api_response,
                execution_time_ms=duration_ms,
            )
            return response
        except ToolError as e:
            self.log.error(
                f"Exception when calling VulnerabilityManagementApi->secure_vulnerability_v1_policies_get: {e}"
            )
            raise e

    def tool_list_pipeline_scan_results(
        self,
        ctx: Context,
        cursor: Annotated[Optional[str], Field(description="Cursor for pagination. If None, returns the first page.")] = None,
        filter: Annotated[
            Optional[str],
            Field(
                description=(
                    """
                    Sysdig Secure query filter expression to filter vulnerability scan results on pipelines.

                    Use the resource://filter-query-language to get the expected filter expression format.

                    The supported fields are:
                    - freeText
                    """
                ),
                examples=[
                    'freeText in ("nginx")',
                    'freeText in ("ubuntu")',
                ],
            ),
        ] = None,
        limit: Annotated[int, Field(ge=1, description="Maximum number of results to return.")] = 50,
    ) -> dict:
        """
        Retrieve a paginated list of pipeline vulnerability scan results.

        Args:
            ctx (Context): A context object containing configuration information.
            cursor (Optional[str]): Cursor for pagination. If None, returns the first page.
            filter (Optional[str]):  Sysdig Secure query filter expression to filter vulnerability.
                Use the resource://filter-query-language to get the expected filter expression format.
                scan results on pipelines.
                Supports operators: =, !=, in, exists, contains, startsWith.
                Combine with and/or/not.
                Key selectors include:
                - freeText (string).
                Examples:
                - freeText in ("nginx")
                - freeText in ("ubuntu")
            limit (int): Maximum number of results to return.

        Returns:
            dict: {
                "results": PipelineResultsResponse as dict,
                "next_cursor": Optional[str],
                "execution_time_ms": float
            }
        """
        start_time = time.time()
        try:
            api_instances: dict = ctx.get_state("api_instances")
            vulnerability_api: VulnerabilityManagementApi = api_instances.get("vulnerability_management")

            api_response = vulnerability_api.secure_vulnerability_v1_pipeline_results_get_without_preload_content(
                cursor=cursor, filter=filter, limit=limit
            )
            duration_ms = (time.time() - start_time) * 1000
            self.log.debug(f"Execution time: {duration_ms:.2f} ms")

            response = create_standard_response(
                results=api_response,
                execution_time_ms=duration_ms,
            )
            return response
        except ToolError as e:
            self.log.error(
                f"Exception when calling VulnerabilityManagementApi->secure_vulnerability_v1_policies_get: {e}"
            )
            raise e

    def tool_get_scan_result(self, ctx: Context, scan_id: str) -> dict:
        """
        Retrieve the result of a specific scan.

        Args:
            ctx (Context): A context object containing configuration information.
            scan_id (str): The ID of the scan.

        Returns:
            dict: ScanResultResponse as dict, or {"error": ...}.
        """
        try:
            api_instances: dict = ctx.get_state("api_instances")
            vulnerability_api: VulnerabilityManagementApi = api_instances.get("vulnerability_management")
            resp: ScanResultResponse = vulnerability_api.secure_vulnerability_v1_results_result_id_get(scan_id)
            return resp.model_dump_json() if hasattr(resp, "dict") else resp
        except ToolError as e:
            self.log.error(
                f"Exception when calling VulnerabilityManagementApi->secure_vulnerability_v1_results_result_id_get: {e}"
            )
            raise e

    def explore_vulnerabilities_prompt(self, filters: str) -> PromptMessage:
        """
        Generates a prompt message for exploring vulnerabilities based on provided filters.

        Args:
            filters (str): The filter expression to apply to the vulnerabilities.
        Returns:
            PromptMessage: A message object containing the prompt for exploring vulnerabilities.
        """
        content = (
            f"Explore vulnerabilities with the following filters:\n\n{filters}\n\n"
            "Please provide insights and recommendations based on these filters."
        )
        return PromptMessage(role="user", content=TextContent(type="text", text=content))
