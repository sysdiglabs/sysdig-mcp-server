"""
This module provides tools for interacting with the Sysdig Secure Vulnerability Management API.
"""

import logging
import os
import time
from typing import List, Optional, Literal, Annotated
from pydantic import Field
from sysdig_client import ApiException
from fastmcp import Context
from sysdig_client.models.scan_result_response import ScanResultResponse
from sysdig_client.models.get_policy_response import GetPolicyResponse
from fastmcp.prompts.prompt import PromptMessage, TextContent
from fastmcp.exceptions import ToolError
from starlette.requests import Request
from sysdig_client.api import VulnerabilityManagementApi
from fastmcp.server.dependencies import get_http_request
from utils.sysdig.client_config import get_configuration
from utils.app_config import get_app_config
from utils.sysdig.api import initialize_api_client
from utils.query_helpers import create_standard_response

# Configure logging
logging.basicConfig(format="%(asctime)s-%(process)d-%(levelname)s- %(message)s", level=os.environ.get("LOGLEVEL", "ERROR"))
log = logging.getLogger(__name__)

app_config = get_app_config()


class VulnerabilityManagementTools:
    """
    A class to encapsulate the tools for interacting with the Sysdig Secure Vulnerability Management API.
    This class provides methods to list runtime vulnerabilities, accepted risks, registry scan results,
    and vulnerability policies.
    """

    def init_client(self, config_tags: set[str]) -> VulnerabilityManagementApi:
        """
        Initializes the VulnerabilityManagementApi client from the request state.
        If the request does not have the API client initialized, it will create a new instance
        using the Sysdig Secure token and host from the environment variables.
        Args:
            config_tags (set[str]): The tags associated with the MCP server configuration, used to determine the transport mode.
        Returns:
            VulnerabilityManagementApi: An instance of the VulnerabilityManagementApi client.
        Raises:
            ValueError: If the SYSDIG_SECURE_TOKEN environment variable is not set.
        """
        vulnerability_management_api: VulnerabilityManagementApi = None
        if "streamable-http" in config_tags:
            # Try to get the HTTP request
            log.debug("Attempting to get the HTTP request to initialize the Sysdig API client.")
            request: Request = get_http_request()
            vulnerability_management_api = request.state.api_instances["vulnerability_management"]
        else:
            # If running in STDIO mode, we need to initialize the API client from environment variables
            log.debug("Running in STDIO mode, initializing the Sysdig API client from environment variables.")
            SYSDIG_SECURE_TOKEN = os.environ.get("SYSDIG_SECURE_TOKEN", "")
            if not SYSDIG_SECURE_TOKEN:
                raise ValueError("Can not initialize client, SYSDIG_SECURE_TOKEN environment variable is not set.")
            SYSDIG_HOST = os.environ.get("SYSDIG_HOST", app_config["sysdig"]["host"])
            cfg = get_configuration(SYSDIG_SECURE_TOKEN, SYSDIG_HOST)
            api_client = initialize_api_client(cfg)
            vulnerability_management_api = VulnerabilityManagementApi(api_client)
        return vulnerability_management_api

    def tool_list_runtime_vulnerabilities(
        self,
        ctx: Context,
        cursor: Annotated[Optional[str], Field(description="Cursor for pagination. If None, returns the first page.")] = None,
        filter: Annotated[
            Optional[str],
            Field(
                description=(
                    """
                    Sysdig Secure query filter expression to filter runtime vulnerability scan results.

                    Use the resource://filter-query-language to get the expected filter expression format.

                    Key fields include:
                        - asset.type
                        - aws.account.id
                        - aws.host.name
                        - aws.region
                        - cloudProvider
                        - cloudProvider.account.id
                        - cloudProvider.region
                        - gcp.instance.id
                        - gcp.instance.zone
                        - gcp.project.id
                        - gcp.project.numericId
                        - host.hostName
                        - kubernetes.cluster.name
                        - kubernetes.namespace.name
                        - kubernetes.node.name
                        - kubernetes.pod.container.name
                        - kubernetes.workload.name
                        - kubernetes.workload.type
                        - workload.name
                        - workload.orchestrator

                    The supported fields are all the fields of the Scope above, plus::
                        - freeText
                        - hasRunningVulns
                        - hasRunningVulns.
                    """
                ),
                examples=[
                    'asset.type = "host"',
                    'aws.region = "us-west-2"',
                    'kubernetes.cluster.name = "cluster1"',
                    'cloudProvider = "gcp" and gcp.project.id = "my-project"',
                    'host.hostName startsWith "web-"',
                ],
            ),
        ] = None,
        sort: Annotated[
            Optional[Literal["vulnTotalBySeverity", "runningVulnTotalBySeverity"]],
            Field(
                description=(
                    """
                    Field to sort by: 'vulnTotalBySeverity' for vulnerabilities by severity; 'runningVulnTotalBySeverity'
                    for vulnerabilities currently loaded in memory by severity.
                """
                ),
            ),
        ] = None,
        order: Annotated[Optional[Literal["asc", "desc"]], Field(description="Sort order: 'asc' or 'desc'.")] = None,
        limit: Annotated[int, Field(ge=1, description="Maximum number of results to return.")] = 50,
    ) -> dict:
        """
        Retrieves a list of assets with runtime vulnerabilities scan results.

        Args:
            cursor (Optional[str]): Cursor for pagination. If None, returns the first page.
            filter (Optional[str]): Query expression to filter the results.
            sort (Optional[str]): Field name to sort by.
            order (Optional[str]): Sort order, either 'asc' or 'desc'.
            limit (int): Maximum number of results to return.

        Returns:
            dict: A dictionary containing:
                - results: Serializable dict of runtime vulnerability scan results.
                - cursor (Optional[str]): Next page cursor, or None if no further pages.
                - execution_time_ms (float): Execution duration in milliseconds.
        """
        try:
            vulnerability_api = self.init_client(config_tags=ctx.fastmcp.tags)
            # Record start time for execution duration
            start_time = time.time()
            api_response = vulnerability_api.scanner_api_service_list_runtime_results_without_preload_content(
                cursor=cursor, filter=filter, sort=sort, order=order, limit=limit
            )
            # Capture next page cursor if available
            duration_ms = (time.time() - start_time) * 1000
            log.debug(f"Execution time: {duration_ms:.2f} ms")

            response = create_standard_response(
                results=api_response,
                execution_time_ms=duration_ms,
            )
            return response
        except ToolError as e:
            log.error(f"Exception when calling VulnerabilityManagementApi->scanner_api_service_list_runtime_results: {e}")
            raise e

    def tool_list_accepted_risks(
        self,
        ctx: Context,
        filter: Optional[str] = None,
        limit: int = 50,
        cursor: Optional[str] = None,
        sort: Optional[str] = None,
        order: Optional[str] = None,
    ) -> dict:
        """
        Retrieve a paginated list of accepted vulnerability risks.

        Args:
            filter (Optional[str]): Query expression to filter accepted risks.
            limit (int): Maximum number of risks to return.
            cursor (Optional[str]): Pagination cursor. If None, returns the first page.
            sort (Optional[str]): Field name to sort by.
            order (Optional[str]): Sort order, either 'asc' or 'desc'.

        Returns:
            dict: The API response as a dictionary, or an error dict on failure.
        """
        try:
            vulnerability_api = self.init_client(config_tags=ctx.fastmcp.tags)
            start_time = time.time()
            api_response = vulnerability_api.get_accepted_risks_v1_without_preload_content(
                filter=filter, limit=limit, cursor=cursor, sort=sort, order=order
            )
            # Capture next page cursor if available
            duration_ms = (time.time() - start_time) * 1000
            log.debug(f"Execution time: {duration_ms:.2f} ms")

            response = create_standard_response(
                results=api_response,
                execution_time_ms=duration_ms,
            )
            return response
        except ToolError as e:
            log.error(f"Exception when calling VulnerabilityManagementApi->get_accepted_risks_v1: {e}")
            raise e

    def tool_get_accepted_risk(self, ctx: Context, accepted_risk_id: str) -> dict:
        """
        Retrieve details of a specific accepted risk by its ID.

        Args:
            accepted_risk_id (str): The ID of the accepted risk to retrieve.

        Returns:
            dict: The accepted risk details as a dictionary, or an error dict on failure.
        """
        try:
            vulnerability_api = self.init_client(config_tags=ctx.fastmcp.tags)
            response = vulnerability_api.get_accepted_risk_v1(accepted_risk_id)
            return response.model_dump_json() if hasattr(response, "dict") else response
        except ToolError as e:
            log.error(f"Exception when calling VulnerabilityManagementApi->get_accepted_risk_v1: {e}")
            raise e

    def tool_list_registry_scan_results(
        self,
        ctx: Context,
        filter: Annotated[
            Optional[str],
            Field(
                description=(
                    """
                    Sysdig Secure query filter expression to filter vulnerability scan results on registries.

                    Use the resource://filter-query-language to get the expected filter expression format.

                    The supported fields are:
                        - freeText
                        - vendor
                    """
                ),
                examples=[
                    'freeText = "alpine:latest" and vendor = "docker"',
                    'vendor = "ecr"',
                    'vendor = "harbor" and freeText in ("redis")',
                ],
            ),
        ] = None,
        limit: int = 50,
        cursor: Optional[str] = None,
    ) -> dict:
        """
        Retrieve a paginated list of vulnerability scan results on registries.

        Args:
            filter (Optional[str]): Logical filter expression to select registry scan results.
                Supports operators: =, !=, in, exists, contains, startsWith.
                Combine with and/or/not.
                Key selectors include: freeText (string), vendor (e.g., "docker", "ecr", "harbor").
                Examples:
                - freeText = "alpine:latest" and vendor = "docker"
                - vendor = "ecr"
            limit (int): Maximum number of results to return.
            cursor (Optional[str]): Pagination cursor. If None, returns the first page.

        Returns:
            dict: The registry scan results as a dictionary, or an error dict on failure.
        """
        try:
            vulnerability_api = self.init_client(config_tags=ctx.fastmcp.tags)
            start_time = time.time()
            api_response = vulnerability_api.scanner_api_service_list_registry_results_without_preload_content(
                filter=filter, limit=limit, cursor=cursor
            )
            duration_ms = (time.time() - start_time) * 1000
            log.debug(f"Execution time: {duration_ms:.2f} ms")

            response = create_standard_response(
                results=api_response,
                execution_time_ms=duration_ms,
            )
            return response
        except ToolError as e:
            log.error(f"Exception when calling VulnerabilityManagementApi->scanner_api_service_list_registry_results: {e}")
            raise e

    def tool_get_vulnerability_policy(
        self, ctx: Context, policy_id: Annotated[int, Field(description="The unique ID of the vulnerability policy to retrieve.")]
    ) -> GetPolicyResponse | dict:
        """
        Retrieve a specific vulnerability policy by its ID.

        Args:
            policy_id (int): The ID of the vulnerability policy to retrieve.

        Returns:
            GetPolicyResponse: The policy details model.
            dict: An error dict on failure.
        """
        try:
            vulnerability_api = self.init_client(config_tags=ctx.fastmcp.tags)
            response: GetPolicyResponse = vulnerability_api.secure_vulnerability_v1_policies_policy_id_get(policy_id)
            return response.model_dump_json() if hasattr(response, "dict") else response
        except ToolError as e:
            log.error(f"Exception when calling VulnerabilityManagementApi->secure_vulnerability_v1_policies_policy_id_get: {e}")
            raise e

    def tool_list_vulnerability_policies(
        self,
        ctx: Context,
        cursor: Optional[str] = None,
        limit: int = 50,
        name: Optional[str] = None,
        stages: Optional[List[str]] = None,
    ) -> dict:
        """
        Retrieve a paginated list of vulnerability policies.

        Args:
            cursor (Optional[str]): Pagination cursor. If None, returns the first page.
            limit (int): Maximum number of policies to return.
            name (Optional[str]): Filter policies by name.
            stages (Optional[List[str]]): Filter policies by applied stages.

        Returns:
            dict: The list of policies as a dictionary, or an error dict on failure.
        """
        start_time = time.time()
        try:
            vulnerability_api = self.init_client(config_tags=ctx.fastmcp.tags)
            api_response = vulnerability_api.secure_vulnerability_v1_policies_get_without_preload_content(
                cursor=cursor, limit=limit, name=name, stages=stages
            )
            # Capture next page cursor if available

            duration_ms = (time.time() - start_time) * 1000
            log.debug(f"Execution time: {duration_ms:.2f} ms")

            response = create_standard_response(
                results=api_response,
                execution_time_ms=duration_ms,
            )
            return response
        except ToolError as e:
            log.error(f"Exception when calling VulnerabilityManagementApi->secure_vulnerability_v1_policies_get: {e}")
            raise e

    def tool_list_pipeline_scan_results(
        self,
        ctx: Context,
        cursor: Annotated[Optional[str], Field(description="Cursor for pagination. If None, returns the first page.")] = None,
        filter: Annotated[
            Optional[str],
            Field(
                description=(
                    """
                    Sysdig Secure query filter expression to filter vulnerability scan results on pipelines.

                    Use the resource://filter-query-language to get the expected filter expression format.

                    The supported fields are:
                    - freeText
                    """
                ),
                examples=[
                    'freeText in ("nginx")',
                    'freeText in ("ubuntu")',
                ],
            ),
        ] = None,
        limit: Annotated[int, Field(ge=1, description="Maximum number of results to return.")] = 50,
    ) -> dict:
        """
        Retrieve a paginated list of pipeline vulnerability scan results.

        Args:
            cursor (Optional[str]): Cursor for pagination. If None, returns the first page.
            filter (Optional[str]): Logical filter expression to select pipeline scan results.
                Supports operators: =, !=, in, exists, contains, startsWith.
                Combine with and/or/not.
                Key selectors include: policyEvaluationsPassed (true/false), freeText (string).
                Examples:
                - policyEvaluationsPassed = true
                - freeText in ("ubuntu")
                - policyEvaluationsPassed = false and freeText in ("ubuntu")
            limit (int): Maximum number of results to return.

        Returns:
            dict: {
                "results": PipelineResultsResponse as dict,
                "next_cursor": Optional[str],
                "execution_time_ms": float
            }
        """
        start_time = time.time()
        try:
            vulnerability_api = self.init_client(config_tags=ctx.fastmcp.tags)
            api_response = vulnerability_api.secure_vulnerability_v1_pipeline_results_get_without_preload_content(
                cursor=cursor, filter=filter, limit=limit
            )
            duration_ms = (time.time() - start_time) * 1000
            log.debug(f"Execution time: {duration_ms:.2f} ms")

            response = create_standard_response(
                results=api_response,
                execution_time_ms=duration_ms,
            )
            return response
        except ToolError as e:
            log.error(f"Exception when calling VulnerabilityManagementApi->secure_vulnerability_v1_policies_get: {e}")
            raise e

    def tool_get_scan_result(self, ctx: Context, scan_id: str) -> dict:
        """
        Retrieve the result of a specific scan.

        Args:
            scan_id (str): The ID of the scan.

        Returns:
            dict: ScanResultResponse as dict, or {"error": ...}.
        """
        try:
            vulnerability_api = self.init_client(config_tags=ctx.fastmcp.tags)
            resp: ScanResultResponse = vulnerability_api.secure_vulnerability_v1_results_result_id_get(scan_id)
            return resp.model_dump_json() if hasattr(resp, "dict") else resp
        except ToolError as e:
            log.error(f"Exception when calling VulnerabilityManagementApi->secure_vulnerability_v1_results_result_id_get: {e}")
            raise e

    def explore_vulnerabilities_prompt(self, ctx: Context, filters: str) -> PromptMessage:
        """
        Generates a prompt message for exploring vulnerabilities based on provided filters.

        Args:
            filters (str): The filter expression to apply to the vulnerabilities.
        Returns:
            PromptMessage: A message object containing the prompt for exploring vulnerabilities.
        """
        content = (
            f"Explore vulnerabilities with the following filters:\n\n{filters}\n\n"
            "Please provide insights and recommendations based on these filters."
        )
        return PromptMessage(role="user", content=TextContent(type="text", text=content))
