// Package sysdig provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version 2.4.1 DO NOT EDIT.
package sysdig

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"gopkg.in/yaml.v2"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for ActionExecutionStatus.
const (
	ActionExecutionStatusCOMPLETED  ActionExecutionStatus = "COMPLETED"
	ActionExecutionStatusENQUEUED   ActionExecutionStatus = "ENQUEUED"
	ActionExecutionStatusFAILED     ActionExecutionStatus = "FAILED"
	ActionExecutionStatusINPROGRESS ActionExecutionStatus = "IN_PROGRESS"
)

// Defines values for ActionType.
const (
	Capture          ActionType = "capture"
	ContainerKilled  ActionType = "container_killed"
	ContainerPaused  ActionType = "container_paused"
	ContainerStopped ActionType = "container_stopped"
	DriftPrevented   ActionType = "drift_prevented"
	MalwarePrevented ActionType = "malware_prevented"
	ProcessKilled    ActionType = "process_killed"
)

// Defines values for AgentlessRuntimeDetectionContentIntegrationType.
const (
	AgentlessRuntimeDetectionContentIntegrationTypeAzure      AgentlessRuntimeDetectionContentIntegrationType = "azure"
	AgentlessRuntimeDetectionContentIntegrationTypeCloudtrail AgentlessRuntimeDetectionContentIntegrationType = "cloudtrail"
	AgentlessRuntimeDetectionContentIntegrationTypeGcp        AgentlessRuntimeDetectionContentIntegrationType = "gcp"
	AgentlessRuntimeDetectionContentIntegrationTypeGithub     AgentlessRuntimeDetectionContentIntegrationType = "github"
	AgentlessRuntimeDetectionContentIntegrationTypeOkta       AgentlessRuntimeDetectionContentIntegrationType = "okta"
)

// Defines values for AgentlessRuntimeDetectionContentPriority.
const (
	AgentlessRuntimeDetectionContentPriorityAlert         AgentlessRuntimeDetectionContentPriority = "alert"
	AgentlessRuntimeDetectionContentPriorityCritical      AgentlessRuntimeDetectionContentPriority = "critical"
	AgentlessRuntimeDetectionContentPriorityDebug         AgentlessRuntimeDetectionContentPriority = "debug"
	AgentlessRuntimeDetectionContentPriorityEmergency     AgentlessRuntimeDetectionContentPriority = "emergency"
	AgentlessRuntimeDetectionContentPriorityError         AgentlessRuntimeDetectionContentPriority = "error"
	AgentlessRuntimeDetectionContentPriorityInformational AgentlessRuntimeDetectionContentPriority = "informational"
	AgentlessRuntimeDetectionContentPriorityNotice        AgentlessRuntimeDetectionContentPriority = "notice"
	AgentlessRuntimeDetectionContentPriorityWarning       AgentlessRuntimeDetectionContentPriority = "warning"
)

// Defines values for AuditTrailContentRequestMethod.
const (
	DELETE AuditTrailContentRequestMethod = "DELETE"
	GET    AuditTrailContentRequestMethod = "GET"
	PATCH  AuditTrailContentRequestMethod = "PATCH"
	POST   AuditTrailContentRequestMethod = "POST"
	PUT    AuditTrailContentRequestMethod = "PUT"
)

// Defines values for AuthenticatedConnectionInfoElasticsearchAuth.
const (
	AuthenticatedConnectionInfoElasticsearchAuthBASICAUTH   AuthenticatedConnectionInfoElasticsearchAuth = "BASIC_AUTH"
	AuthenticatedConnectionInfoElasticsearchAuthBEARERTOKEN AuthenticatedConnectionInfoElasticsearchAuth = "BEARER_TOKEN"
)

// Defines values for AuthenticatedConnectionInfoElasticsearchFormat.
const (
	AuthenticatedConnectionInfoElasticsearchFormatKVPAIRS AuthenticatedConnectionInfoElasticsearchFormat = "KV_PAIRS"
)

// Defines values for AuthenticatedConnectionInfoKafkaV1Auth.
const (
	AuthenticatedConnectionInfoKafkaV1AuthGssapi AuthenticatedConnectionInfoKafkaV1Auth = "gssapi"
)

// Defines values for AuthenticatedConnectionInfoKafkaV1Balancer.
const (
	AuthenticatedConnectionInfoKafkaV1BalancerCrc32      AuthenticatedConnectionInfoKafkaV1Balancer = "crc32"
	AuthenticatedConnectionInfoKafkaV1BalancerHash       AuthenticatedConnectionInfoKafkaV1Balancer = "hash"
	AuthenticatedConnectionInfoKafkaV1BalancerLeastbytes AuthenticatedConnectionInfoKafkaV1Balancer = "leastbytes"
	AuthenticatedConnectionInfoKafkaV1BalancerMurmur2    AuthenticatedConnectionInfoKafkaV1Balancer = "murmur2"
	AuthenticatedConnectionInfoKafkaV1BalancerRoundrobin AuthenticatedConnectionInfoKafkaV1Balancer = "roundrobin"
)

// Defines values for AuthenticatedConnectionInfoKafkaV1Compression.
const (
	AuthenticatedConnectionInfoKafkaV1CompressionGzip   AuthenticatedConnectionInfoKafkaV1Compression = "gzip"
	AuthenticatedConnectionInfoKafkaV1CompressionLz4    AuthenticatedConnectionInfoKafkaV1Compression = "lz4"
	AuthenticatedConnectionInfoKafkaV1CompressionSnappy AuthenticatedConnectionInfoKafkaV1Compression = "snappy"
	AuthenticatedConnectionInfoKafkaV1CompressionZstd   AuthenticatedConnectionInfoKafkaV1Compression = "zstd"
)

// Defines values for AuthenticatedConnectionInfoWebhookAuth.
const (
	AuthenticatedConnectionInfoWebhookAuthBASICAUTH   AuthenticatedConnectionInfoWebhookAuth = "BASIC_AUTH"
	AuthenticatedConnectionInfoWebhookAuthBEARERTOKEN AuthenticatedConnectionInfoWebhookAuth = "BEARER_TOKEN"
	AuthenticatedConnectionInfoWebhookAuthCERTIFICATE AuthenticatedConnectionInfoWebhookAuth = "CERTIFICATE"
	AuthenticatedConnectionInfoWebhookAuthSIGNATURE   AuthenticatedConnectionInfoWebhookAuth = "SIGNATURE"
)

// Defines values for AuthenticatedConnectionInfoWebhookOutput.
const (
	AuthenticatedConnectionInfoWebhookOutputJson   AuthenticatedConnectionInfoWebhookOutput = "json"
	AuthenticatedConnectionInfoWebhookOutputNdjson AuthenticatedConnectionInfoWebhookOutput = "ndjson"
)

// Defines values for AuthenticatedConnectionInfoWebhookTimestampFormat.
const (
	AuthenticatedConnectionInfoWebhookTimestampFormatMicroseconds AuthenticatedConnectionInfoWebhookTimestampFormat = "microseconds"
	AuthenticatedConnectionInfoWebhookTimestampFormatMilliseconds AuthenticatedConnectionInfoWebhookTimestampFormat = "milliseconds"
	AuthenticatedConnectionInfoWebhookTimestampFormatNanoseconds  AuthenticatedConnectionInfoWebhookTimestampFormat = "nanoseconds"
	AuthenticatedConnectionInfoWebhookTimestampFormatSeconds      AuthenticatedConnectionInfoWebhookTimestampFormat = "seconds"
)

// Defines values for BaseConnectionInfoChronicleRegion.
const (
	BaseConnectionInfoChronicleRegionAsiaSoutheast1 BaseConnectionInfoChronicleRegion = "asia-southeast1"
	BaseConnectionInfoChronicleRegionEurope         BaseConnectionInfoChronicleRegion = "europe"
	BaseConnectionInfoChronicleRegionUs             BaseConnectionInfoChronicleRegion = "us"
)

// Defines values for BaseConnectionInfoChronicleV2Region.
const (
	BaseConnectionInfoChronicleV2RegionAsiaNortheast1      BaseConnectionInfoChronicleV2Region = "asia-northeast1"
	BaseConnectionInfoChronicleV2RegionAsiaSouth1          BaseConnectionInfoChronicleV2Region = "asia-south1"
	BaseConnectionInfoChronicleV2RegionAsiaSoutheast1      BaseConnectionInfoChronicleV2Region = "asia-southeast1"
	BaseConnectionInfoChronicleV2RegionAustraliaSoutheast1 BaseConnectionInfoChronicleV2Region = "australia-southeast1"
	BaseConnectionInfoChronicleV2RegionEurope              BaseConnectionInfoChronicleV2Region = "europe"
	BaseConnectionInfoChronicleV2RegionEuropeWest2         BaseConnectionInfoChronicleV2Region = "europe-west2"
	BaseConnectionInfoChronicleV2RegionEuropeWest3         BaseConnectionInfoChronicleV2Region = "europe-west3"
	BaseConnectionInfoChronicleV2RegionEuropeWest6         BaseConnectionInfoChronicleV2Region = "europe-west6"
	BaseConnectionInfoChronicleV2RegionMeCentral2          BaseConnectionInfoChronicleV2Region = "me-central2"
	BaseConnectionInfoChronicleV2RegionMeWest1             BaseConnectionInfoChronicleV2Region = "me-west1"
	BaseConnectionInfoChronicleV2RegionUs                  BaseConnectionInfoChronicleV2Region = "us"
)

// Defines values for BaseConnectionInfoElasticsearchAuth.
const (
	BaseConnectionInfoElasticsearchAuthBASICAUTH   BaseConnectionInfoElasticsearchAuth = "BASIC_AUTH"
	BaseConnectionInfoElasticsearchAuthBEARERTOKEN BaseConnectionInfoElasticsearchAuth = "BEARER_TOKEN"
)

// Defines values for BaseConnectionInfoElasticsearchFormat.
const (
	BaseConnectionInfoElasticsearchFormatKVPAIRS BaseConnectionInfoElasticsearchFormat = "KV_PAIRS"
)

// Defines values for BaseConnectionInfoKafkaBalancer.
const (
	BaseConnectionInfoKafkaBalancerCrc32      BaseConnectionInfoKafkaBalancer = "crc32"
	BaseConnectionInfoKafkaBalancerHash       BaseConnectionInfoKafkaBalancer = "hash"
	BaseConnectionInfoKafkaBalancerLeastbytes BaseConnectionInfoKafkaBalancer = "leastbytes"
	BaseConnectionInfoKafkaBalancerMurmur2    BaseConnectionInfoKafkaBalancer = "murmur2"
	BaseConnectionInfoKafkaBalancerRoundrobin BaseConnectionInfoKafkaBalancer = "roundrobin"
)

// Defines values for BaseConnectionInfoKafkaCompression.
const (
	BaseConnectionInfoKafkaCompressionGzip   BaseConnectionInfoKafkaCompression = "gzip"
	BaseConnectionInfoKafkaCompressionLz4    BaseConnectionInfoKafkaCompression = "lz4"
	BaseConnectionInfoKafkaCompressionSnappy BaseConnectionInfoKafkaCompression = "snappy"
	BaseConnectionInfoKafkaCompressionZstd   BaseConnectionInfoKafkaCompression = "zstd"
)

// Defines values for BaseConnectionInfoKafkaV1Balancer.
const (
	BaseConnectionInfoKafkaV1BalancerCrc32      BaseConnectionInfoKafkaV1Balancer = "crc32"
	BaseConnectionInfoKafkaV1BalancerHash       BaseConnectionInfoKafkaV1Balancer = "hash"
	BaseConnectionInfoKafkaV1BalancerLeastbytes BaseConnectionInfoKafkaV1Balancer = "leastbytes"
	BaseConnectionInfoKafkaV1BalancerMurmur2    BaseConnectionInfoKafkaV1Balancer = "murmur2"
	BaseConnectionInfoKafkaV1BalancerRoundrobin BaseConnectionInfoKafkaV1Balancer = "roundrobin"
)

// Defines values for BaseConnectionInfoKafkaV1Compression.
const (
	BaseConnectionInfoKafkaV1CompressionGzip   BaseConnectionInfoKafkaV1Compression = "gzip"
	BaseConnectionInfoKafkaV1CompressionLz4    BaseConnectionInfoKafkaV1Compression = "lz4"
	BaseConnectionInfoKafkaV1CompressionSnappy BaseConnectionInfoKafkaV1Compression = "snappy"
	BaseConnectionInfoKafkaV1CompressionZstd   BaseConnectionInfoKafkaV1Compression = "zstd"
)

// Defines values for BaseConnectionInfoSyslogFormatter.
const (
	CEF  BaseConnectionInfoSyslogFormatter = "CEF"
	JSON BaseConnectionInfoSyslogFormatter = "JSON"
	LEEF BaseConnectionInfoSyslogFormatter = "LEEF"
)

// Defines values for BaseConnectionInfoSyslogMessageFormat.
const (
	RFC3164 BaseConnectionInfoSyslogMessageFormat = "RFC_3164"
	RFC5424 BaseConnectionInfoSyslogMessageFormat = "RFC_5424"
	RFC5425 BaseConnectionInfoSyslogMessageFormat = "RFC_5425"
)

// Defines values for BaseConnectionInfoWebhookAuth.
const (
	BaseConnectionInfoWebhookAuthBASICAUTH   BaseConnectionInfoWebhookAuth = "BASIC_AUTH"
	BaseConnectionInfoWebhookAuthBEARERTOKEN BaseConnectionInfoWebhookAuth = "BEARER_TOKEN"
	BaseConnectionInfoWebhookAuthCERTIFICATE BaseConnectionInfoWebhookAuth = "CERTIFICATE"
	BaseConnectionInfoWebhookAuthSIGNATURE   BaseConnectionInfoWebhookAuth = "SIGNATURE"
)

// Defines values for BaseConnectionInfoWebhookOutput.
const (
	BaseConnectionInfoWebhookOutputJson   BaseConnectionInfoWebhookOutput = "json"
	BaseConnectionInfoWebhookOutputNdjson BaseConnectionInfoWebhookOutput = "ndjson"
)

// Defines values for BaseConnectionInfoWebhookTimestampFormat.
const (
	BaseConnectionInfoWebhookTimestampFormatMicroseconds BaseConnectionInfoWebhookTimestampFormat = "microseconds"
	BaseConnectionInfoWebhookTimestampFormatMilliseconds BaseConnectionInfoWebhookTimestampFormat = "milliseconds"
	BaseConnectionInfoWebhookTimestampFormatNanoseconds  BaseConnectionInfoWebhookTimestampFormat = "nanoseconds"
	BaseConnectionInfoWebhookTimestampFormatSeconds      BaseConnectionInfoWebhookTimestampFormat = "seconds"
)

// Defines values for BaseRiskAcceptedPayloadReason.
const (
	BaseRiskAcceptedPayloadReasonCustom          BaseRiskAcceptedPayloadReason = "Custom"
	BaseRiskAcceptedPayloadReasonRiskAvoided     BaseRiskAcceptedPayloadReason = "RiskAvoided"
	BaseRiskAcceptedPayloadReasonRiskMitigated   BaseRiskAcceptedPayloadReason = "RiskMitigated"
	BaseRiskAcceptedPayloadReasonRiskNotRelevant BaseRiskAcceptedPayloadReason = "RiskNotRelevant"
	BaseRiskAcceptedPayloadReasonRiskOwned       BaseRiskAcceptedPayloadReason = "RiskOwned"
	BaseRiskAcceptedPayloadReasonRiskTransferred BaseRiskAcceptedPayloadReason = "RiskTransferred"
)

// Defines values for BaseRiskAcceptedPayloadStages.
const (
	BaseRiskAcceptedPayloadStagesPipeline BaseRiskAcceptedPayloadStages = "pipeline"
	BaseRiskAcceptedPayloadStagesRegistry BaseRiskAcceptedPayloadStages = "registry"
	BaseRiskAcceptedPayloadStagesRuntime  BaseRiskAcceptedPayloadStages = "runtime"
)

// Defines values for BaseRiskAcceptedResponsePayloadStatus.
const (
	BaseRiskAcceptedResponsePayloadStatusActive  BaseRiskAcceptedResponsePayloadStatus = "active"
	BaseRiskAcceptedResponsePayloadStatusExpired BaseRiskAcceptedResponsePayloadStatus = "expired"
)

// Defines values for BundleType.
const (
	BundleTypeCustom     BundleType = "custom"
	BundleTypePredefined BundleType = "predefined"
)

// Defines values for Category.
const (
	CategoryAdmissionController Category = "admissionController"
	CategoryCloudtrail          Category = "cloudtrail"
	CategoryFalcocloud          Category = "falcocloud"
	CategoryGithub              Category = "github"
	CategoryMiner               Category = "miner"
	CategoryOkta                Category = "okta"
	CategoryRemote              Category = "remote"
	CategoryRuntime             Category = "runtime"
)

// Defines values for CisaKevAvailableSinceType.
const (
	CisaKevAvailableSinceTypeCisaKevAvailableSince CisaKevAvailableSinceType = "cisaKevAvailableSince"
)

// Defines values for CisaKevKnownRansomwareCampaignUseType.
const (
	CisaKevKnownRansomwareCampaignUseTypeCisaKevKnownRansomwareCampaignUse CisaKevKnownRansomwareCampaignUseType = "cisaKevKnownRansomwareCampaignUse"
)

// Defines values for CisaKevPublishDateType.
const (
	CisaKevDueDateIn CisaKevPublishDateType = "cisaKevDueDateIn"
)

// Defines values for CommandType.
const (
	CommandTypeCommand CommandType = "command"
)

// Defines values for ConnectionDirection.
const (
	ConnectionDirectionIn  ConnectionDirection = "in"
	ConnectionDirectionOut ConnectionDirection = "out"
)

// Defines values for ConnectionType.
const (
	ConnectionTypeConnection ConnectionType = "connection"
)

// Defines values for CreateChronicleIntegrationConnInfoRegion.
const (
	CreateChronicleIntegrationConnInfoRegionAsiaSoutheast1 CreateChronicleIntegrationConnInfoRegion = "asia-southeast1"
	CreateChronicleIntegrationConnInfoRegionEurope         CreateChronicleIntegrationConnInfoRegion = "europe"
	CreateChronicleIntegrationConnInfoRegionUs             CreateChronicleIntegrationConnInfoRegion = "us"
)

// Defines values for CreateChronicleIntegrationConnInfoV2Region.
const (
	CreateChronicleIntegrationConnInfoV2RegionAsiaNortheast1      CreateChronicleIntegrationConnInfoV2Region = "asia-northeast1"
	CreateChronicleIntegrationConnInfoV2RegionAsiaSouth1          CreateChronicleIntegrationConnInfoV2Region = "asia-south1"
	CreateChronicleIntegrationConnInfoV2RegionAsiaSoutheast1      CreateChronicleIntegrationConnInfoV2Region = "asia-southeast1"
	CreateChronicleIntegrationConnInfoV2RegionAustraliaSoutheast1 CreateChronicleIntegrationConnInfoV2Region = "australia-southeast1"
	CreateChronicleIntegrationConnInfoV2RegionEurope              CreateChronicleIntegrationConnInfoV2Region = "europe"
	CreateChronicleIntegrationConnInfoV2RegionEuropeWest2         CreateChronicleIntegrationConnInfoV2Region = "europe-west2"
	CreateChronicleIntegrationConnInfoV2RegionEuropeWest3         CreateChronicleIntegrationConnInfoV2Region = "europe-west3"
	CreateChronicleIntegrationConnInfoV2RegionEuropeWest6         CreateChronicleIntegrationConnInfoV2Region = "europe-west6"
	CreateChronicleIntegrationConnInfoV2RegionMeCentral2          CreateChronicleIntegrationConnInfoV2Region = "me-central2"
	CreateChronicleIntegrationConnInfoV2RegionMeWest1             CreateChronicleIntegrationConnInfoV2Region = "me-west1"
	CreateChronicleIntegrationConnInfoV2RegionUs                  CreateChronicleIntegrationConnInfoV2Region = "us"
)

// Defines values for CreateRiskAcceptedRequestEntityType.
const (
	CreateRiskAcceptedRequestEntityTypeHostName          CreateRiskAcceptedRequestEntityType = "hostName"
	CreateRiskAcceptedRequestEntityTypeHostNameContains  CreateRiskAcceptedRequestEntityType = "hostNameContains"
	CreateRiskAcceptedRequestEntityTypeImageName         CreateRiskAcceptedRequestEntityType = "imageName"
	CreateRiskAcceptedRequestEntityTypeImageNameContains CreateRiskAcceptedRequestEntityType = "imageNameContains"
	CreateRiskAcceptedRequestEntityTypeImagePrefix       CreateRiskAcceptedRequestEntityType = "imagePrefix"
	CreateRiskAcceptedRequestEntityTypeImageSuffix       CreateRiskAcceptedRequestEntityType = "imageSuffix"
	CreateRiskAcceptedRequestEntityTypePackage           CreateRiskAcceptedRequestEntityType = "package"
	CreateRiskAcceptedRequestEntityTypePolicyRule        CreateRiskAcceptedRequestEntityType = "policyRule"
	CreateRiskAcceptedRequestEntityTypeVulnerability     CreateRiskAcceptedRequestEntityType = "vulnerability"
)

// Defines values for CreateRiskAcceptedRequestReason.
const (
	CreateRiskAcceptedRequestReasonCustom          CreateRiskAcceptedRequestReason = "Custom"
	CreateRiskAcceptedRequestReasonRiskAvoided     CreateRiskAcceptedRequestReason = "RiskAvoided"
	CreateRiskAcceptedRequestReasonRiskMitigated   CreateRiskAcceptedRequestReason = "RiskMitigated"
	CreateRiskAcceptedRequestReasonRiskNotRelevant CreateRiskAcceptedRequestReason = "RiskNotRelevant"
	CreateRiskAcceptedRequestReasonRiskOwned       CreateRiskAcceptedRequestReason = "RiskOwned"
	CreateRiskAcceptedRequestReasonRiskTransferred CreateRiskAcceptedRequestReason = "RiskTransferred"
)

// Defines values for CreateRiskAcceptedRequestStages.
const (
	CreateRiskAcceptedRequestStagesPipeline CreateRiskAcceptedRequestStages = "pipeline"
	CreateRiskAcceptedRequestStagesRegistry CreateRiskAcceptedRequestStages = "registry"
	CreateRiskAcceptedRequestStagesRuntime  CreateRiskAcceptedRequestStages = "runtime"
)

// Defines values for DenyCveType.
const (
	DenyCVE DenyCveType = "denyCVE"
)

// Defines values for DenyPkgType.
const (
	DenyPkgTypeDenyPkg DenyPkgType = "denyPkg"
)

// Defines values for EntityDefinitionDefinitionDefType.
const (
	Entity       EntityDefinitionDefinitionDefType = "Entity"
	Field        EntityDefinitionDefinitionDefType = "Field"
	Function     EntityDefinitionDefinitionDefType = "Function"
	Query        EntityDefinitionDefinitionDefType = "Query"
	Relationship EntityDefinitionDefinitionDefType = "Relationship"
	Union        EntityDefinitionDefinitionDefType = "Union"
)

// Defines values for EntityDefinitionDefinitionType.
const (
	EntityDefinitionDefinitionTypeBigInt   EntityDefinitionDefinitionType = "BigInt"
	EntityDefinitionDefinitionTypeBoolean  EntityDefinitionDefinitionType = "Boolean"
	EntityDefinitionDefinitionTypeDateTime EntityDefinitionDefinitionType = "DateTime"
	EntityDefinitionDefinitionTypeEnum     EntityDefinitionDefinitionType = "Enum"
	EntityDefinitionDefinitionTypeFloat    EntityDefinitionDefinitionType = "Float"
	EntityDefinitionDefinitionTypeInteger  EntityDefinitionDefinitionType = "Integer"
	EntityDefinitionDefinitionTypeList     EntityDefinitionDefinitionType = "List"
	EntityDefinitionDefinitionTypeString   EntityDefinitionDefinitionType = "String"
)

// Defines values for EntryPointModuleV1.
const (
	Alerts             EntryPointModuleV1 = "Alerts"
	DashboardTemplates EntryPointModuleV1 = "DashboardTemplates"
	Dashboards         EntryPointModuleV1 = "Dashboards"
	Events             EntryPointModuleV1 = "Events"
	Explore            EntryPointModuleV1 = "Explore"
	Overview           EntryPointModuleV1 = "Overview"
	Settings           EntryPointModuleV1 = "Settings"
)

// Defines values for EventContentType.
const (
	AgentlessMLRuntimeDetection EventContentType = "agentlessMLRuntimeDetection"
	AgentlessRuntimeDetection   EventContentType = "agentlessRuntimeDetection"
	K8sAdmissionReview          EventContentType = "k8sAdmissionReview"
	StatefulDetections          EventContentType = "statefulDetections"
	WorkloadMLRuntimeDetection  EventContentType = "workloadMLRuntimeDetection"
	WorkloadRuntimeDetection    EventContentType = "workloadRuntimeDetection"
)

// Defines values for FileaccessType.
const (
	FileaccessTypeFileaccess FileaccessType = "fileaccess"
)

// Defines values for GetBundleResponseBundleType.
const (
	GetBundleResponseBundleTypeCustom     GetBundleResponseBundleType = "custom"
	GetBundleResponseBundleTypePredefined GetBundleResponseBundleType = "predefined"
)

// Defines values for GetKafkaIntegrationResponseV1ConnectionInfoAuth.
const (
	GetKafkaIntegrationResponseV1ConnectionInfoAuthGssapi GetKafkaIntegrationResponseV1ConnectionInfoAuth = "gssapi"
)

// Defines values for GetKafkaIntegrationResponseV1ConnectionInfoBalancer.
const (
	GetKafkaIntegrationResponseV1ConnectionInfoBalancerCrc32      GetKafkaIntegrationResponseV1ConnectionInfoBalancer = "crc32"
	GetKafkaIntegrationResponseV1ConnectionInfoBalancerHash       GetKafkaIntegrationResponseV1ConnectionInfoBalancer = "hash"
	GetKafkaIntegrationResponseV1ConnectionInfoBalancerLeastbytes GetKafkaIntegrationResponseV1ConnectionInfoBalancer = "leastbytes"
	GetKafkaIntegrationResponseV1ConnectionInfoBalancerMurmur2    GetKafkaIntegrationResponseV1ConnectionInfoBalancer = "murmur2"
	GetKafkaIntegrationResponseV1ConnectionInfoBalancerRoundrobin GetKafkaIntegrationResponseV1ConnectionInfoBalancer = "roundrobin"
)

// Defines values for GetKafkaIntegrationResponseV1ConnectionInfoCompression.
const (
	GetKafkaIntegrationResponseV1ConnectionInfoCompressionGzip   GetKafkaIntegrationResponseV1ConnectionInfoCompression = "gzip"
	GetKafkaIntegrationResponseV1ConnectionInfoCompressionLz4    GetKafkaIntegrationResponseV1ConnectionInfoCompression = "lz4"
	GetKafkaIntegrationResponseV1ConnectionInfoCompressionSnappy GetKafkaIntegrationResponseV1ConnectionInfoCompression = "snappy"
	GetKafkaIntegrationResponseV1ConnectionInfoCompressionZstd   GetKafkaIntegrationResponseV1ConnectionInfoCompression = "zstd"
)

// Defines values for GroupMappingSettingsV1DifferentRolesSameTeamStrategy.
const (
	GroupMappingSettingsV1DifferentRolesSameTeamStrategyFIRSTMATCH     GroupMappingSettingsV1DifferentRolesSameTeamStrategy = "FIRST_MATCH"
	GroupMappingSettingsV1DifferentRolesSameTeamStrategyUNAUTHORIZED   GroupMappingSettingsV1DifferentRolesSameTeamStrategy = "UNAUTHORIZED"
	GroupMappingSettingsV1DifferentRolesSameTeamStrategyWEIGHTED       GroupMappingSettingsV1DifferentRolesSameTeamStrategy = "WEIGHTED"
	GroupMappingSettingsV1DifferentRolesSameTeamStrategyWEIGHTEDBYTEAM GroupMappingSettingsV1DifferentRolesSameTeamStrategy = "WEIGHTED_BY_TEAM"
)

// Defines values for GroupMappingSettingsV1NoMappingStrategy.
const (
	GroupMappingSettingsV1NoMappingStrategyDEFAULTTEAMDEFAULTROLE  GroupMappingSettingsV1NoMappingStrategy = "DEFAULT_TEAM_DEFAULT_ROLE"
	GroupMappingSettingsV1NoMappingStrategyNOMAPPINGSERRORREDIRECT GroupMappingSettingsV1NoMappingStrategy = "NO_MAPPINGS_ERROR_REDIRECT"
	GroupMappingSettingsV1NoMappingStrategyUNAUTHORIZED            GroupMappingSettingsV1NoMappingStrategy = "UNAUTHORIZED"
)

// Defines values for GssapiConnectionInfoKafkaV1Auth.
const (
	GssapiConnectionInfoKafkaV1AuthGssapi GssapiConnectionInfoKafkaV1Auth = "gssapi"
)

// Defines values for HostNameContextType.
const (
	HostNameContextTypeHostName HostNameContextType = "hostName"
)

// Defines values for HostNameContainsContextType.
const (
	HostNameContainsContextTypeHostNameContains HostNameContainsContextType = "hostNameContains"
)

// Defines values for ImageConfigCreationDateWithAgeType.
const (
	ImageConfigCreationDateWithAgeTypeImageConfigCreationDateWithAge ImageConfigCreationDateWithAgeType = "imageConfigCreationDateWithAge"
)

// Defines values for ImageConfigDefaultUserIsNotType.
const (
	ImageConfigDefaultUserIsNotTypeImageConfigDefaultUserIsNot ImageConfigDefaultUserIsNotType = "imageConfigDefaultUserIsNot"
)

// Defines values for ImageConfigDefaultUserIsRootType.
const (
	ImageConfigDefaultUserIsRootTypeImageConfigDefaultUserIsRoot ImageConfigDefaultUserIsRootType = "imageConfigDefaultUserIsRoot"
)

// Defines values for ImageConfigDefaultUserListExtraOperator.
const (
	IN    ImageConfigDefaultUserListExtraOperator = "IN"
	NOTIN ImageConfigDefaultUserListExtraOperator = "NOT_IN"
)

// Defines values for ImageConfigDefaultUserListType.
const (
	ImageConfigDefaultUserListTypeImageConfigDefaultUserList ImageConfigDefaultUserListType = "imageConfigDefaultUserList"
)

// Defines values for ImageConfigEnvVariableContainsType.
const (
	ImageConfigEnvVariableContainsTypeImageConfigEnvVariableContains ImageConfigEnvVariableContainsType = "imageConfigEnvVariableContains"
)

// Defines values for ImageConfigEnvVariableExistsType.
const (
	ImageConfigEnvVariableExistsTypeImageConfigEnvVariableExists ImageConfigEnvVariableExistsType = "imageConfigEnvVariableExists"
)

// Defines values for ImageConfigEnvVariableNotExistsType.
const (
	ImageConfigEnvVariableNotExistsTypeImageConfigEnvVariableNotExists ImageConfigEnvVariableNotExistsType = "imageConfigEnvVariableNotExists"
)

// Defines values for ImageConfigInstructionIsPkgManagerType.
const (
	ImageConfigInstructionIsPkgManagerTypeImageConfigInstructionIsPkgManager ImageConfigInstructionIsPkgManagerType = "imageConfigInstructionIsPkgManager"
)

// Defines values for ImageConfigInstructionNotRecommendedType.
const (
	ImageConfigInstructionNotRecommendedTypeImageConfigInstructionNotRecommended ImageConfigInstructionNotRecommendedType = "imageConfigInstructionNotRecommended"
)

// Defines values for ImageConfigLabelExistsType.
const (
	ImageConfigLabelExistsTypeImageConfigLabelExists ImageConfigLabelExistsType = "imageConfigLabelExists"
)

// Defines values for ImageConfigLabelNotContainsType.
const (
	ImageConfigLabelNotContainsTypeImageConfigLabelNotContains ImageConfigLabelNotContainsType = "imageConfigLabelNotContains"
)

// Defines values for ImageConfigLabelNotExistsType.
const (
	ImageConfigLabelNotExistsTypeImageConfigLabelNotExists ImageConfigLabelNotExistsType = "imageConfigLabelNotExists"
)

// Defines values for ImageConfigSensitiveInformationAndSecretsType.
const (
	ImageConfigSensitiveInformationAndSecretsTypeImageConfigSensitiveInformationAndSecrets ImageConfigSensitiveInformationAndSecretsType = "imageConfigSensitiveInformationAndSecrets"
)

// Defines values for ImageMetadataArchitecture.
const (
	Amd64    ImageMetadataArchitecture = "amd64"
	Arm      ImageMetadataArchitecture = "arm"
	Arm64    ImageMetadataArchitecture = "arm64"
	Loong64  ImageMetadataArchitecture = "loong64"
	Mips     ImageMetadataArchitecture = "mips"
	Mips64   ImageMetadataArchitecture = "mips64"
	Mips64le ImageMetadataArchitecture = "mips64le"
	Mipsle   ImageMetadataArchitecture = "mipsle"
	N386     ImageMetadataArchitecture = "386"
	Ppc64    ImageMetadataArchitecture = "ppc64"
	Ppc64le  ImageMetadataArchitecture = "ppc64le"
	Riscv64  ImageMetadataArchitecture = "riscv64"
	S390x    ImageMetadataArchitecture = "s390x"
	Wasm     ImageMetadataArchitecture = "wasm"
)

// Defines values for ImageNameContextType.
const (
	ImageNameContextTypeImageName ImageNameContextType = "imageName"
)

// Defines values for ImageNameContainsContextType.
const (
	ImageNameContainsContextTypeImageNameContains ImageNameContainsContextType = "imageNameContains"
)

// Defines values for ImagePrefixContextType.
const (
	ImagePrefixContextTypeImagePrefix ImagePrefixContextType = "imagePrefix"
)

// Defines values for ImageSuffixContextType.
const (
	ImageSuffixContextTypeImageSuffix ImageSuffixContextType = "imageSuffix"
)

// Defines values for IntegrationChannel.
const (
	ACTIVITYAUDIT        IntegrationChannel = "ACTIVITY_AUDIT"
	MONITOREVENTS        IntegrationChannel = "MONITOR_EVENTS"
	PLATFORMAUDIT        IntegrationChannel = "PLATFORM_AUDIT"
	SECUREEVENTSPOLICIES IntegrationChannel = "SECURE_EVENTS_POLICIES"
)

// Defines values for IntegrationType.
const (
	IntegrationTypeCHRONICLE IntegrationType = "CHRONICLE"
	IntegrationTypeELASTIC   IntegrationType = "ELASTIC"
	IntegrationTypeKAFKA     IntegrationType = "KAFKA"
	IntegrationTypeMCM       IntegrationType = "MCM"
	IntegrationTypePUBSUB    IntegrationType = "PUBSUB"
	IntegrationTypeQRADAR    IntegrationType = "QRADAR"
	IntegrationTypeSCC       IntegrationType = "SCC"
	IntegrationTypeSENTINEL  IntegrationType = "SENTINEL"
	IntegrationTypeSPLUNK    IntegrationType = "SPLUNK"
	IntegrationTypeSQS       IntegrationType = "SQS"
	IntegrationTypeSYSLOG    IntegrationType = "SYSLOG"
	IntegrationTypeWEBHOOK   IntegrationType = "WEBHOOK"
)

// Defines values for IssueTypeFieldResponseV1Type.
const (
	IssueTypeFieldResponseV1TypeCheckbox IssueTypeFieldResponseV1Type = "checkbox"
	IssueTypeFieldResponseV1TypeDocument IssueTypeFieldResponseV1Type = "document"
	IssueTypeFieldResponseV1TypeLabel    IssueTypeFieldResponseV1Type = "label"
	IssueTypeFieldResponseV1TypeNumber   IssueTypeFieldResponseV1Type = "number"
	IssueTypeFieldResponseV1TypeText     IssueTypeFieldResponseV1Type = "text"
	IssueTypeFieldResponseV1TypeUser     IssueTypeFieldResponseV1Type = "user"
)

// Defines values for KafkaAuthenticatedConnectionInfoAuth.
const (
	KafkaAuthenticatedConnectionInfoAuthGssapi    KafkaAuthenticatedConnectionInfoAuth = "gssapi"
	KafkaAuthenticatedConnectionInfoAuthSaslplain KafkaAuthenticatedConnectionInfoAuth = "sasl/plain"
	KafkaAuthenticatedConnectionInfoAuthSaslscram KafkaAuthenticatedConnectionInfoAuth = "sasl/scram"
)

// Defines values for KafkaAuthenticatedPrivateConnectionInfoAuth.
const (
	KafkaAuthenticatedPrivateConnectionInfoAuthGssapi    KafkaAuthenticatedPrivateConnectionInfoAuth = "gssapi"
	KafkaAuthenticatedPrivateConnectionInfoAuthSaslplain KafkaAuthenticatedPrivateConnectionInfoAuth = "sasl/plain"
	KafkaAuthenticatedPrivateConnectionInfoAuthSaslscram KafkaAuthenticatedPrivateConnectionInfoAuth = "sasl/scram"
)

// Defines values for KafkaGssapiAuthenticatedConnectionInfoAuth.
const (
	KafkaGssapiAuthenticatedConnectionInfoAuthGssapi KafkaGssapiAuthenticatedConnectionInfoAuth = "gssapi"
)

// Defines values for KafkaGssapiAuthenticatedConnectionInfoBalancer.
const (
	KafkaGssapiAuthenticatedConnectionInfoBalancerCrc32      KafkaGssapiAuthenticatedConnectionInfoBalancer = "crc32"
	KafkaGssapiAuthenticatedConnectionInfoBalancerHash       KafkaGssapiAuthenticatedConnectionInfoBalancer = "hash"
	KafkaGssapiAuthenticatedConnectionInfoBalancerLeastbytes KafkaGssapiAuthenticatedConnectionInfoBalancer = "leastbytes"
	KafkaGssapiAuthenticatedConnectionInfoBalancerMurmur2    KafkaGssapiAuthenticatedConnectionInfoBalancer = "murmur2"
	KafkaGssapiAuthenticatedConnectionInfoBalancerRoundrobin KafkaGssapiAuthenticatedConnectionInfoBalancer = "roundrobin"
)

// Defines values for KafkaGssapiAuthenticatedConnectionInfoCompression.
const (
	KafkaGssapiAuthenticatedConnectionInfoCompressionGzip   KafkaGssapiAuthenticatedConnectionInfoCompression = "gzip"
	KafkaGssapiAuthenticatedConnectionInfoCompressionLz4    KafkaGssapiAuthenticatedConnectionInfoCompression = "lz4"
	KafkaGssapiAuthenticatedConnectionInfoCompressionSnappy KafkaGssapiAuthenticatedConnectionInfoCompression = "snappy"
	KafkaGssapiAuthenticatedConnectionInfoCompressionZstd   KafkaGssapiAuthenticatedConnectionInfoCompression = "zstd"
)

// Defines values for KafkaGssapiAuthenticatedPrivateConnectionInfoAuth.
const (
	KafkaGssapiAuthenticatedPrivateConnectionInfoAuthGssapi KafkaGssapiAuthenticatedPrivateConnectionInfoAuth = "gssapi"
)

// Defines values for KafkaGssapiAuthenticatedPrivateConnectionInfoBalancer.
const (
	KafkaGssapiAuthenticatedPrivateConnectionInfoBalancerCrc32      KafkaGssapiAuthenticatedPrivateConnectionInfoBalancer = "crc32"
	KafkaGssapiAuthenticatedPrivateConnectionInfoBalancerHash       KafkaGssapiAuthenticatedPrivateConnectionInfoBalancer = "hash"
	KafkaGssapiAuthenticatedPrivateConnectionInfoBalancerLeastbytes KafkaGssapiAuthenticatedPrivateConnectionInfoBalancer = "leastbytes"
	KafkaGssapiAuthenticatedPrivateConnectionInfoBalancerMurmur2    KafkaGssapiAuthenticatedPrivateConnectionInfoBalancer = "murmur2"
	KafkaGssapiAuthenticatedPrivateConnectionInfoBalancerRoundrobin KafkaGssapiAuthenticatedPrivateConnectionInfoBalancer = "roundrobin"
)

// Defines values for KafkaGssapiAuthenticatedPrivateConnectionInfoCompression.
const (
	KafkaGssapiAuthenticatedPrivateConnectionInfoCompressionGzip   KafkaGssapiAuthenticatedPrivateConnectionInfoCompression = "gzip"
	KafkaGssapiAuthenticatedPrivateConnectionInfoCompressionLz4    KafkaGssapiAuthenticatedPrivateConnectionInfoCompression = "lz4"
	KafkaGssapiAuthenticatedPrivateConnectionInfoCompressionSnappy KafkaGssapiAuthenticatedPrivateConnectionInfoCompression = "snappy"
	KafkaGssapiAuthenticatedPrivateConnectionInfoCompressionZstd   KafkaGssapiAuthenticatedPrivateConnectionInfoCompression = "zstd"
)

// Defines values for KafkaGssapiConnectionInfoAuth.
const (
	KafkaGssapiConnectionInfoAuthGssapi KafkaGssapiConnectionInfoAuth = "gssapi"
)

// Defines values for KafkaPlaintextIsTlsEnabled.
const (
	KafkaPlaintextIsTlsEnabledFalse KafkaPlaintextIsTlsEnabled = false
)

// Defines values for KafkaPlaintextV1IsTlsEnabled.
const (
	KafkaPlaintextV1IsTlsEnabledFalse KafkaPlaintextV1IsTlsEnabled = false
)

// Defines values for KafkaSaslPlainAuthenticatedConnectionInfoAuth.
const (
	KafkaSaslPlainAuthenticatedConnectionInfoAuthSaslplain KafkaSaslPlainAuthenticatedConnectionInfoAuth = "sasl/plain"
)

// Defines values for KafkaSaslPlainAuthenticatedConnectionInfoBalancer.
const (
	KafkaSaslPlainAuthenticatedConnectionInfoBalancerCrc32      KafkaSaslPlainAuthenticatedConnectionInfoBalancer = "crc32"
	KafkaSaslPlainAuthenticatedConnectionInfoBalancerHash       KafkaSaslPlainAuthenticatedConnectionInfoBalancer = "hash"
	KafkaSaslPlainAuthenticatedConnectionInfoBalancerLeastbytes KafkaSaslPlainAuthenticatedConnectionInfoBalancer = "leastbytes"
	KafkaSaslPlainAuthenticatedConnectionInfoBalancerMurmur2    KafkaSaslPlainAuthenticatedConnectionInfoBalancer = "murmur2"
	KafkaSaslPlainAuthenticatedConnectionInfoBalancerRoundrobin KafkaSaslPlainAuthenticatedConnectionInfoBalancer = "roundrobin"
)

// Defines values for KafkaSaslPlainAuthenticatedConnectionInfoCompression.
const (
	KafkaSaslPlainAuthenticatedConnectionInfoCompressionGzip   KafkaSaslPlainAuthenticatedConnectionInfoCompression = "gzip"
	KafkaSaslPlainAuthenticatedConnectionInfoCompressionLz4    KafkaSaslPlainAuthenticatedConnectionInfoCompression = "lz4"
	KafkaSaslPlainAuthenticatedConnectionInfoCompressionSnappy KafkaSaslPlainAuthenticatedConnectionInfoCompression = "snappy"
	KafkaSaslPlainAuthenticatedConnectionInfoCompressionZstd   KafkaSaslPlainAuthenticatedConnectionInfoCompression = "zstd"
)

// Defines values for KafkaSaslPlainAuthenticatedPrivateConnectionInfoAuth.
const (
	KafkaSaslPlainAuthenticatedPrivateConnectionInfoAuthSaslplain KafkaSaslPlainAuthenticatedPrivateConnectionInfoAuth = "sasl/plain"
)

// Defines values for KafkaSaslPlainAuthenticatedPrivateConnectionInfoBalancer.
const (
	KafkaSaslPlainAuthenticatedPrivateConnectionInfoBalancerCrc32      KafkaSaslPlainAuthenticatedPrivateConnectionInfoBalancer = "crc32"
	KafkaSaslPlainAuthenticatedPrivateConnectionInfoBalancerHash       KafkaSaslPlainAuthenticatedPrivateConnectionInfoBalancer = "hash"
	KafkaSaslPlainAuthenticatedPrivateConnectionInfoBalancerLeastbytes KafkaSaslPlainAuthenticatedPrivateConnectionInfoBalancer = "leastbytes"
	KafkaSaslPlainAuthenticatedPrivateConnectionInfoBalancerMurmur2    KafkaSaslPlainAuthenticatedPrivateConnectionInfoBalancer = "murmur2"
	KafkaSaslPlainAuthenticatedPrivateConnectionInfoBalancerRoundrobin KafkaSaslPlainAuthenticatedPrivateConnectionInfoBalancer = "roundrobin"
)

// Defines values for KafkaSaslPlainAuthenticatedPrivateConnectionInfoCompression.
const (
	KafkaSaslPlainAuthenticatedPrivateConnectionInfoCompressionGzip   KafkaSaslPlainAuthenticatedPrivateConnectionInfoCompression = "gzip"
	KafkaSaslPlainAuthenticatedPrivateConnectionInfoCompressionLz4    KafkaSaslPlainAuthenticatedPrivateConnectionInfoCompression = "lz4"
	KafkaSaslPlainAuthenticatedPrivateConnectionInfoCompressionSnappy KafkaSaslPlainAuthenticatedPrivateConnectionInfoCompression = "snappy"
	KafkaSaslPlainAuthenticatedPrivateConnectionInfoCompressionZstd   KafkaSaslPlainAuthenticatedPrivateConnectionInfoCompression = "zstd"
)

// Defines values for KafkaSaslPlainConnectionInfoAuth.
const (
	Saslplain KafkaSaslPlainConnectionInfoAuth = "sasl/plain"
)

// Defines values for KafkaSaslScramAuthenticatedConnectionInfoAlgorithm.
const (
	KafkaSaslScramAuthenticatedConnectionInfoAlgorithmSha256 KafkaSaslScramAuthenticatedConnectionInfoAlgorithm = "sha256"
	KafkaSaslScramAuthenticatedConnectionInfoAlgorithmSha512 KafkaSaslScramAuthenticatedConnectionInfoAlgorithm = "sha512"
)

// Defines values for KafkaSaslScramAuthenticatedConnectionInfoAuth.
const (
	KafkaSaslScramAuthenticatedConnectionInfoAuthSaslscram KafkaSaslScramAuthenticatedConnectionInfoAuth = "sasl/scram"
)

// Defines values for KafkaSaslScramAuthenticatedConnectionInfoBalancer.
const (
	KafkaSaslScramAuthenticatedConnectionInfoBalancerCrc32      KafkaSaslScramAuthenticatedConnectionInfoBalancer = "crc32"
	KafkaSaslScramAuthenticatedConnectionInfoBalancerHash       KafkaSaslScramAuthenticatedConnectionInfoBalancer = "hash"
	KafkaSaslScramAuthenticatedConnectionInfoBalancerLeastbytes KafkaSaslScramAuthenticatedConnectionInfoBalancer = "leastbytes"
	KafkaSaslScramAuthenticatedConnectionInfoBalancerMurmur2    KafkaSaslScramAuthenticatedConnectionInfoBalancer = "murmur2"
	KafkaSaslScramAuthenticatedConnectionInfoBalancerRoundrobin KafkaSaslScramAuthenticatedConnectionInfoBalancer = "roundrobin"
)

// Defines values for KafkaSaslScramAuthenticatedConnectionInfoCompression.
const (
	KafkaSaslScramAuthenticatedConnectionInfoCompressionGzip   KafkaSaslScramAuthenticatedConnectionInfoCompression = "gzip"
	KafkaSaslScramAuthenticatedConnectionInfoCompressionLz4    KafkaSaslScramAuthenticatedConnectionInfoCompression = "lz4"
	KafkaSaslScramAuthenticatedConnectionInfoCompressionSnappy KafkaSaslScramAuthenticatedConnectionInfoCompression = "snappy"
	KafkaSaslScramAuthenticatedConnectionInfoCompressionZstd   KafkaSaslScramAuthenticatedConnectionInfoCompression = "zstd"
)

// Defines values for KafkaSaslScramAuthenticatedPrivateConnectionInfoAlgorithm.
const (
	KafkaSaslScramAuthenticatedPrivateConnectionInfoAlgorithmSha256 KafkaSaslScramAuthenticatedPrivateConnectionInfoAlgorithm = "sha256"
	KafkaSaslScramAuthenticatedPrivateConnectionInfoAlgorithmSha512 KafkaSaslScramAuthenticatedPrivateConnectionInfoAlgorithm = "sha512"
)

// Defines values for KafkaSaslScramAuthenticatedPrivateConnectionInfoAuth.
const (
	KafkaSaslScramAuthenticatedPrivateConnectionInfoAuthSaslscram KafkaSaslScramAuthenticatedPrivateConnectionInfoAuth = "sasl/scram"
)

// Defines values for KafkaSaslScramAuthenticatedPrivateConnectionInfoBalancer.
const (
	KafkaSaslScramAuthenticatedPrivateConnectionInfoBalancerCrc32      KafkaSaslScramAuthenticatedPrivateConnectionInfoBalancer = "crc32"
	KafkaSaslScramAuthenticatedPrivateConnectionInfoBalancerHash       KafkaSaslScramAuthenticatedPrivateConnectionInfoBalancer = "hash"
	KafkaSaslScramAuthenticatedPrivateConnectionInfoBalancerLeastbytes KafkaSaslScramAuthenticatedPrivateConnectionInfoBalancer = "leastbytes"
	KafkaSaslScramAuthenticatedPrivateConnectionInfoBalancerMurmur2    KafkaSaslScramAuthenticatedPrivateConnectionInfoBalancer = "murmur2"
	KafkaSaslScramAuthenticatedPrivateConnectionInfoBalancerRoundrobin KafkaSaslScramAuthenticatedPrivateConnectionInfoBalancer = "roundrobin"
)

// Defines values for KafkaSaslScramAuthenticatedPrivateConnectionInfoCompression.
const (
	KafkaSaslScramAuthenticatedPrivateConnectionInfoCompressionGzip   KafkaSaslScramAuthenticatedPrivateConnectionInfoCompression = "gzip"
	KafkaSaslScramAuthenticatedPrivateConnectionInfoCompressionLz4    KafkaSaslScramAuthenticatedPrivateConnectionInfoCompression = "lz4"
	KafkaSaslScramAuthenticatedPrivateConnectionInfoCompressionSnappy KafkaSaslScramAuthenticatedPrivateConnectionInfoCompression = "snappy"
	KafkaSaslScramAuthenticatedPrivateConnectionInfoCompressionZstd   KafkaSaslScramAuthenticatedPrivateConnectionInfoCompression = "zstd"
)

// Defines values for KafkaSaslScramConnectionInfoAlgorithm.
const (
	Sha256 KafkaSaslScramConnectionInfoAlgorithm = "sha256"
	Sha512 KafkaSaslScramConnectionInfoAlgorithm = "sha512"
)

// Defines values for KafkaSaslScramConnectionInfoAuth.
const (
	Saslscram KafkaSaslScramConnectionInfoAuth = "sasl/scram"
)

// Defines values for KafkaTlsEncryptedIsTlsEnabled.
const (
	KafkaTlsEncryptedIsTlsEnabledTrue KafkaTlsEncryptedIsTlsEnabled = true
)

// Defines values for KafkaTlsEncryptedV1IsTlsEnabled.
const (
	KafkaTlsEncryptedV1IsTlsEnabledTrue KafkaTlsEncryptedV1IsTlsEnabled = true
)

// Defines values for KubernetesType.
const (
	KubernetesTypeKubernetes KubernetesType = "kubernetes"
)

// Defines values for LabelMatcherV1Operator.
const (
	EQUALS           LabelMatcherV1Operator = "EQUALS"
	NOTEQUALS        LabelMatcherV1Operator = "NOT_EQUALS"
	NOTREGEXPMATCHES LabelMatcherV1Operator = "NOT_REGEXP_MATCHES"
	REGEXPMATCHES    LabelMatcherV1Operator = "REGEXP_MATCHES"
)

// Defines values for NewRuleRuleType.
const (
	NewRuleRuleTypeImageConfigCreationDate                   NewRuleRuleType = "imageConfigCreationDate"
	NewRuleRuleTypeImageConfigDefaultUser                    NewRuleRuleType = "imageConfigDefaultUser"
	NewRuleRuleTypeImageConfigEnvVariable                    NewRuleRuleType = "imageConfigEnvVariable"
	NewRuleRuleTypeImageConfigInstructionIsPkgManager        NewRuleRuleType = "imageConfigInstructionIsPkgManager"
	NewRuleRuleTypeImageConfigInstructionNotRecommended      NewRuleRuleType = "imageConfigInstructionNotRecommended"
	NewRuleRuleTypeImageConfigLabel                          NewRuleRuleType = "imageConfigLabel"
	NewRuleRuleTypeImageConfigSensitiveInformationAndSecrets NewRuleRuleType = "imageConfigSensitiveInformationAndSecrets"
	NewRuleRuleTypePkgDenyList                               NewRuleRuleType = "pkgDenyList"
	NewRuleRuleTypeVulnDenyList                              NewRuleRuleType = "vulnDenyList"
	NewRuleRuleTypeVulnSeverityAndThreats                    NewRuleRuleType = "vulnSeverityAndThreats"
)

// Defines values for NewStageName.
const (
	NewStageNamePipeline NewStageName = "pipeline"
	NewStageNameRegistry NewStageName = "registry"
	NewStageNameRuntime  NewStageName = "runtime"
)

// Defines values for NotificationChannelTypeV1.
const (
	NotificationChannelTypeV1CUSTOMWEBHOOK          NotificationChannelTypeV1 = "CUSTOM_WEBHOOK"
	NotificationChannelTypeV1EMAIL                  NotificationChannelTypeV1 = "EMAIL"
	NotificationChannelTypeV1GCHAT                  NotificationChannelTypeV1 = "GCHAT"
	NotificationChannelTypeV1IBMEVENTNOTIFICATIONS  NotificationChannelTypeV1 = "IBM_EVENT_NOTIFICATIONS"
	NotificationChannelTypeV1MSTEAMS                NotificationChannelTypeV1 = "MS_TEAMS"
	NotificationChannelTypeV1OPSGENIE               NotificationChannelTypeV1 = "OPSGENIE"
	NotificationChannelTypeV1PAGERDUTY              NotificationChannelTypeV1 = "PAGER_DUTY"
	NotificationChannelTypeV1PROMETHEUSALERTMANAGER NotificationChannelTypeV1 = "PROMETHEUS_ALERT_MANAGER"
	NotificationChannelTypeV1SLACK                  NotificationChannelTypeV1 = "SLACK"
	NotificationChannelTypeV1SNS                    NotificationChannelTypeV1 = "SNS"
	NotificationChannelTypeV1TEAMEMAIL              NotificationChannelTypeV1 = "TEAM_EMAIL"
	NotificationChannelTypeV1VICTOROPS              NotificationChannelTypeV1 = "VICTOROPS"
	NotificationChannelTypeV1WEBHOOK                NotificationChannelTypeV1 = "WEBHOOK"
)

// Defines values for Operand.
const (
	OperandContains   Operand = "contains"
	OperandEmpty      Operand = "!="
	OperandEqual      Operand = "="
	OperandExists     Operand = "exists"
	OperandIn         Operand = "in"
	OperandNotExists  Operand = "not exists"
	OperandNotIn      Operand = "not in"
	OperandStartsWith Operand = "starts with"
)

// Defines values for Originator.
const (
	AdmissionController Originator = "admissionController"
	Falcocloud          Originator = "falcocloud"
	Policy              Originator = "policy"
	ProfilingDetection  Originator = "profilingDetection"
)

// Defines values for PackageNameContextType.
const (
	PackageNameContextTypePackageName PackageNameContextType = "packageName"
)

// Defines values for PackageNameVersionContextType.
const (
	PackageNameVersionContextTypePackageName    PackageNameVersionContextType = "packageName"
	PackageNameVersionContextTypePackageVersion PackageNameVersionContextType = "packageVersion"
)

// Defines values for PackagePathContextType.
const (
	PackagePathContextTypePackagePath PackagePathContextType = "packagePath"
)

// Defines values for PackagePathVersionContextType.
const (
	PackagePathVersionContextTypePackagePath    PackagePathVersionContextType = "packagePath"
	PackagePathVersionContextTypePackageVersion PackagePathVersionContextType = "packageVersion"
)

// Defines values for PackageVersionContextType.
const (
	PackageVersionContextTypePackageVersion PackageVersionContextType = "packageVersion"
)

// Defines values for PoliciesGlobalEvaluation.
const (
	PoliciesGlobalEvaluationAccepted PoliciesGlobalEvaluation = "accepted"
	PoliciesGlobalEvaluationFailed   PoliciesGlobalEvaluation = "failed"
	PoliciesGlobalEvaluationNoPolicy PoliciesGlobalEvaluation = "noPolicy"
	PoliciesGlobalEvaluationPassed   PoliciesGlobalEvaluation = "passed"
)

// Defines values for PolicyEvaluationEvaluation.
const (
	PolicyEvaluationEvaluationAccepted PolicyEvaluationEvaluation = "accepted"
	PolicyEvaluationEvaluationFailed   PolicyEvaluationEvaluation = "failed"
	PolicyEvaluationEvaluationNoPolicy PolicyEvaluationEvaluation = "noPolicy"
	PolicyEvaluationEvaluationPassed   PolicyEvaluationEvaluation = "passed"
)

// Defines values for PolicyEvaluationResult.
const (
	PolicyEvaluationResultAccepted      PolicyEvaluationResult = "accepted"
	PolicyEvaluationResultFailed        PolicyEvaluationResult = "failed"
	PolicyEvaluationResultNoPolicy      PolicyEvaluationResult = "noPolicy"
	PolicyEvaluationResultNotApplicable PolicyEvaluationResult = "notApplicable"
	PolicyEvaluationResultPassed        PolicyEvaluationResult = "passed"
)

// Defines values for PolicyOrigin.
const (
	SecureUI PolicyOrigin = "Secure UI"
	Sysdig   PolicyOrigin = "Sysdig"
	Tuner    PolicyOrigin = "Tuner"
)

// Defines values for PricingType.
const (
	PricingTypeCLUSTER PricingType = "CLUSTER"
	PricingTypeDEFAULT PricingType = "DEFAULT"
)

// Defines values for PrivateConnectionInfoElasticsearchAuth.
const (
	PrivateConnectionInfoElasticsearchAuthBASICAUTH   PrivateConnectionInfoElasticsearchAuth = "BASIC_AUTH"
	PrivateConnectionInfoElasticsearchAuthBEARERTOKEN PrivateConnectionInfoElasticsearchAuth = "BEARER_TOKEN"
)

// Defines values for Product.
const (
	ProductMonitor Product = "monitor"
	ProductSecure  Product = "secure"
)

// Defines values for PromqlMatcherOperator.
const (
	EQUAL         PromqlMatcherOperator = "EQUAL"
	NOTEQUAL      PromqlMatcherOperator = "NOT_EQUAL"
	REGEXMATCH    PromqlMatcherOperator = "REGEX_MATCH"
	REGEXNOTMATCH PromqlMatcherOperator = "REGEX_NOT_MATCH"
)

// Defines values for ResponderType.
const (
	ResponderTypeCLOUD   ResponderType = "CLOUD"
	ResponderTypeCLUSTER ResponderType = "CLUSTER"
	ResponderTypeHOST    ResponderType = "HOST"
)

// Defines values for RiskAcceptanceDefinitionStatus.
const (
	RiskAcceptanceDefinitionStatusActive  RiskAcceptanceDefinitionStatus = "active"
	RiskAcceptanceDefinitionStatusExpired RiskAcceptanceDefinitionStatus = "expired"
)

// Defines values for RiskAcceptedResponseEntityType.
const (
	RiskAcceptedResponseEntityTypeHostName          RiskAcceptedResponseEntityType = "hostName"
	RiskAcceptedResponseEntityTypeHostNameContains  RiskAcceptedResponseEntityType = "hostNameContains"
	RiskAcceptedResponseEntityTypeImageName         RiskAcceptedResponseEntityType = "imageName"
	RiskAcceptedResponseEntityTypeImageNameContains RiskAcceptedResponseEntityType = "imageNameContains"
	RiskAcceptedResponseEntityTypeImagePrefix       RiskAcceptedResponseEntityType = "imagePrefix"
	RiskAcceptedResponseEntityTypeImageSuffix       RiskAcceptedResponseEntityType = "imageSuffix"
	RiskAcceptedResponseEntityTypePackage           RiskAcceptedResponseEntityType = "package"
	RiskAcceptedResponseEntityTypePolicyRule        RiskAcceptedResponseEntityType = "policyRule"
	RiskAcceptedResponseEntityTypeVulnerability     RiskAcceptedResponseEntityType = "vulnerability"
)

// Defines values for RiskAcceptedResponseReason.
const (
	RiskAcceptedResponseReasonCustom          RiskAcceptedResponseReason = "Custom"
	RiskAcceptedResponseReasonRiskAvoided     RiskAcceptedResponseReason = "RiskAvoided"
	RiskAcceptedResponseReasonRiskMitigated   RiskAcceptedResponseReason = "RiskMitigated"
	RiskAcceptedResponseReasonRiskNotRelevant RiskAcceptedResponseReason = "RiskNotRelevant"
	RiskAcceptedResponseReasonRiskOwned       RiskAcceptedResponseReason = "RiskOwned"
	RiskAcceptedResponseReasonRiskTransferred RiskAcceptedResponseReason = "RiskTransferred"
)

// Defines values for RiskAcceptedResponseStages.
const (
	RiskAcceptedResponseStagesPipeline RiskAcceptedResponseStages = "pipeline"
	RiskAcceptedResponseStagesRegistry RiskAcceptedResponseStages = "registry"
	RiskAcceptedResponseStagesRuntime  RiskAcceptedResponseStages = "runtime"
)

// Defines values for RiskAcceptedResponseStatus.
const (
	Active  RiskAcceptedResponseStatus = "active"
	Expired RiskAcceptedResponseStatus = "expired"
)

// Defines values for RuleEvaluationResult.
const (
	RuleEvaluationResultAccepted      RuleEvaluationResult = "accepted"
	RuleEvaluationResultFailed        RuleEvaluationResult = "failed"
	RuleEvaluationResultNotApplicable RuleEvaluationResult = "notApplicable"
	RuleEvaluationResultPassed        RuleEvaluationResult = "passed"
)

// Defines values for RuleFailureType.
const (
	RuleFailureTypeImageConfigFailure RuleFailureType = "imageConfigFailure"
	RuleFailureTypePkgVulnFailure     RuleFailureType = "pkgVulnFailure"
)

// Defines values for SbomResultResponseBomFormat.
const (
	CycloneDX SbomResultResponseBomFormat = "CycloneDX"
)

// Defines values for SbomResultResponseCompositionsAggregate.
const (
	Complete     SbomResultResponseCompositionsAggregate = "complete"
	Incomplete   SbomResultResponseCompositionsAggregate = "incomplete"
	NotSpecified SbomResultResponseCompositionsAggregate = "not_specified"
	Unknown      SbomResultResponseCompositionsAggregate = "unknown"
)

// Defines values for SbomResultResponseMetadataLifecycle.
const (
	Operations SbomResultResponseMetadataLifecycle = "operations"
	PostBuild  SbomResultResponseMetadataLifecycle = "post-build"
)

// Defines values for ScanResultResponseAssetType.
const (
	ScanResultResponseAssetTypeContainerImage ScanResultResponseAssetType = "containerImage"
	ScanResultResponseAssetTypeHost           ScanResultResponseAssetType = "host"
)

// Defines values for ScanResultResponseStage.
const (
	ScanResultResponseStagePipeline ScanResultResponseStage = "pipeline"
	ScanResultResponseStageRegistry ScanResultResponseStage = "registry"
	ScanResultResponseStageRuntime  ScanResultResponseStage = "runtime"
)

// Defines values for ScopeTypeV1.
const (
	AGENT                 ScopeTypeV1 = "AGENT"
	AWSCLOUDWATCH         ScopeTypeV1 = "AWS_CLOUD_WATCH"
	HOSTCONTAINER         ScopeTypeV1 = "HOST_CONTAINER"
	IBMPLATFORMMETRICS    ScopeTypeV1 = "IBM_PLATFORM_METRICS"
	PROMETHEUSREMOTEWRITE ScopeTypeV1 = "PROMETHEUS_REMOTE_WRITE"
)

// Defines values for ServicesServiceType.
const (
	EVENTSFORWARDER ServicesServiceType = "EVENTS_FORWARDER"
)

// Defines values for Source.
const (
	AgentlessAwsMl         Source = "agentless-aws-ml"
	AgentlessOktaMl        Source = "agentless-okta-ml"
	AwsCloudtrail          Source = "aws_cloudtrail"
	Awscloudtrail          Source = "awscloudtrail"
	AzurePlatformlogs      Source = "azure_platformlogs"
	GcpAuditlog            Source = "gcp_auditlog"
	Github                 Source = "github"
	K8SAdmissionController Source = "K8SAdmissionController"
	K8sAudit               Source = "k8s_audit"
	Okta                   Source = "okta"
	Profiling              Source = "profiling"
	Syscall                Source = "syscall"
	Windows                Source = "windows"
)

// Defines values for SsoTypeV1.
const (
	OPENID SsoTypeV1 = "OPENID"
	SAML   SsoTypeV1 = "SAML"
)

// Defines values for SupportedFilterType.
const (
	SupportedFilterTypeDate   SupportedFilterType = "date"
	SupportedFilterTypeIp     SupportedFilterType = "ip"
	SupportedFilterTypeNumber SupportedFilterType = "number"
	SupportedFilterTypeString SupportedFilterType = "string"
)

// Defines values for TeamRoleV1.
const (
	ROLETEAMEDIT           TeamRoleV1 = "ROLE_TEAM_EDIT"
	ROLETEAMMANAGER        TeamRoleV1 = "ROLE_TEAM_MANAGER"
	ROLETEAMNONE           TeamRoleV1 = "ROLE_TEAM_NONE"
	ROLETEAMREAD           TeamRoleV1 = "ROLE_TEAM_READ"
	ROLETEAMSERVICEMANAGER TeamRoleV1 = "ROLE_TEAM_SERVICE_MANAGER"
	ROLETEAMSTANDARD       TeamRoleV1 = "ROLE_TEAM_STANDARD"
)

// Defines values for Types.
const (
	TypesCommands     Types = "commands"
	TypesConnections  Types = "connections"
	TypesFileaccesses Types = "fileaccesses"
	TypesKubernetes   Types = "kubernetes"
)

// Defines values for UpdateChronicleIntegrationConnInfoRegion.
const (
	UpdateChronicleIntegrationConnInfoRegionAsiaSoutheast1 UpdateChronicleIntegrationConnInfoRegion = "asia-southeast1"
	UpdateChronicleIntegrationConnInfoRegionEurope         UpdateChronicleIntegrationConnInfoRegion = "europe"
	UpdateChronicleIntegrationConnInfoRegionUs             UpdateChronicleIntegrationConnInfoRegion = "us"
)

// Defines values for UpdateChronicleIntegrationConnInfoV2Region.
const (
	UpdateChronicleIntegrationConnInfoV2RegionAsiaNortheast1      UpdateChronicleIntegrationConnInfoV2Region = "asia-northeast1"
	UpdateChronicleIntegrationConnInfoV2RegionAsiaSouth1          UpdateChronicleIntegrationConnInfoV2Region = "asia-south1"
	UpdateChronicleIntegrationConnInfoV2RegionAsiaSoutheast1      UpdateChronicleIntegrationConnInfoV2Region = "asia-southeast1"
	UpdateChronicleIntegrationConnInfoV2RegionAustraliaSoutheast1 UpdateChronicleIntegrationConnInfoV2Region = "australia-southeast1"
	UpdateChronicleIntegrationConnInfoV2RegionEurope              UpdateChronicleIntegrationConnInfoV2Region = "europe"
	UpdateChronicleIntegrationConnInfoV2RegionEuropeWest2         UpdateChronicleIntegrationConnInfoV2Region = "europe-west2"
	UpdateChronicleIntegrationConnInfoV2RegionEuropeWest3         UpdateChronicleIntegrationConnInfoV2Region = "europe-west3"
	UpdateChronicleIntegrationConnInfoV2RegionEuropeWest6         UpdateChronicleIntegrationConnInfoV2Region = "europe-west6"
	UpdateChronicleIntegrationConnInfoV2RegionMeCentral2          UpdateChronicleIntegrationConnInfoV2Region = "me-central2"
	UpdateChronicleIntegrationConnInfoV2RegionMeWest1             UpdateChronicleIntegrationConnInfoV2Region = "me-west1"
	UpdateChronicleIntegrationConnInfoV2RegionUs                  UpdateChronicleIntegrationConnInfoV2Region = "us"
)

// Defines values for UpdateElasticsearchIntegrationRequestConnectionInfoAuth.
const (
	UpdateElasticsearchIntegrationRequestConnectionInfoAuthBASICAUTH   UpdateElasticsearchIntegrationRequestConnectionInfoAuth = "BASIC_AUTH"
	UpdateElasticsearchIntegrationRequestConnectionInfoAuthBEARERTOKEN UpdateElasticsearchIntegrationRequestConnectionInfoAuth = "BEARER_TOKEN"
)

// Defines values for UpdateElasticsearchIntegrationRequestConnectionInfoFormat.
const (
	KVPAIRS UpdateElasticsearchIntegrationRequestConnectionInfoFormat = "KV_PAIRS"
)

// Defines values for UpdateKafkaIntegrationRequestV1ConnectionInfoAuth.
const (
	Gssapi UpdateKafkaIntegrationRequestV1ConnectionInfoAuth = "gssapi"
)

// Defines values for UpdateKafkaIntegrationRequestV1ConnectionInfoBalancer.
const (
	Crc32      UpdateKafkaIntegrationRequestV1ConnectionInfoBalancer = "crc32"
	Hash       UpdateKafkaIntegrationRequestV1ConnectionInfoBalancer = "hash"
	Leastbytes UpdateKafkaIntegrationRequestV1ConnectionInfoBalancer = "leastbytes"
	Murmur2    UpdateKafkaIntegrationRequestV1ConnectionInfoBalancer = "murmur2"
	Roundrobin UpdateKafkaIntegrationRequestV1ConnectionInfoBalancer = "roundrobin"
)

// Defines values for UpdateKafkaIntegrationRequestV1ConnectionInfoCompression.
const (
	Gzip   UpdateKafkaIntegrationRequestV1ConnectionInfoCompression = "gzip"
	Lz4    UpdateKafkaIntegrationRequestV1ConnectionInfoCompression = "lz4"
	Snappy UpdateKafkaIntegrationRequestV1ConnectionInfoCompression = "snappy"
	Zstd   UpdateKafkaIntegrationRequestV1ConnectionInfoCompression = "zstd"
)

// Defines values for UpdateRiskAcceptedReason.
const (
	UpdateRiskAcceptedReasonCustom          UpdateRiskAcceptedReason = "Custom"
	UpdateRiskAcceptedReasonRiskAvoided     UpdateRiskAcceptedReason = "RiskAvoided"
	UpdateRiskAcceptedReasonRiskMitigated   UpdateRiskAcceptedReason = "RiskMitigated"
	UpdateRiskAcceptedReasonRiskNotRelevant UpdateRiskAcceptedReason = "RiskNotRelevant"
	UpdateRiskAcceptedReasonRiskOwned       UpdateRiskAcceptedReason = "RiskOwned"
	UpdateRiskAcceptedReasonRiskTransferred UpdateRiskAcceptedReason = "RiskTransferred"
)

// Defines values for UpdateWebhookIntegrationRequestConnectionInfoAuth.
const (
	BASICAUTH   UpdateWebhookIntegrationRequestConnectionInfoAuth = "BASIC_AUTH"
	BEARERTOKEN UpdateWebhookIntegrationRequestConnectionInfoAuth = "BEARER_TOKEN"
	CERTIFICATE UpdateWebhookIntegrationRequestConnectionInfoAuth = "CERTIFICATE"
	SIGNATURE   UpdateWebhookIntegrationRequestConnectionInfoAuth = "SIGNATURE"
)

// Defines values for UpdateWebhookIntegrationRequestConnectionInfoOutput.
const (
	Json   UpdateWebhookIntegrationRequestConnectionInfoOutput = "json"
	Ndjson UpdateWebhookIntegrationRequestConnectionInfoOutput = "ndjson"
)

// Defines values for UpdateWebhookIntegrationRequestConnectionInfoTimestampFormat.
const (
	Microseconds UpdateWebhookIntegrationRequestConnectionInfoTimestampFormat = "microseconds"
	Milliseconds UpdateWebhookIntegrationRequestConnectionInfoTimestampFormat = "milliseconds"
	Nanoseconds  UpdateWebhookIntegrationRequestConnectionInfoTimestampFormat = "nanoseconds"
	Seconds      UpdateWebhookIntegrationRequestConnectionInfoTimestampFormat = "seconds"
)

// Defines values for VulnAgeType.
const (
	VulnAgeTypeVulnAge VulnAgeType = "vulnAge"
)

// Defines values for VulnCvssType.
const (
	VulnCVSS VulnCvssType = "vulnCVSS"
)

// Defines values for VulnCvssEqualsType.
const (
	VulnCVSSEquals VulnCvssEqualsType = "vulnCVSSEquals"
)

// Defines values for VulnDisclosureRangeType.
const (
	VulnDisclosureRangeTypeVulnDisclosureRange VulnDisclosureRangeType = "vulnDisclosureRange"
)

// Defines values for VulnEpssPercentileGteType.
const (
	VulnEpssPercentileGteTypeVulnEpssPercentileGte VulnEpssPercentileGteType = "vulnEpssPercentileGte"
)

// Defines values for VulnEpssScoreGteType.
const (
	VulnEpssScoreGteTypeVulnEpssScoreGte VulnEpssScoreGteType = "vulnEpssScoreGte"
)

// Defines values for VulnExploitableType.
const (
	VulnExploitableTypeVulnExploitable VulnExploitableType = "vulnExploitable"
)

// Defines values for VulnExploitableNoAdminType.
const (
	VulnExploitableNoAdminTypeVulnExploitableNoAdmin VulnExploitableNoAdminType = "vulnExploitableNoAdmin"
)

// Defines values for VulnExploitableNoUserType.
const (
	VulnExploitableNoUserTypeVulnExploitableNoUser VulnExploitableNoUserType = "vulnExploitableNoUser"
)

// Defines values for VulnExploitableViaNetworkType.
const (
	VulnExploitableViaNetworkTypeVulnExploitableViaNetwork VulnExploitableViaNetworkType = "vulnExploitableViaNetwork"
)

// Defines values for VulnExploitableWithAgeType.
const (
	VulnExploitableWithAgeTypeVulnExploitableWithAge VulnExploitableWithAgeType = "vulnExploitableWithAge"
)

// Defines values for VulnIsFixableType.
const (
	VulnIsFixableTypeVulnIsFixable VulnIsFixableType = "vulnIsFixable"
)

// Defines values for VulnIsFixableWithAgeType.
const (
	VulnIsFixableWithAgeTypeVulnIsFixableWithAge VulnIsFixableWithAgeType = "vulnIsFixableWithAge"
)

// Defines values for VulnIsInUseType.
const (
	VulnIsInUseTypeVulnIsInUse VulnIsInUseType = "vulnIsInUse"
)

// Defines values for VulnPkgTypeExtraPkgType.
const (
	NonOs VulnPkgTypeExtraPkgType = "nonOs"
	Os    VulnPkgTypeExtraPkgType = "os"
)

// Defines values for VulnPkgTypeType.
const (
	VulnPkgTypeTypeVulnPkgType VulnPkgTypeType = "vulnPkgType"
)

// Defines values for VulnSeverityExtraLevel.
const (
	VulnSeverityExtraLevelCritical   VulnSeverityExtraLevel = "critical"
	VulnSeverityExtraLevelHigh       VulnSeverityExtraLevel = "high"
	VulnSeverityExtraLevelLow        VulnSeverityExtraLevel = "low"
	VulnSeverityExtraLevelMedium     VulnSeverityExtraLevel = "medium"
	VulnSeverityExtraLevelNegligible VulnSeverityExtraLevel = "negligible"
)

// Defines values for VulnSeverityType.
const (
	VulnSeverityTypeVulnSeverity VulnSeverityType = "vulnSeverity"
)

// Defines values for VulnSeverityEqualsExtraLevel.
const (
	VulnSeverityEqualsExtraLevelCritical   VulnSeverityEqualsExtraLevel = "critical"
	VulnSeverityEqualsExtraLevelHigh       VulnSeverityEqualsExtraLevel = "high"
	VulnSeverityEqualsExtraLevelLow        VulnSeverityEqualsExtraLevel = "low"
	VulnSeverityEqualsExtraLevelMedium     VulnSeverityEqualsExtraLevel = "medium"
	VulnSeverityEqualsExtraLevelNegligible VulnSeverityEqualsExtraLevel = "negligible"
)

// Defines values for VulnSeverityEqualsType.
const (
	VulnSeverityEqualsTypeVulnSeverityEquals VulnSeverityEqualsType = "vulnSeverityEquals"
)

// Defines values for VulnerabilitySeverity.
const (
	VulnerabilitySeverityCritical   VulnerabilitySeverity = "critical"
	VulnerabilitySeverityHigh       VulnerabilitySeverity = "high"
	VulnerabilitySeverityLow        VulnerabilitySeverity = "low"
	VulnerabilitySeverityMedium     VulnerabilitySeverity = "medium"
	VulnerabilitySeverityNegligible VulnerabilitySeverity = "negligible"
)

// Defines values for RoleDisplayNamePath.
const (
	RoleDisplayNamePathAdvancedUser   RoleDisplayNamePath = "Advanced User"
	RoleDisplayNamePathServiceManager RoleDisplayNamePath = "Service Manager"
	RoleDisplayNamePathStandardUser   RoleDisplayNamePath = "Standard User"
	RoleDisplayNamePathTeamManager    RoleDisplayNamePath = "Team Manager"
	RoleDisplayNamePathViewOnly       RoleDisplayNamePath = "View Only"
)

// Defines values for SsoProductIdPath.
const (
	SsoProductIdPathMonitor SsoProductIdPath = "monitor"
	SsoProductIdPathSecure  SsoProductIdPath = "secure"
)

// Defines values for Order.
const (
	OrderAsc  Order = "asc"
	OrderDesc Order = "desc"
)

// Defines values for ListJobsV1ParamsIsReportTemplate.
const (
	False ListJobsV1ParamsIsReportTemplate = "false"
	True  ListJobsV1ParamsIsReportTemplate = "true"
)

// Defines values for ListJobsV1ParamsJobType.
const (
	ONDEMAND  ListJobsV1ParamsJobType = "ON_DEMAND"
	SCHEDULED ListJobsV1ParamsJobType = "SCHEDULED"
)

// Defines values for ListJobsV1ParamsStatus.
const (
	ListJobsV1ParamsStatusCOMPLETED ListJobsV1ParamsStatus = "COMPLETED"
	ListJobsV1ParamsStatusCREATED   ListJobsV1ParamsStatus = "CREATED"
	ListJobsV1ParamsStatusFAILED    ListJobsV1ParamsStatus = "FAILED"
	ListJobsV1ParamsStatusRUNNING   ListJobsV1ParamsStatus = "RUNNING"
)

// Defines values for ListJobsV1ParamsKind.
const (
	ComplianceReadiness     ListJobsV1ParamsKind = "compliance_readiness"
	VulnerabilityManagement ListJobsV1ParamsKind = "vulnerability_management"
)

// Defines values for GetDefaultRoleByDisplayNameV1ParamsRoleDisplayName.
const (
	GetDefaultRoleByDisplayNameV1ParamsRoleDisplayNameAdvancedUser   GetDefaultRoleByDisplayNameV1ParamsRoleDisplayName = "Advanced User"
	GetDefaultRoleByDisplayNameV1ParamsRoleDisplayNameServiceManager GetDefaultRoleByDisplayNameV1ParamsRoleDisplayName = "Service Manager"
	GetDefaultRoleByDisplayNameV1ParamsRoleDisplayNameStandardUser   GetDefaultRoleByDisplayNameV1ParamsRoleDisplayName = "Standard User"
	GetDefaultRoleByDisplayNameV1ParamsRoleDisplayNameTeamManager    GetDefaultRoleByDisplayNameV1ParamsRoleDisplayName = "Team Manager"
	GetDefaultRoleByDisplayNameV1ParamsRoleDisplayNameViewOnly       GetDefaultRoleByDisplayNameV1ParamsRoleDisplayName = "View Only"
)

// Defines values for GetGlobaSsoSettingsV1ParamsSsoProductId.
const (
	GetGlobaSsoSettingsV1ParamsSsoProductIdMonitor GetGlobaSsoSettingsV1ParamsSsoProductId = "monitor"
	GetGlobaSsoSettingsV1ParamsSsoProductIdSecure  GetGlobaSsoSettingsV1ParamsSsoProductId = "secure"
)

// Defines values for UpdateGlobalSsoSettingsV1ParamsSsoProductId.
const (
	UpdateGlobalSsoSettingsV1ParamsSsoProductIdMonitor UpdateGlobalSsoSettingsV1ParamsSsoProductId = "monitor"
	UpdateGlobalSsoSettingsV1ParamsSsoProductIdSecure  UpdateGlobalSsoSettingsV1ParamsSsoProductId = "secure"
)

// Defines values for GetSecureVulnerabilityV1PoliciesParamsStages.
const (
	GetSecureVulnerabilityV1PoliciesParamsStagesAdmissionControl GetSecureVulnerabilityV1PoliciesParamsStages = "admission_control"
	GetSecureVulnerabilityV1PoliciesParamsStagesPipeline         GetSecureVulnerabilityV1PoliciesParamsStages = "pipeline"
	GetSecureVulnerabilityV1PoliciesParamsStagesRegistry         GetSecureVulnerabilityV1PoliciesParamsStages = "registry"
	GetSecureVulnerabilityV1PoliciesParamsStagesRuntime          GetSecureVulnerabilityV1PoliciesParamsStages = "runtime"
)

// Defines values for ScannerAPIServiceListRuntimeResultsParamsSort.
const (
	ScannerAPIServiceListRuntimeResultsParamsSortRunningVulnTotalBySeverity ScannerAPIServiceListRuntimeResultsParamsSort = "runningVulnTotalBySeverity"
	ScannerAPIServiceListRuntimeResultsParamsSortVulnTotalBySeverity        ScannerAPIServiceListRuntimeResultsParamsSort = "vulnTotalBySeverity"
)

// Defines values for ScannerAPIServiceListRuntimeResultsParamsOrder.
const (
	ScannerAPIServiceListRuntimeResultsParamsOrderAsc  ScannerAPIServiceListRuntimeResultsParamsOrder = "asc"
	ScannerAPIServiceListRuntimeResultsParamsOrderDesc ScannerAPIServiceListRuntimeResultsParamsOrder = "desc"
)

// Defines values for GetAcceptedRisksV1ParamsOrder.
const (
	Asc  GetAcceptedRisksV1ParamsOrder = "asc"
	Desc GetAcceptedRisksV1ParamsOrder = "desc"
)

// Defines values for GetAcceptedRisksV1ParamsSort.
const (
	AcceptanceDate GetAcceptedRisksV1ParamsSort = "acceptanceDate"
	ExpirationDate GetAcceptedRisksV1ParamsSort = "expirationDate"
)

// Defines values for GetSBOMV1beta1ParamsAssetType.
const (
	GetSBOMV1beta1ParamsAssetTypeContainerImage GetSBOMV1beta1ParamsAssetType = "container-image"
	GetSBOMV1beta1ParamsAssetTypeHost           GetSBOMV1beta1ParamsAssetType = "host"
)

// AccessKeyResponseV1 Access key response
type AccessKeyResponseV1 struct {
	// AccessKey Displays the access key value
	AccessKey *string `json:"accessKey,omitempty"`

	// AgentLimit Maximum number of agents that can be connected with the access key
	AgentLimit *int32 `json:"agentLimit"`

	// AgentReservation Number of agents that are guaranteed to be available for the access key
	AgentReservation *int32 `json:"agentReservation"`

	// DateCreated Date and time when access key was created
	DateCreated *time.Time `json:"dateCreated"`

	// DateDisabled Date and time when access key was disabled
	DateDisabled *time.Time `json:"dateDisabled"`

	Id *UnlimitedLong `json:"id,omitempty"`

	// IsEnabled Indicates if the access key is enabled
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Metadata Access key metadata (maximum of 20 key-value pairs where key can be up to 25 characters long and value can be up to 50 characters long)
	Metadata *map[string]string `json:"metadata,omitempty"`

	// TeamId ID of team that owns the access key
	TeamId *int32 `json:"teamId"`
}

// Action Action performed when the event happened.
type Action struct {
	union json.RawMessage
}

// ActionExecution The submitted Response Action.
type ActionExecution struct {
	// ActionExecutionIdBeingUndone The ID of the Response Action being undone.
	ActionExecutionIdBeingUndone *string `json:"actionExecutionIdBeingUndone,omitempty"`

	// ActionType The name of the Response Action to execute.
	// It may be one of the following:
	// - KILL_PROCESS
	// - KILL_CONTAINER
	// - STOP_CONTAINER
	// - PAUSE_CONTAINER
	// - FILE_QUARANTINE
	// - FILE_ACQUIRE
	// - UNPAUSE_CONTAINER
	// - FILE_UNQUARANTINE
	// - START_CONTAINER
	// - DELETE_POD
	// - ROLLOUT_RESTART
	// - KUBERNETES_VOLUME_SNAPSHOT
	// - KUBERNETES_DELETE_VOLUME_SNAPSHOT
	// - GET_LOGS
	// - ISOLATE_NETWORK
	// - DELETE_NETWORK_POLICY
	//
	// The following actions serve as the undo for previous actions:
	// - START_CONTAINER: undo for STOP_CONTAINER\
	// - UNPAUSE_CONTAINER: undo for PAUSE_CONTAINER\
	// - FILE_UNQUARANTINE: undo for FILE_QUARANTINE\
	// - KUBERNETES_DELETE_VOLUME_SNAPSHOT: undo for KUBERNETES_VOLUME_SNAPSHOT\
	// - DELETE_NETWORK_POLICY: undo for ISOLATE_NETWORK\
	//
	// Do not use undo actions in [submitActionExecutionv1](#tag/Response-actions/operation/submitActionExecutionv1).
	//
	// You can execute an undo actions using the service [undoActionExecutionV1](#tag/Response-actions/operation/undoActionExecutionV1).
	ActionType ResponseActionType `json:"actionType"`

	// CallerId The ID of the user that executed the Response action.
	CallerId *CallerId `json:"callerId,omitempty"`

	// CreatedAt The date and time the Response Action was submitted.
	CreatedAt time.Time `json:"createdAt"`

	// ExecutionContext The context in which the Response Action is executed.\
	// It may contain additional information on the Response Action being executed, such as the host name or the MAC address.\
	// For example:\
	// ```json
	// {
	//     "host.hostName": "my-host",
	//     "host.mac": "00:00:00:00:00:00",
	//     "host.id": "abc123"
	// }
	// ```
	ExecutionContext ExecutionContext `json:"executionContext"`

	// Failure The reason a Response Action failed to execute.
	Failure *Failure `json:"failure,omitempty"`

	// Id The ID of the Response Action.
	Id string `json:"id"`

	// Outputs The parameters used to request the Response Action execution.
	Outputs *ActionExecutionOutputs `json:"outputs,omitempty"`

	// Parameters The parameters used to request the Response Action execution.
	Parameters ActionExecutionParameters `json:"parameters"`

	// ResponderType The type of Responder executing an action.
	ResponderType ResponderType `json:"responderType"`

	// Status The status of the action execution.
	Status ActionExecutionStatus `json:"status"`

	// UpdatedAt The date and time the Response Action was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// UserId The ID of the user that submitted the Response Action.
	UserId *int64 `json:"userId,omitempty"`
}

// ActionExecutionIntParameterValue The value of an int parameter.
type ActionExecutionIntParameterValue = int64

// ActionExecutionOutputs The parameters used to request the Response Action execution.
type ActionExecutionOutputs map[string]ActionExecutionParameterValue

// ActionExecutionParameterValue The value of a parameter.
type ActionExecutionParameterValue struct {
	union json.RawMessage
}

// ActionExecutionParameterValue2 The value of a boolean parameter.
type ActionExecutionParameterValue2 = bool

// ActionExecutionParameters The parameters used to request the Response Action execution.
type ActionExecutionParameters map[string]ActionExecutionParameterValue

// ActionExecutionStatus The status of the action execution.
type ActionExecutionStatus string

// ActionExecutionStringParameterValue The value of a string parameter.
type ActionExecutionStringParameterValue = string

// ActionExecutions A list of Response Action executions.
type ActionExecutions struct {
	// Data The list of Response Actions.
	Data []ActionExecution `json:"data"`
}

// ActionOutputsMetadata Metadata that describes a parameter returned by a Response Action execution.
type ActionOutputsMetadata struct {
	// Description The description of the output parameter.
	Description string `json:"description"`

	// Name The name of the output parameter.
	Name OutputParameterName `json:"name"`

	// Required If `true`, the parameter is mandatory.
	Required bool `json:"required"`

	// Type The type of an Response Action parameter.\
	// It may assume the following values:\
	// * string\
	// * integer\
	// * boolean\
	// This list of possible values may grow in the future.
	Type ParameterType `json:"type"`
}

// ActionParameterMetadata Metadata that describes a parameter to be submitted for a Response Action execution.
type ActionParameterMetadata struct {
	// Description The description of the parameter.
	Description string `json:"description"`

	// Name The name of the parameter.
	Name ActionParameterName `json:"name"`

	// Required If `true`, the parameter is mandatory.
	Required bool `json:"required"`

	// Type The type of an Response Action parameter.\
	// It may assume the following values:\
	// * string\
	// * integer\
	// * boolean\
	// This list of possible values may grow in the future.
	Type ParameterType `json:"type"`
}

// ActionParameterName The name of the parameter.
type ActionParameterName = string

// ActionType Action type.
type ActionType string

// Actions A list of Response Actions
type Actions struct {
	// Data The list of Response Actions.
	Data []ResponseAction `json:"data"`
}

// AdditionalTeamPermissionsV1 Additional permissions available to the users of the team.
type AdditionalTeamPermissionsV1 struct {
	HasAgentCli             *bool `json:"hasAgentCli,omitempty"`
	HasAwsData              *bool `json:"hasAwsData,omitempty"`
	HasBeaconMetrics        *bool `json:"hasBeaconMetrics,omitempty"`
	HasInfrastructureEvents *bool `json:"hasInfrastructureEvents,omitempty"`
	HasRapidResponse        *bool `json:"hasRapidResponse,omitempty"`

	// HasSysdigCaptures Enable the Sysdig captures feature for this team.
	HasSysdigCaptures *bool `json:"hasSysdigCaptures,omitempty"`
}

// AgentlessMlRuntimeDetectionContent defines model for AgentlessMlRuntimeDetectionContent.
type AgentlessMlRuntimeDetectionContent struct {
	Fields map[string]string `json:"fields"`

	// PolicyId ID of the policy that generated the event
	PolicyId *PolicyId `json:"policyId,omitempty"`

	// PolicyNotificationChannelIds The list of notification channels where an alert is sent after event is generated.
	// Doesn't account for aggregations and eventual thresholds.
	PolicyNotificationChannelIds *PolicyNotificationChannelIds `json:"policyNotificationChannelIds,omitempty"`

	// PolicyOrigin The policy author:
	// - `Sysdig` - default and managed policies
	// - `Sysdig UI` - users interacting with Sysdig
	// - `Tuner` - the automated tuner
	PolicyOrigin PolicyOrigin `json:"policyOrigin"`

	// RuleName Name of the rule the event is generated after
	RuleName RuleName `json:"ruleName"`

	// RuleType Rule type:
	// - 1 - List matching - process
	// - 2 - List matching - container
	// - 3 - List matching - file
	// - 4 - List matching - network
	// - 5 - List matching - syscall
	// - 6 - Falco
	// - 7 - Drift detection
	// - 8 - Malware detection
	// - 11 - ML - Cryptominer detection
	// - 13 - ML - AWS anomalous login
	// - 14 - ML - Okta anomalous login
	RuleType RuleType `json:"ruleType"`

	// Type The type of the event content.
	Type EventContentType `json:"type"`
}

// AgentlessRuntimeDetectionContent defines model for AgentlessRuntimeDetectionContent.
type AgentlessRuntimeDetectionContent struct {
	Fields *map[string]string `json:"fields,omitempty"`

	// IntegrationId The unique identifier of the integration that generated the event.
	IntegrationId string `json:"integrationId"`

	// IntegrationType The type of integration that generated the event.
	IntegrationType AgentlessRuntimeDetectionContentIntegrationType `json:"integrationType"`

	// Output Event output, generated after the configured rule
	Output *string `json:"output,omitempty"`

	// PolicyId ID of the policy that generated the event
	PolicyId PolicyId `json:"policyId"`

	// PolicyNotificationChannelIds The list of notification channels where an alert is sent after event is generated.
	// Doesn't account for aggregations and eventual thresholds.
	PolicyNotificationChannelIds *PolicyNotificationChannelIds `json:"policyNotificationChannelIds,omitempty"`

	// PolicyOrigin The policy author:
	// - `Sysdig` - default and managed policies
	// - `Sysdig UI` - users interacting with Sysdig
	// - `Tuner` - the automated tuner
	PolicyOrigin PolicyOrigin `json:"policyOrigin"`

	// Priority Rule priority
	Priority *AgentlessRuntimeDetectionContentPriority `json:"priority,omitempty"`

	// RuleName Name of the rule the event is generated after
	RuleName RuleName `json:"ruleName"`

	// RuleTags The tags attached to the rule
	RuleTags *RuleTags `json:"ruleTags,omitempty"`

	// RuleType Rule type:
	// - 1 - List matching - process
	// - 2 - List matching - container
	// - 3 - List matching - file
	// - 4 - List matching - network
	// - 5 - List matching - syscall
	// - 6 - Falco
	// - 7 - Drift detection
	// - 8 - Malware detection
	// - 11 - ML - Cryptominer detection
	// - 13 - ML - AWS anomalous login
	// - 14 - ML - Okta anomalous login
	RuleType RuleType `json:"ruleType"`

	// Type The type of the event content.
	Type EventContentType `json:"type"`
}

// AgentlessRuntimeDetectionContentIntegrationType The type of integration that generated the event.
type AgentlessRuntimeDetectionContentIntegrationType string

// AgentlessRuntimeDetectionContentPriority Rule priority
type AgentlessRuntimeDetectionContentPriority string

// AllSsoSettingsResponseV1 defines model for AllSsoSettingsResponseV1.
type AllSsoSettingsResponseV1 struct {
	// Data The list of SSO settings.
	Data *[]SsoSettingsResponseV1 `json:"data,omitempty"`
}

// ArbitraryMapOfStrings Key value pairs of values.
type ArbitraryMapOfStrings map[string]string

// AuditEvent Platform Audit Event
type AuditEvent struct {
	// Content Content object for Platform Audit Event.
	Content *AuditTrailContent `json:"content,omitempty"`

	// Cursor The cursor that can be used to fetch a set of events surrounding
	// this same event. By providing this value as `cursor` in a GET
	// request, you will get the set of events surrounding
	// this current event.
	Cursor *string `json:"cursor,omitempty"`

	// Id The event id.
	Id *string `json:"id,omitempty"`

	// Labels Key value pairs of values, represents entityType where the Audit Event was generated.
	Labels *map[string]string `json:"labels,omitempty"`

	// Timestamp The event timestamp in nanoseconds.
	Timestamp *int64 `json:"timestamp,omitempty"`
}

// AuditEventsFeedFilter Query language expression for filtering results.
// The filter is the result of logical concatenations,
// using "and" and "or" binary operators and the "not" unary prefix operator (i.e. `auditTrail.requestMethod = 'GET' and auditTrail.entityType = 'user'`),
// of attribute comparisons. Attribute comparisons can be:
// - scalar, using `=`, `!=` comparison operators (i.e. `auditTrail.teamName = 'Test team'`)
type AuditEventsFeedFilter = string

// AuditEventsFeedLimit The number of items to return
type AuditEventsFeedLimit = int32

// AuditPage Pagination information.
type AuditPage struct {
	// Next `next` is a string pointing to the next page of data.
	// Use this as the `cursor` to scroll paginated results and get the next page of data.
	// If not included, the current response is the last page.
	Next *string `json:"next,omitempty"`

	// Prev `prev` is a string pointing to the previous page of data.
	// Use this as the `cursor` to get the previous page of data.
	Prev *string `json:"prev,omitempty"`

	// Total The number of events matching the search criteria. This number is always major or equal to the number of events returned.
	Total int64 `json:"total"`
}

// AuditSupportedFilter A supported field for filtering Activity Audit events.
type AuditSupportedFilter struct {
	// Id Attribute onto which filtering is supported.
	Id string `json:"id"`

	// Operands The list of supported operands for filtering events.
	Operands *[]Operand `json:"operands,omitempty"`

	// Type Data type for the attribute values.
	Type SupportedFilterType `json:"type"`
}

// AuditSupportedFiltersResponse The list of supported attributes for filtering Activity Audit entries.
type AuditSupportedFiltersResponse struct {
	// Data The list of supported attributes for filtering Activity Audit entries.
	Data []AuditSupportedFilter `json:"data"`
}

// AuditTrailContent Content object for Platform Audit Event.
type AuditTrailContent struct {
	// EntityId ID of the entity that was affected by the action.
	EntityId *string `json:"entityId,omitempty"`

	// EntityPayload Payload of the entity that was affected by the action.
	EntityPayload *string `json:"entityPayload,omitempty"`

	// EntityType Type of entity that was affected by the action. Full list of possible values can be found in the our documentation
	// https://docs.sysdig.com/en/docs/administration/administration-settings/app-status-and-audit/sysdig-platform-audit/#sysdig-monitor-and-sysdig-platform.
	EntityType *string `json:"entityType,omitempty"`

	// QueryString Query string of the request that was used to preform action.
	QueryString *string `json:"queryString,omitempty"`

	// RequestMethod HTTP request method that was used to preform action.
	RequestMethod *AuditTrailContentRequestMethod `json:"requestMethod,omitempty"`

	// RequestUri URI of the request that was used to preform action.
	RequestUri *string `json:"requestUri,omitempty"`

	// ResponseStatusCode HTTP response status code of the request that was used to preform action.
	ResponseStatusCode *int32 `json:"responseStatusCode,omitempty"`

	// ServiceAccountId ID of the service account that was used to preform action.
	ServiceAccountId *int32 `json:"serviceAccountId,omitempty"`

	// ServiceAccountName Name of the service account that was used to preform action.
	ServiceAccountName *string `json:"serviceAccountName,omitempty"`

	// TeamId Team ID, that user who preformed some action was logged in.
	TeamId *int32 `json:"teamId,omitempty"`

	// TeamName Name of the team, that user who preformed action was logged in.
	TeamName *string `json:"teamName,omitempty"`

	// TimestampNs The event timestamp in nanoseconds.
	TimestampNs *int64 `json:"timestampNs,omitempty"`

	// UserId ID of user that was preforming some action.
	UserId *int32 `json:"userId,omitempty"`

	// UserOriginIP IP address of the user that was preforming action.
	UserOriginIP *string `json:"userOriginIP,omitempty"`

	// Username Username of the user that was preforming some action.
	Username *string `json:"username,omitempty"`
}

// AuditTrailContentRequestMethod HTTP request method that was used to preform action.
type AuditTrailContentRequestMethod string

// AuthenticatedConnectionInfoElasticsearch defines model for AuthenticatedConnectionInfoElasticsearch.
type AuthenticatedConnectionInfoElasticsearch struct {
	// Auth Authentication method
	Auth *AuthenticatedConnectionInfoElasticsearchAuth `json:"auth,omitempty"`

	// Endpoint Elasticsearch instance endpoint URL
	Endpoint string `json:"endpoint"`

	// Format If specified, transforms `content.fields` and `labels`
	// * `KV_PAIRS` - from objects (i.e. `{"foo": "bar", ...}`) to arrays of objects with "key" and "value" properties {i.e. `[{"key" : "foo", "value": "bar"}, ...]`)
	Format *AuthenticatedConnectionInfoElasticsearchFormat `json:"format,omitempty"`

	// Index Name of the index to store the data in
	Index string `json:"index"`

	// IsInsecure Don't verify TLS certificate
	IsInsecure *bool `json:"isInsecure,omitempty"`

	// Secret Authentication secret. To be set if auth is specified
	Secret *string `json:"secret,omitempty"`
}

// AuthenticatedConnectionInfoElasticsearchAuth Authentication method
type AuthenticatedConnectionInfoElasticsearchAuth string

// AuthenticatedConnectionInfoElasticsearchFormat If specified, transforms `content.fields` and `labels`
// * `KV_PAIRS` - from objects (i.e. `{"foo": "bar", ...}`) to arrays of objects with "key" and "value" properties {i.e. `[{"key" : "foo", "value": "bar"}, ...]`)
type AuthenticatedConnectionInfoElasticsearchFormat string

// AuthenticatedConnectionInfoKafkaV1 defines model for AuthenticatedConnectionInfoKafkaV1.
type AuthenticatedConnectionInfoKafkaV1 struct {
	// Auth The authentication method to optionally use. Currently supporting only GSSAPI
	Auth AuthenticatedConnectionInfoKafkaV1Auth `json:"auth"`

	// Balancer Algorithm that the client uses to multiplex data between the multiple Brokers. For compatibility with the Java client, Murmur2 is used as the default partitioner
	Balancer *AuthenticatedConnectionInfoKafkaV1Balancer `json:"balancer,omitempty"`

	// Brokers Kafka server endpoint. A Kafka cluster may provide several brokers; it follows the 'hostname: port' (without protocol scheme).
	Brokers []string `json:"brokers"`

	// Compression Compression standard used for the data
	Compression *AuthenticatedConnectionInfoKafkaV1Compression `json:"compression,omitempty"`

	// Keytab base64 encoded Kerberos keytab
	Keytab *string `json:"keytab,omitempty"`

	// Krb5 Kerberos krb5.conf file content for GSSAPI
	Krb5 string `json:"krb5"`

	// Principal GSSAPI principal
	Principal string `json:"principal"`

	// Realm GSSAPI realm
	Realm string `json:"realm"`

	// Service GSSAPI Service name
	Service string `json:"service"`

	// Topic Kafka topic where you want to store the forwarded data
	Topic string `json:"topic"`
	union json.RawMessage
}

// AuthenticatedConnectionInfoKafkaV1Auth The authentication method to optionally use. Currently supporting only GSSAPI
type AuthenticatedConnectionInfoKafkaV1Auth string

// AuthenticatedConnectionInfoKafkaV1Balancer Algorithm that the client uses to multiplex data between the multiple Brokers. For compatibility with the Java client, Murmur2 is used as the default partitioner
type AuthenticatedConnectionInfoKafkaV1Balancer string

// AuthenticatedConnectionInfoKafkaV1Compression Compression standard used for the data
type AuthenticatedConnectionInfoKafkaV1Compression string

// AuthenticatedConnectionInfoWebhook defines model for AuthenticatedConnectionInfoWebhook.
type AuthenticatedConnectionInfoWebhook struct {
	// Auth Authentication method
	Auth *AuthenticatedConnectionInfoWebhookAuth `json:"auth,omitempty"`

	// CertificateId ID of a certificate stored in Sysdig's [Certificates Management tool](#tag/Certificates). Note that the RFC 5425 (TLS) protocol is required for you to see this field
	CertificateId *int64 `json:"certificateId,omitempty"`

	// Endpoint Webhook endpoint following the schema protocol
	Endpoint string `json:"endpoint"`

	// Headers Extra headers to add to the request. Each header mapping requires 2 keys: 'key' for the header key and 'value' for its value
	Headers *[]KeyValueObject `json:"headers,omitempty"`

	// IsInsecure Skip TLS certificate verification
	IsInsecure *bool `json:"isInsecure,omitempty"`

	// Output Payload format
	Output *AuthenticatedConnectionInfoWebhookOutput `json:"output,omitempty"`

	// Secret Secret to use, according to the "auth" value.
	Secret *string `json:"secret,omitempty"`

	// TimestampFormat The resolution of the "timestamp" field in the payload
	TimestampFormat *AuthenticatedConnectionInfoWebhookTimestampFormat `json:"timestampFormat,omitempty"`
}

// AuthenticatedConnectionInfoWebhookAuth Authentication method
type AuthenticatedConnectionInfoWebhookAuth string

// AuthenticatedConnectionInfoWebhookOutput Payload format
type AuthenticatedConnectionInfoWebhookOutput string

// AuthenticatedConnectionInfoWebhookTimestampFormat The resolution of the "timestamp" field in the payload
type AuthenticatedConnectionInfoWebhookTimestampFormat string

// BaseAction defines model for BaseAction.
type BaseAction struct {
	// Type Action type.
	Type ActionType `json:"type"`
}

// BaseConnectionInfoAmazonSqs defines model for BaseConnectionInfoAmazonSqs.
type BaseConnectionInfoAmazonSqs struct {
	// Delay Delay, in seconds, applied to the data
	Delay *int64 `json:"delay,omitempty"`

	// Headers Extra headers to add to the payload. Each header mapping requires 2 keys: 'key' for the header key and 'value' for its value
	Headers *[]KeyValueObject `json:"headers,omitempty"`

	// IsFifo If the queue is of FIFO type
	IsFifo *bool `json:"isFifo,omitempty"`

	// OwnerAccount The AWS account ID of the account that created the queue
	OwnerAccount *string `json:"ownerAccount,omitempty"`

	// Queue Queue name
	Queue string `json:"queue"`

	// Region Region in which the SQS queue is hosted
	Region string `json:"region"`
}

// BaseConnectionInfoChronicle defines model for BaseConnectionInfoChronicle.
type BaseConnectionInfoChronicle struct {
	// Region The target region
	Region *BaseConnectionInfoChronicleRegion `json:"region,omitempty"`
}

// BaseConnectionInfoChronicleRegion The target region
type BaseConnectionInfoChronicleRegion string

// BaseConnectionInfoChronicleV2 defines model for BaseConnectionInfoChronicleV2.
type BaseConnectionInfoChronicleV2 struct {
	// ChronicleCustomerId Unique identifier (UUID) corresponding to a particular Chronicle instance
	ChronicleCustomerId string `json:"chronicleCustomerId"`

	// Namespace User-configured environment namespace to identify the data domain the logs originated from
	Namespace string `json:"namespace"`

	// Region The target region
	Region *BaseConnectionInfoChronicleV2Region `json:"region,omitempty"`
}

// BaseConnectionInfoChronicleV2Region The target region
type BaseConnectionInfoChronicleV2Region string

// BaseConnectionInfoElasticsearch defines model for BaseConnectionInfoElasticsearch.
type BaseConnectionInfoElasticsearch struct {
	// Auth Authentication method
	Auth *BaseConnectionInfoElasticsearchAuth `json:"auth,omitempty"`

	// Endpoint Elasticsearch instance endpoint URL
	Endpoint string `json:"endpoint"`

	// Format If specified, transforms `content.fields` and `labels`
	// * `KV_PAIRS` - from objects (i.e. `{"foo": "bar", ...}`) to arrays of objects with "key" and "value" properties {i.e. `[{"key" : "foo", "value": "bar"}, ...]`)
	Format *BaseConnectionInfoElasticsearchFormat `json:"format,omitempty"`

	// Index Name of the index to store the data in
	Index string `json:"index"`

	// IsInsecure Don't verify TLS certificate
	IsInsecure *bool `json:"isInsecure,omitempty"`
}

// BaseConnectionInfoElasticsearchAuth Authentication method
type BaseConnectionInfoElasticsearchAuth string

// BaseConnectionInfoElasticsearchFormat If specified, transforms `content.fields` and `labels`
// * `KV_PAIRS` - from objects (i.e. `{"foo": "bar", ...}`) to arrays of objects with "key" and "value" properties {i.e. `[{"key" : "foo", "value": "bar"}, ...]`)
type BaseConnectionInfoElasticsearchFormat string

// BaseConnectionInfoGooglePubSub defines model for BaseConnectionInfoGooglePubSub.
type BaseConnectionInfoGooglePubSub struct {
	// Attributes Extra headers to add to the request. Each header mapping requires 2 keys: "key" for the header key and "value" for its value
	Attributes *[]KeyValueObject `json:"attributes,omitempty"`

	// OrderingKey The key to use to order the messages. Required to enable ordered delivery
	OrderingKey *string `json:"orderingKey,omitempty"`

	// Project GCP project ID hosting the target pub/sub
	Project string `json:"project"`

	// Topic pub/sub topic onto which publish the data
	Topic string `json:"topic"`
}

// BaseConnectionInfoGoogleScc defines model for BaseConnectionInfoGoogleScc.
type BaseConnectionInfoGoogleScc struct {
	// Organization ID of your GCP organization
	Organization string `json:"organization"`

	// SecurityMarks additional annotations to add to assets or findings as they get forwarded to Security Command Center
	SecurityMarks *[]KeyValueObject `json:"securityMarks,omitempty"`
}

// BaseConnectionInfoKafka defines model for BaseConnectionInfoKafka.
type BaseConnectionInfoKafka struct {
	// Balancer Algorithm that the client uses to multiplex data between the multiple Brokers. For compatibility with the Java client, Murmur2 is used as the default partitioner
	Balancer *BaseConnectionInfoKafkaBalancer `json:"balancer,omitempty"`

	// Brokers Kafka server endpoint. A Kafka cluster may provide several brokers; it follows the 'hostname: port' (without protocol scheme).
	Brokers []string `json:"brokers"`

	// Compression Compression standard used for the data
	Compression *BaseConnectionInfoKafkaCompression `json:"compression,omitempty"`

	// Topic Kafka topic where you want to store the forwarded data
	Topic string `json:"topic"`
	union json.RawMessage
}

// BaseConnectionInfoKafkaBalancer Algorithm that the client uses to multiplex data between the multiple Brokers. For compatibility with the Java client, Murmur2 is used as the default partitioner
type BaseConnectionInfoKafkaBalancer string

// BaseConnectionInfoKafkaCompression Compression standard used for the data
type BaseConnectionInfoKafkaCompression string

// BaseConnectionInfoKafkaV1 defines model for BaseConnectionInfoKafkaV1.
type BaseConnectionInfoKafkaV1 struct {
	// Balancer Algorithm that the client uses to multiplex data between the multiple Brokers. For compatibility with the Java client, Murmur2 is used as the default partitioner
	Balancer *BaseConnectionInfoKafkaV1Balancer `json:"balancer,omitempty"`

	// Brokers Kafka server endpoint. A Kafka cluster may provide several brokers; it follows the 'hostname: port' (without protocol scheme).
	Brokers []string `json:"brokers"`

	// Compression Compression standard used for the data
	Compression *BaseConnectionInfoKafkaV1Compression `json:"compression,omitempty"`

	// Topic Kafka topic where you want to store the forwarded data
	Topic string `json:"topic"`
	union json.RawMessage
}

// BaseConnectionInfoKafkaV1Balancer Algorithm that the client uses to multiplex data between the multiple Brokers. For compatibility with the Java client, Murmur2 is used as the default partitioner
type BaseConnectionInfoKafkaV1Balancer string

// BaseConnectionInfoKafkaV1Compression Compression standard used for the data
type BaseConnectionInfoKafkaV1Compression string

// BaseConnectionInfoMcm defines model for BaseConnectionInfoMcm.
type BaseConnectionInfoMcm struct {
	// AccountId IBM Account ID
	AccountId *string `json:"accountId,omitempty"`

	// Endpoint The URL, including protocol and port (if non standard), to your IBM Cloud Pak for Multicloud Management API endpoint
	Endpoint string `json:"endpoint"`

	// IsInsecure Skip TLS certificate verification
	IsInsecure *bool `json:"isInsecure,omitempty"`

	// NoteName The note to use. If unspecified, a note with `policy-event` ID will be created and used
	NoteName *string `json:"noteName,omitempty"`

	// ProviderId The provider the findings will be associated to
	ProviderId *string `json:"providerId,omitempty"`
}

// BaseConnectionInfoMicrosoftSentinel defines model for BaseConnectionInfoMicrosoftSentinel.
type BaseConnectionInfoMicrosoftSentinel struct {
	// WorkspaceId Log Analytics workspace ID
	WorkspaceId string `json:"workspaceId"`
}

// BaseConnectionInfoQradar defines model for BaseConnectionInfoQradar.
type BaseConnectionInfoQradar struct {
	// Address DNS name or IP of the QRadar instance
	Address string `json:"address"`

	// IsInsecure Don't verify TLS certificate
	IsInsecure *bool `json:"isInsecure,omitempty"`

	// IsTls Use TLS encryption
	IsTls *bool `json:"isTls,omitempty"`

	// Port QRadar Management Port
	Port int64 `json:"port"`
}

// BaseConnectionInfoSplunk defines model for BaseConnectionInfoSplunk.
type BaseConnectionInfoSplunk struct {
	// CertificateId ID of a certificate stored in Sysdig's [Certificates Management tool](#tag/Certificates). Note that the RFC 5425 (TLS) protocol is required for you to see this field
	CertificateId *int64 `json:"certificateId,omitempty"`

	// Endpoint URL of the Splunk instance
	Endpoint string `json:"endpoint"`

	// Index index to send data to. If unspecified, it will be used the index specified on the HTTP Event Collector configuration on Splunk
	Index *string `json:"index,omitempty"`

	// IsInsecure Skip TLS certificate verification
	IsInsecure *bool `json:"isInsecure,omitempty"`

	// SourceType Source type to override [Sysdig standard data type to source type mapping](https://docs.sysdig.com/en/forward-splunk#reference-data-categories-mapped-to-source-types)
	SourceType *string `json:"sourceType,omitempty"`
}

// BaseConnectionInfoSyslog defines model for BaseConnectionInfoSyslog.
type BaseConnectionInfoSyslog struct {
	// Address Address of the Syslog server
	Address string `json:"address"`

	// CertificateId ID of a certificate stored in Sysdig's [Certificates Management tool](#tag/Certificates). Note that the RFC 5425 (TLS) protocol is required for you to see this field
	CertificateId *int64 `json:"certificateId,omitempty"`

	// Formatter The message content format
	Formatter *BaseConnectionInfoSyslogFormatter `json:"formatter,omitempty"`

	// IsInsecure Skip TLS certificate verification
	IsInsecure *bool `json:"isInsecure,omitempty"`

	// MessageFormat The syslog message format. RFC_5425 is TLS only
	MessageFormat BaseConnectionInfoSyslogMessageFormat `json:"messageFormat"`

	// Port port of the syslog server
	Port int64 `json:"port"`
}

// BaseConnectionInfoSyslogFormatter The message content format
type BaseConnectionInfoSyslogFormatter string

// BaseConnectionInfoSyslogMessageFormat The syslog message format. RFC_5425 is TLS only
type BaseConnectionInfoSyslogMessageFormat string

// BaseConnectionInfoWebhook defines model for BaseConnectionInfoWebhook.
type BaseConnectionInfoWebhook struct {
	// Auth Authentication method
	Auth *BaseConnectionInfoWebhookAuth `json:"auth,omitempty"`

	// CertificateId ID of a certificate stored in Sysdig's [Certificates Management tool](#tag/Certificates). Note that the RFC 5425 (TLS) protocol is required for you to see this field
	CertificateId *int64 `json:"certificateId,omitempty"`

	// Endpoint Webhook endpoint following the schema protocol
	Endpoint string `json:"endpoint"`

	// Headers Extra headers to add to the request. Each header mapping requires 2 keys: 'key' for the header key and 'value' for its value
	Headers *[]KeyValueObject `json:"headers,omitempty"`

	// IsInsecure Skip TLS certificate verification
	IsInsecure *bool `json:"isInsecure,omitempty"`

	// Output Payload format
	Output *BaseConnectionInfoWebhookOutput `json:"output,omitempty"`

	// TimestampFormat The resolution of the "timestamp" field in the payload
	TimestampFormat *BaseConnectionInfoWebhookTimestampFormat `json:"timestampFormat,omitempty"`
}

// BaseConnectionInfoWebhookAuth Authentication method
type BaseConnectionInfoWebhookAuth string

// BaseConnectionInfoWebhookOutput Payload format
type BaseConnectionInfoWebhookOutput string

// BaseConnectionInfoWebhookTimestampFormat The resolution of the "timestamp" field in the payload
type BaseConnectionInfoWebhookTimestampFormat string

// BaseContent Base content for all events
type BaseContent struct {
	// Type The type of the event content.
	Type EventContentType `json:"type"`
}

// BaseImage defines model for BaseImage.
type BaseImage struct {
	PullStrings *[]string `json:"pullStrings,omitempty"`
}

// BaseIntegrationPayload defines model for BaseIntegrationPayload.
type BaseIntegrationPayload struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels *IntegrationChannels `json:"channels,omitempty"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// BaseRiskAcceptedPayload defines model for BaseRiskAcceptedPayload.
type BaseRiskAcceptedPayload struct {
	// Description Description of why the accepted risk was created
	Description *string `json:"description,omitempty"`

	// EntityValue A value to match with the entityType
	EntityValue *string `json:"entityValue,omitempty"`

	// ExpirationDate Date when the accepted risk will expire (in YYYY-MM-DD format)
	ExpirationDate *openapi_types.Date `json:"expirationDate,omitempty"`

	// Reason Reason for acceptance
	Reason *BaseRiskAcceptedPayloadReason `json:"reason,omitempty"`

	// Stages List of stages where the risk acceptance is applied, empty list enables risk acceptance for all the stages
	Stages *[]BaseRiskAcceptedPayloadStages `json:"stages"`
}

// BaseRiskAcceptedPayloadReason Reason for acceptance
type BaseRiskAcceptedPayloadReason string

// BaseRiskAcceptedPayloadStages defines model for BaseRiskAcceptedPayload.Stages.
type BaseRiskAcceptedPayloadStages string

// BaseRiskAcceptedResponsePayload defines model for BaseRiskAcceptedResponsePayload.
type BaseRiskAcceptedResponsePayload struct {
	// CreatedAt Date when the Accepted Risk was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// CreatedBy User who created the risk acceptance
	CreatedBy *string `json:"createdBy,omitempty"`

	// ExpirationDate Date when the accepted risk will expire (in YYYY-MM-DD format)
	ExpirationDate *openapi_types.Date `json:"expirationDate,omitempty"`

	// Id The Accepted Risk ID
	Id *string `json:"id,omitempty"`

	// Status Specifies whether the Accepted Risk is enabled or expired
	Status *BaseRiskAcceptedResponsePayloadStatus `json:"status,omitempty"`

	// UpdatedAt Date when the Accepted Risk was updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// UpdatedBy User who last updated the risk acceptance
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// BaseRiskAcceptedResponsePayloadStatus Specifies whether the Accepted Risk is enabled or expired
type BaseRiskAcceptedResponsePayloadStatus string

// BucketConfigurationV1 defines model for BucketConfigurationV1.
type BucketConfigurationV1 struct {
	// Description The description of the bucket.
	Description *string `json:"description"`

	// Endpoint The endpoint of the bucket. ***Required for S3 compatible storage.***
	Endpoint *string `json:"endpoint"`

	// Folder The folder in the bucket where the captures are stored. Name of the folder without any prefix slashes ("test-folder" and not "/test-folder").
	Folder *string `json:"folder,omitempty"`

	// Name The name of the bucket.
	Name string `json:"name"`

	// PathStyleAccess Specifies if the bucket uses path-style access.
	PathStyleAccess *bool `json:"pathStyleAccess,omitempty"`

	// ProviderKeyId Id of the configured cloud provider account. Could be fetched with /api/providers endpoint.
	ProviderKeyId *string `json:"providerKeyId"`

	// Region The region of the bucket.
	Region *string `json:"region"`
}

// Bundle defines model for Bundle.
type Bundle struct {
	// Identifier Identifier of the bundle
	Identifier *string `json:"identifier,omitempty"`

	// Name Name of the bundle
	Name  *string     `json:"name,omitempty"`
	Rules *[]Rule     `json:"rules,omitempty"`
	Type  *BundleType `json:"type,omitempty"`
}

// BundleType defines model for Bundle.Type.
type BundleType string

// BundleRef defines model for BundleRef.
type BundleRef struct {
	// Id The Bundle ID.
	Id int `json:"id"`

	// Name The human readable Bundle name.
	Name *string `json:"name,omitempty"`
}

// BundleRule A Rule definition
type BundleRule struct {
	// Predicates The Predicates defining this Rule
	Predicates []struct {
		Extra *map[string]interface{} `json:"extra,omitempty"`
		Type  string                  `json:"type"`
	} `json:"predicates"`
	RuleId string `json:"ruleId"`

	// RuleType The type of the rule.
	// It may be one of the following:
	// - vulnSeverityAndThreats
	// - vulnDenyList
	// - imageConfigDefaultUser
	// - imageConfigLabel
	// - imageConfigEnvVariable
	// - imageConfigInstructionNotRecommended
	// - imageConfigInstructionIsPkgManager
	// - imageConfigCreationDate
	// - imageConfigSensitiveInformationAndSecrets
	// - pkgDenyList
	RuleType string `json:"ruleType"`
}

// CallerId The ID of the user that executed the Response action.
type CallerId = string

// CaptureAction defines model for CaptureAction.
type CaptureAction struct {
	// AfterEventNs Amount of nanoseconds after the event the Capture spans.
	AfterEventNs *int64 `json:"afterEventNs,omitempty"`

	// BeforeEventNs Amount of nanoseconds before the event the Capture spans.
	BeforeEventNs *int64 `json:"beforeEventNs,omitempty"`

	// ErrMsg When `isSuccessful` is `false`, details on why the action failed.
	ErrMsg *string `json:"errMsg,omitempty"`

	// IsSuccessful Whether or not the Capture was taken successfully.
	IsSuccessful *bool `json:"isSuccessful,omitempty"`

	// Token Token to retrieve the related capture.
	Token *string `json:"token,omitempty"`

	// Type Action type.
	Type ActionType `json:"type"`
}

// CaptureStorageConfigurationResponseV1 defines model for CaptureStorageConfigurationResponseV1.
type CaptureStorageConfigurationResponseV1 struct {
	// Buckets The list of buckets where the captures are stored. Currently only one bucket is supported.
	Buckets *[]BucketConfigurationV1 `json:"buckets"`

	// IsEnabled Specifies if capture storage is enabled.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// IsEncryptionWithProvidedKeyEnabled Specifies if server-side encryption with provided encryption key (SSE-C) is enabled.
	IsEncryptionWithProvidedKeyEnabled *bool `json:"isEncryptionWithProvidedKeyEnabled,omitempty"`
}

// Category The event category:
// - `runtime` - Agent-based threat detection events
// - `remote` - Kubernetes admission requests and CloudConnector events
// - `admissionController` - Kubernetes admission requests-posture checks
// - `cloudtrail` - Agentless CloudTrail CDR events
// - `okta` - Agentless Okta CDR events
// - `github` - Agentless Github CDR events
// - `falcocloud` - Agentless CDR events (excluded CloudTrail, Okta, Github)
// - `miner` - Workload ML Crypto events
type Category string

// Certificate An X-509 certificate
type Certificate struct {
	// CertificateName The certificate Name.
	CertificateName string `json:"certificateName"`

	// Created The timestamp the certificate was created.
	Created time.Time `json:"created"`

	// Fingerprint The certificate fingerprint
	Fingerprint string `json:"fingerprint"`

	// Id The certificate ID.
	Id int64 `json:"id"`

	// Issuer The Distinguished Name of the certificate issuer.
	Issuer string `json:"issuer"`

	// Usage The number of services that currently use that certificate.
	Usage int32 `json:"usage"`

	// Validity The certificate validity interval.
	Validity struct {
		// After The beginning of the certificate validity period.
		After *time.Time `json:"after,omitempty"`

		// Before The end of the certificate validity period.
		Before *time.Time `json:"before,omitempty"`
	} `json:"validity"`
}

// CertificatesResponse Customer certificates
type CertificatesResponse struct {
	Data []Certificate `json:"data"`
}

// CheckboxFieldValueV1 defines model for CheckboxFieldValueV1.
type CheckboxFieldValueV1 struct {
	// ID Jira checkbox field id.
	ID string `json:"id"`

	// Value Jira checkbox field value.
	Value string `json:"value"`
}

// CisaKevAvailableSince Number of days since the vulnerability was added to CISA's Known Exploited Vulnerabilities (KEV) catalog. Calculated from initial inclusion date to current date.
type CisaKevAvailableSince struct {
	Extra struct {
		// Days Number of days.
		Days *int32 `json:"days,omitempty"`
	} `json:"extra"`
	Type CisaKevAvailableSinceType `json:"type"`
}

// CisaKevAvailableSinceType defines model for CisaKevAvailableSince.Type.
type CisaKevAvailableSinceType string

// CisaKevKnownRansomwareCampaignUse The vulnerability listed in CISA's KEV catalog as actively exploited in ransomware campaigns.
type CisaKevKnownRansomwareCampaignUse struct {
	Type CisaKevKnownRansomwareCampaignUseType `json:"type"`
}

// CisaKevKnownRansomwareCampaignUseType defines model for CisaKevKnownRansomwareCampaignUse.Type.
type CisaKevKnownRansomwareCampaignUseType string

// CisaKevPublishDate Number of days remaining until the CISA KEV-listed vulnerability is fixed.
type CisaKevPublishDate struct {
	Extra struct {
		// Days Number of days.
		Days *int32 `json:"days,omitempty"`
	} `json:"extra"`
	Type CisaKevPublishDateType `json:"type"`
}

// CisaKevPublishDateType defines model for CisaKevPublishDate.Type.
type CisaKevPublishDateType string

// Command defines model for Command.
type Command struct {
	// Cmdline Full command line
	Cmdline string `json:"cmdline"`

	// Comm The name of the command.
	Comm string `json:"comm"`

	// ContainerId The container id. `containerId` is present only if the audit event was
	// collected in a container context.
	ContainerId *ContainerId `json:"containerId,omitempty"`

	// Cwd Command working directory.
	Cwd string `json:"cwd"`

	// Hostname The Kubernetes hostname.
	Hostname Hostname `json:"hostname"`

	// Id The audit event id.
	Id Id `json:"id"`

	// Labels Key value pairs of labels.
	Labels *map[string]string `json:"labels,omitempty"`

	// LoginShellDistance Level of nesting from the parent shell.
	LoginShellDistance int64 `json:"loginShellDistance"`

	// LoginShellId Process id of the shell.
	LoginShellId int64 `json:"loginShellId"`

	// Pcomm The name of the parent command.
	Pcomm string `json:"pcomm"`

	// Pid Process ID.
	Pid int64 `json:"pid"`

	// Ppid Parent process ID.
	Ppid int64 `json:"ppid"`

	// ProcExepath Process executable path.
	ProcExepath string `json:"procExepath"`

	// Timestamp Timestamp the audit event occured, expressed in nanoseconds.
	Timestamp Timestamp `json:"timestamp"`

	// Tty TTY number.
	Tty int64 `json:"tty"`

	// Type The entry type
	Type CommandType `json:"type"`

	// Uid User ID
	Uid int64 `json:"uid"`

	// UserLoginName User login name.
	UserLoginName string `json:"userLoginName"`

	// UserLoginUid User login UID.
	UserLoginUid int64 `json:"userLoginUid"`

	// Username Username
	Username *string `json:"username,omitempty"`
}

// CommandType The entry type
type CommandType string

// Connection defines model for Connection.
type Connection struct {
	// ClientIpv4 The IPv4 dotted notation of the client address.
	ClientIpv4 string `json:"clientIpv4"`

	// ClientPort The client port.
	ClientPort int64 `json:"clientPort"`

	// Cmdline Full command line
	Cmdline string `json:"cmdline"`

	// Comm The name of the command.
	Comm string `json:"comm"`

	// ContainerId The container id. `containerId` is present only if the audit event was
	// collected in a container context.
	ContainerId ContainerId `json:"containerId"`

	// Direction The direction of the connection.
	Direction ConnectionDirection `json:"direction"`

	// DnsDomains DNS information for the connection event.
	DnsDomains []string `json:"dnsDomains"`

	// Hostname The Kubernetes hostname.
	Hostname Hostname `json:"hostname"`

	// Id The audit event id.
	Id Id `json:"id"`

	// L4protocol The layer 4 protocol.
	L4protocol string `json:"l4protocol"`

	// Labels Key value pairs of labels.
	Labels *map[string]string `json:"labels,omitempty"`

	// Pid Id of the process owning the connection.
	Pid int64 `json:"pid"`

	// ProcessName Name of the process owning the connection.
	ProcessName string `json:"processName"`

	// ServerIpv4 The IPv4 dotted notation of the server address.
	ServerIpv4 string `json:"serverIpv4"`

	// ServerPort The server port.
	ServerPort int64 `json:"serverPort"`

	// Timestamp Timestamp the audit event occured, expressed in nanoseconds.
	Timestamp Timestamp `json:"timestamp"`

	// Tty TTY number.
	Tty int64 `json:"tty"`

	// Type The entry type
	Type ConnectionType `json:"type"`
}

// ConnectionDirection The direction of the connection.
type ConnectionDirection string

// ConnectionType The entry type
type ConnectionType string

// ContainerId The container id. `containerId` is present only if the audit event was
// collected in a container context.
type ContainerId = string

// ContainerInfo Kubernetes container information.
type ContainerInfo struct {
	// ContainerId Container id.
	ContainerId string `json:"containerId"`

	// ContainerName Container name.
	ContainerName string `json:"containerName"`

	// PodName Pod name
	PodName string `json:"podName"`

	// PullString Pull string for image used for the container.
	PullString *string `json:"pullString,omitempty"`
}

// ContainerKilledAction defines model for ContainerKilledAction.
type ContainerKilledAction struct {
	// ErrMsg When `isSuccessful` is `false`, details on why the action failed.
	ErrMsg *string `json:"errMsg,omitempty"`

	// IsSuccessful Whether or not the action was completed successfully.
	IsSuccessful *bool `json:"isSuccessful,omitempty"`

	// Type Action type.
	Type ActionType `json:"type"`
}

// ContainerPausedAction defines model for ContainerPausedAction.
type ContainerPausedAction struct {
	// ErrMsg When `isSuccessful` is `false`, details on why the action failed.
	ErrMsg *string `json:"errMsg,omitempty"`

	// IsSuccessful Whether or not the action was completed successfully.
	IsSuccessful *bool `json:"isSuccessful,omitempty"`

	// Type Action type.
	Type ActionType `json:"type"`
}

// ContainerStoppedAction defines model for ContainerStoppedAction.
type ContainerStoppedAction struct {
	// ErrMsg When `isSuccessful` is `false`, details on why the action failed.
	ErrMsg *string `json:"errMsg,omitempty"`

	// IsSuccessful Whether or not the action was completed successfully.
	IsSuccessful *bool `json:"isSuccessful,omitempty"`

	// Type Action type.
	Type ActionType `json:"type"`
}

// Context defines model for Context.
type Context struct {
	// Type Type for the context entry
	Type string `json:"type"`

	// Value Value for the context entry
	Value string `json:"value"`
}

// ContextEmpty To be used when `entityType` is not `vulnerability` or `policyRule`.
type ContextEmpty = []map[string]interface{}

// ContextHostContains Context to apply
type ContextHostContains = []HostNameContains

// ContextHostName Context host name
type ContextHostName = []HostName

// ContextImageContains Context to apply
type ContextImageContains = []ImageNameContains

// ContextImageName Context to apply
type ContextImageName = []ImageName

// ContextImagePrefix Context to apply
type ContextImagePrefix = []ImagePrefix

// ContextImageSuffix Context to apply
type ContextImageSuffix = []ImageSuffix

// ContextPackageName Context to apply
type ContextPackageName = []PackageName

// ContextPackageNameVersion Context to apply
type ContextPackageNameVersion = []PackageNameVersion

// ContextPackagePath Context to apply
type ContextPackagePath = []PackagePath

// ContextPackagePathVersion Context to apply
type ContextPackagePathVersion = []PackagePathVersion

// ContextPackageVersion Context to apply
type ContextPackageVersion = []PackageVersion

// CreateAccessKeyRequestV1 Create access key request
type CreateAccessKeyRequestV1 struct {
	// AgentLimit Maximum number of agents that can be connected with the access key
	AgentLimit *int32 `json:"agentLimit,omitempty"`

	// AgentReservation Number of agents that are guaranteed to be available for the access key
	AgentReservation *int32 `json:"agentReservation,omitempty"`

	// Metadata Access key metadata (maximum of 20 key-value pairs where key can be up to 25 characters long and value can be up to 50 characters long)
	Metadata *map[string]string `json:"metadata,omitempty"`

	// TeamId ID of team that owns the access key
	TeamId *int32 `json:"teamId,omitempty"`
}

// CreateAmazonSqsIntegrationRequest defines model for CreateAmazonSqsIntegrationRequest.
type CreateAmazonSqsIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels `json:"channels,omitempty"`
	ConnectionInfo struct {
		// AccessKey Access Key for authenticating on AWS to send data on the queue
		AccessKey string `json:"accessKey"`

		// AccessSecret Access Secret for authenticating on AWS to send data on the queue
		AccessSecret string `json:"accessSecret"`

		// Delay Delay, in seconds, applied to the data
		Delay *int64 `json:"delay,omitempty"`

		// Headers Extra headers to add to the payload. Each header mapping requires 2 keys: 'key' for the header key and 'value' for its value
		Headers *[]KeyValueObject `json:"headers,omitempty"`

		// IsFifo If the queue is of FIFO type
		IsFifo *bool `json:"isFifo,omitempty"`

		// OwnerAccount The AWS account ID of the account that created the queue
		OwnerAccount *string `json:"ownerAccount,omitempty"`

		// Queue Queue name
		Queue string `json:"queue"`

		// Region Region in which the SQS queue is hosted
		Region string `json:"region"`
	} `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// CreateBundleRequest Bundle definition
type CreateBundleRequest struct {
	// Description Human readable description of this Bundle
	Description *string `json:"description,omitempty"`

	// Name The human readable Bundle name
	Name string `json:"name"`

	// Rules The Rules defining this Bundle
	Rules []NewRule `json:"rules"`
}

// CreateChronicleIntegrationConnInfo defines model for CreateChronicleIntegrationConnInfo.
type CreateChronicleIntegrationConnInfo struct {
	// ApiKey The Chronicle v2 API key
	ApiKey string `json:"apiKey"`

	// Region The target region
	Region *CreateChronicleIntegrationConnInfoRegion `json:"region,omitempty"`
}

// CreateChronicleIntegrationConnInfoRegion The target region
type CreateChronicleIntegrationConnInfoRegion string

// CreateChronicleIntegrationConnInfoV2 defines model for CreateChronicleIntegrationConnInfoV2.
type CreateChronicleIntegrationConnInfoV2 struct {
	// ChronicleCustomerId Unique identifier (UUID) corresponding to a particular Chronicle instance
	ChronicleCustomerId string `json:"chronicleCustomerId"`

	// CredentialsOAuth2 The Chronicle v2 OAuth2 credentials
	CredentialsOAuth2 string `json:"credentialsOAuth2"`

	// Namespace User-configured environment namespace to identify the data domain the logs originated from
	Namespace string `json:"namespace"`

	// Region The target region
	Region *CreateChronicleIntegrationConnInfoV2Region `json:"region,omitempty"`
}

// CreateChronicleIntegrationConnInfoV2Region The target region
type CreateChronicleIntegrationConnInfoV2Region string

// CreateChronicleIntegrationRequest defines model for CreateChronicleIntegrationRequest.
type CreateChronicleIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels                             `json:"channels,omitempty"`
	ConnectionInfo CreateChronicleIntegrationRequest_ConnectionInfo `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// CreateChronicleIntegrationRequest_ConnectionInfo defines model for CreateChronicleIntegrationRequest.ConnectionInfo.
type CreateChronicleIntegrationRequest_ConnectionInfo struct {
	union json.RawMessage
}

// CreateEfoIntegrationRequestV1 Create Integration Request
type CreateEfoIntegrationRequestV1 struct {
	union json.RawMessage
}

// CreateElasticsearchIntegrationRequest defines model for CreateElasticsearchIntegrationRequest.
type CreateElasticsearchIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels                                 `json:"channels,omitempty"`
	ConnectionInfo CreateElasticsearchIntegrationRequest_ConnectionInfo `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// CreateElasticsearchIntegrationRequest_ConnectionInfo defines model for CreateElasticsearchIntegrationRequest.ConnectionInfo.
type CreateElasticsearchIntegrationRequest_ConnectionInfo struct {
	union json.RawMessage
}

// CreateGlobalServiceAccountRequestV1 defines model for CreateGlobalServiceAccountRequestV1.
type CreateGlobalServiceAccountRequestV1 struct {
	// ExpirationDate Time when the Service Account API key expires, | in number of milliseconds since January 1, 1970, 00:00:00 GMT
	ExpirationDate *int64 `json:"expirationDate,omitempty"`

	// Name The display name of the Service Account.
	Name *string `json:"name,omitempty"`

	// SystemRoles Array of System roles assigned to the global service account.
	SystemRoles *[]string `json:"systemRoles,omitempty"`
}

// CreateGooglePubSubIntegrationRequest defines model for CreateGooglePubSubIntegrationRequest.
type CreateGooglePubSubIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels `json:"channels,omitempty"`
	ConnectionInfo struct {
		// Attributes Extra headers to add to the request. Each header mapping requires 2 keys: "key" for the header key and "value" for its value
		Attributes *[]KeyValueObject `json:"attributes,omitempty"`

		// CredentialsJson JSON credentials for the service account Sysdig will use to send data
		CredentialsJson string `json:"credentialsJson"`

		// OrderingKey The key to use to order the messages. Required to enable ordered delivery
		OrderingKey *string `json:"orderingKey,omitempty"`

		// Project GCP project ID hosting the target pub/sub
		Project string `json:"project"`

		// Topic pub/sub topic onto which publish the data
		Topic string `json:"topic"`
	} `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// CreateGoogleSccIntegrationRequest defines model for CreateGoogleSccIntegrationRequest.
type CreateGoogleSccIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels `json:"channels,omitempty"`
	ConnectionInfo struct {
		// CredentialsJson JSON credentials for the service account Sysdig will use to send data
		CredentialsJson string `json:"credentialsJson"`

		// Organization ID of your GCP organization
		Organization string `json:"organization"`

		// SecurityMarks additional annotations to add to assets or findings as they get forwarded to Security Command Center
		SecurityMarks *[]KeyValueObject `json:"securityMarks,omitempty"`
	} `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// CreateGroupMappingRequestV1 defines model for CreateGroupMappingRequestV1.
type CreateGroupMappingRequestV1 struct {
	// CustomTeamRoleId The custom team role ID assigned for the user in this team. **Mutually exclusive with standardTeamRole**.
	CustomTeamRoleId *UnlimitedLong `json:"customTeamRoleId"`

	// GroupName The group name matching the external provider name.
	GroupName string `json:"groupName"`

	// IsAdmin Flag that indicates if the group is an admin group.
	IsAdmin *bool `json:"isAdmin,omitempty"`

	// StandardTeamRole The standard team role assigned for the user in this team. **Mutually exclusive with customTeamRoleId**.
	StandardTeamRole *TeamRoleV1 `json:"standardTeamRole"`

	// TeamMap Determines the teams to which a group is mapped.
	TeamMap TeamMapV1 `json:"teamMap"`

	// Weight The weight of the group mapping is used to determine the priority - a lower number has higher priority.
	Weight *int16 `json:"weight,omitempty"`
}

// CreateInhibitionRuleRequestV1 defines model for CreateInhibitionRuleRequestV1.
type CreateInhibitionRuleRequestV1 struct {
	// Description Description of the inhibition rule.
	Description *string `json:"description"`

	// Equal List of labels that must have an equal value in the source and target alert for the inhibition to take effect.
	Equal *[]string `json:"equal"`

	// IsEnabled Indicates if the inhibition rule is enabled or not.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name Name of the inhibition rule. If provided, must be unique.
	Name *string `json:"name"`

	// SourceMatchers List of source matchers for which one or more alerts have to exist for the inhibition to take effect.
	SourceMatchers []LabelMatcherV1 `json:"sourceMatchers"`

	// TargetMatchers List of target matchers that have to be fulfilled by the target alerts to be muted.
	TargetMatchers []LabelMatcherV1 `json:"targetMatchers"`
}

// CreateIntegrationRequest Create Integration Request
type CreateIntegrationRequest struct {
	union json.RawMessage
}

// CreateIntegrationRequestV1 defines model for CreateIntegrationRequestV1.
type CreateIntegrationRequestV1 struct {
	// Name Integration name.
	Name string `json:"name"`

	// IsAllTeams If **true**, the integration will be enabled for all teams.
	// If **false**, the integration will be enabled for the teams specified in the *teamIds* field.
	IsAllTeams *bool `json:"isAllTeams,omitempty"`

	// TeamIDs List of Sysdig's internal team ids for which the integration will be enabled.
	// This field is required if *isAllTeams* is **false**.
	TeamIDs *[]UnlimitedLong `json:"teamIds,omitempty"`

	// JiraProject Associated Jira project id.
	// Please refer to the [Jira documentation](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-projects#api-group-projects "Jira project documentation") for more info.
	JiraProject string `json:"jiraProject"`

	// JiraURL Customer's Jira URL.
	JiraURL string `json:"jiraUrl"`

	// JiraEmail User's email associated with the Jira account.
	JiraEmail openapi_types.Email `json:"jiraEmail"`

	// JiraAccessToken Jira access token for the provided Jira account.
	JiraAccessToken string `json:"jiraAccessToken"`

	// JiraAssignee The default assignee Jira account id for this integration.
	// Please refer to the [Jira documentation](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-user-search/#api-group-user-search "Jira user documentation") for more info.
	JiraAssignee *string `json:"jiraAssignee,omitempty"`

	// JiraLabels The list of Jira labels available for this integration.
	// Please refer to the [Jira documentation](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-labels/#api-group-labels "Jira labels documentation") for more info.
	JiraLabels *[]string `json:"jiraLabels,omitempty"`
}

// CreateIpFilterV1 Request to create IP filter.
type CreateIpFilterV1 struct {
	// IpRange IP range in CIDR notation
	IpRange   string  `json:"ipRange"`
	IsEnabled bool    `json:"isEnabled"`
	Note      *string `json:"note,omitempty"`
}

// CreateIssueTypeRequestV1 defines model for CreateIssueTypeRequestV1.
type CreateIssueTypeRequestV1 struct {
	// JiraID Jira issue type id.
	// Please refer to the [Jira documentation](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issue-types/#api-group-issue-types "Jira issue types documentation") for more info.
	JiraID string `json:"jiraId"`

	// JiraOpenStatusID Jira status id mapped to open status.
	// Please refer to the [Jira documentation](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-status/#api-group-status "Jira status documentation") for more info.
	JiraOpenStatusID string `json:"jiraOpenStatusId"`

	// JiraInProgressStatusID Jira status id mapped to in progress status.
	// Please refer to the [Jira documentation](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-status/#api-group-status "Jira status documentation") for more info.
	JiraInProgressStatusID string `json:"jiraInProgressStatusId"`

	// JiraClosedStatusID Jira status id mapped to closed status.
	// Please refer to the [Jira documentation](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-status/#api-group-status "Jira status documentation") for more info.
	JiraClosedStatusID string `json:"jiraClosedStatusId"`

	// CustomFieldIDs List of supported custom field ids for the issue type.
	// Please refer to the [Jira documentation](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issues/#api-rest-api-3-issue-createmeta-get "Jira issue type fields documentation") for more info.
	CustomFieldIDs *[]string `json:"customFieldIds,omitempty"`
}

// CreateKafkaIntegrationRequest defines model for CreateKafkaIntegrationRequest.
type CreateKafkaIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels                         `json:"channels,omitempty"`
	ConnectionInfo CreateKafkaIntegrationRequest_ConnectionInfo `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// CreateKafkaIntegrationRequest_ConnectionInfo defines model for CreateKafkaIntegrationRequest.ConnectionInfo.
type CreateKafkaIntegrationRequest_ConnectionInfo struct {
	union json.RawMessage
}

// CreateKafkaIntegrationRequestV1 defines model for CreateKafkaIntegrationRequestV1.
type CreateKafkaIntegrationRequestV1 struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels                           `json:"channels,omitempty"`
	ConnectionInfo CreateKafkaIntegrationRequestV1_ConnectionInfo `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// CreateKafkaIntegrationRequestV1_ConnectionInfo defines model for CreateKafkaIntegrationRequestV1.ConnectionInfo.
type CreateKafkaIntegrationRequestV1_ConnectionInfo struct {
	union json.RawMessage
}

// CreateMcmIntegrationRequest defines model for CreateMcmIntegrationRequest.
type CreateMcmIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels `json:"channels,omitempty"`
	ConnectionInfo struct {
		// AccountId IBM Account ID
		AccountId *string `json:"accountId,omitempty"`

		// ApiKey IBM Cloud API Key
		ApiKey string `json:"apiKey"`

		// Endpoint The URL, including protocol and port (if non standard), to your IBM Cloud Pak for Multicloud Management API endpoint
		Endpoint string `json:"endpoint"`

		// IsInsecure Skip TLS certificate verification
		IsInsecure *bool `json:"isInsecure,omitempty"`

		// NoteName The note to use. If unspecified, a note with `policy-event` ID will be created and used
		NoteName *string `json:"noteName,omitempty"`

		// ProviderId The provider the findings will be associated to
		ProviderId *string `json:"providerId,omitempty"`
	} `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// CreateMicrosoftSentinelIntegrationRequest defines model for CreateMicrosoftSentinelIntegrationRequest.
type CreateMicrosoftSentinelIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels `json:"channels,omitempty"`
	ConnectionInfo struct {
		// Secret Log analytics primary key
		Secret string `json:"secret"`

		// WorkspaceId Log Analytics workspace ID
		WorkspaceId string `json:"workspaceId"`
	} `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// CreateNotificationChannelRequestV1 defines model for CreateNotificationChannelRequestV1.
type CreateNotificationChannelRequestV1 struct {
	// Type The type of the notification channel
	Type NotificationChannelTypeV1 `json:"type"`
}

// CreatePolicyRequest A Policy definition
type CreatePolicyRequest struct {
	// Bundles bundles defining this policy
	Bundles []BundleRef `json:"bundles"`

	// Description policy description
	Description *string `json:"description,omitempty"`

	// Name human readable policy name
	Name string `json:"name"`

	// Stages array of stages for the policy.
	// An empty array means the policy is applied only when specifically requested by its identifier.
	Stages *[]NewStage `json:"stages,omitempty"`
}

// CreatePricingRequestV1 defines model for CreatePricingRequestV1.
type CreatePricingRequestV1 struct {
	// ClusterName The name of the cluster. Required when `type` is `CLUSTER`.
	ClusterName *string `json:"clusterName"`

	// Name The name of the pricing configuration.
	Name string `json:"name"`

	// SpotLabel The name of a node label that is used to identify the node as a spot node.
	SpotLabel *string `json:"spotLabel"`

	// SpotLabelValue The value of the spot node label.
	SpotLabelValue *string `json:"spotLabelValue"`

	// Type The type of the pricing.
	Type PricingType `json:"type"`

	// UnitPricing The unit pricing configuration used to compute costs.
	UnitPricing UnitPricingV1 `json:"unitPricing"`
}

// CreateQradarIntegrationRequest defines model for CreateQradarIntegrationRequest.
type CreateQradarIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels     `json:"channels,omitempty"`
	ConnectionInfo BaseConnectionInfoQradar `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// CreateRiskAcceptedRequest defines model for CreateRiskAcceptedRequest.
type CreateRiskAcceptedRequest struct {
	// Context If entityType is not `vulnerability`, `policyRule` or `package`, you should use `Empty Matcher` in the context.
	Context CreateRiskAcceptedRequest_Context `json:"context"`

	// Description Description of why the accepted risk was created
	Description string `json:"description"`

	// EntityType The entity where the Accepted Risk will be applied.
	EntityType CreateRiskAcceptedRequestEntityType `json:"entityType"`

	// EntityValue A value to match with the entityType
	EntityValue string `json:"entityValue"`

	// ExpirationDate Date when the accepted risk will expire (in YYYY-MM-DD format)
	ExpirationDate *openapi_types.Date `json:"expirationDate,omitempty"`

	// Reason Reason for acceptance
	Reason CreateRiskAcceptedRequestReason `json:"reason"`

	// Stages List of stages where the risk acceptance is applied, empty list enables risk acceptance for all the stages
	Stages *[]CreateRiskAcceptedRequestStages `json:"stages"`
}

// CreateRiskAcceptedRequest_Context If entityType is not `vulnerability`, `policyRule` or `package`, you should use `Empty Matcher` in the context.
type CreateRiskAcceptedRequest_Context struct {
	union json.RawMessage
}

// CreateRiskAcceptedRequestEntityType The entity where the Accepted Risk will be applied.
type CreateRiskAcceptedRequestEntityType string

// CreateRiskAcceptedRequestReason Reason for acceptance
type CreateRiskAcceptedRequestReason string

// CreateRiskAcceptedRequestStages defines model for CreateRiskAcceptedRequest.Stages.
type CreateRiskAcceptedRequestStages string

// CreateServiceAccountRequestV1 defines model for CreateServiceAccountRequestV1.
type CreateServiceAccountRequestV1 struct {
	// ExpirationDate Time when the Service Account API key expires, | in number of milliseconds since January 1, 1970, 00:00:00 GMT
	ExpirationDate *int64 `json:"expirationDate,omitempty"`

	// Name The display name of the Service Account.
	Name *string `json:"name,omitempty"`
}

// CreateServiceAccountsNotificationSettingsRequestV1 The base schema for the service accounts notification settings.
type CreateServiceAccountsNotificationSettingsRequestV1 = ServiceAccountsNotificationSettinsBase

// CreateSplunkIntegrationRequest defines model for CreateSplunkIntegrationRequest.
type CreateSplunkIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels `json:"channels,omitempty"`
	ConnectionInfo struct {
		// CertificateId ID of a certificate stored in Sysdig's [Certificates Management tool](#tag/Certificates). Note that the RFC 5425 (TLS) protocol is required for you to see this field
		CertificateId *int64 `json:"certificateId,omitempty"`

		// Endpoint URL of the Splunk instance
		Endpoint string `json:"endpoint"`

		// Index index to send data to. If unspecified, it will be used the index specified on the HTTP Event Collector configuration on Splunk
		Index *string `json:"index,omitempty"`

		// IsInsecure Skip TLS certificate verification
		IsInsecure *bool `json:"isInsecure,omitempty"`

		// SourceType Source type to override [Sysdig standard data type to source type mapping](https://docs.sysdig.com/en/forward-splunk#reference-data-categories-mapped-to-source-types)
		SourceType *string `json:"sourceType,omitempty"`

		// Token HTTP Event Collector Token
		Token string `json:"token"`
	} `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// CreateSsoSettingsRequestV1 defines model for CreateSsoSettingsRequestV1.
type CreateSsoSettingsRequestV1 struct {
	// Config Create Request SSO Settings Base Schema
	Config *SsoSettingsCreateRequestBaseV1 `json:"config,omitempty"`

	// CreateUserOnLogin Flag to indicate if the user will be created automatically if not found in the system.
	CreateUserOnLogin *bool `json:"createUserOnLogin,omitempty"`

	// GroupMappingAttributeName The group mapping attribute name.
	GroupMappingAttributeName *string `json:"groupMappingAttributeName"`

	// IntegrationName The name of this SSO config.
	IntegrationName *string `json:"integrationName"`

	// IsActive Flag to indicate if the SSO settings is active.
	IsActive *bool `json:"isActive,omitempty"`

	// IsGroupMappingEnabled Flag to indicate if group mapping support is enabled.
	IsGroupMappingEnabled *bool `json:"isGroupMappingEnabled,omitempty"`

	// IsPasswordLoginEnabled Flag to indicate if the user will be able to login with password. Deprecated: use the API endpoint `/platform/v1/global-sso-settings` for this functionality. This is now a global setting: if this flag is defined here and this SSO setting is set to be active, the setting will be applied at global level.
	// Deprecated:
	IsPasswordLoginEnabled *bool `json:"isPasswordLoginEnabled,omitempty"`

	// IsSingleLogoutEnabled Flag to indicate if the single logout support is enabled.
	IsSingleLogoutEnabled *bool `json:"isSingleLogoutEnabled,omitempty"`

	// Product The product to which SSO settings is applied to. SSO settings are configured per specific product.
	Product *Product `json:"product,omitempty"`
}

// CreateSyslogIntegrationRequest defines model for CreateSyslogIntegrationRequest.
type CreateSyslogIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels     `json:"channels,omitempty"`
	ConnectionInfo BaseConnectionInfoSyslog `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// CreateTeamRequestV1 defines model for CreateTeamRequestV1.
type CreateTeamRequestV1 struct {
	// AdditionalTeamPermissions Additional permissions available to the users of the team.
	AdditionalTeamPermissions *AdditionalTeamPermissionsV1 `json:"additionalTeamPermissions,omitempty"`

	// CustomTeamRoleId The custom team role assigned by default to users added to this team. **Mutually exclusive with standardTeamRoleId**.
	CustomTeamRoleId *UnlimitedLong `json:"customTeamRoleId,omitempty"`

	// Description A longer description of the team explaining what is it used for.
	Description *string `json:"description,omitempty"`

	// IsAllZones **True** if the users that are members of this team have access to all zones. **Mutually exclusive with zoneIds**.\
	// \
	// _Only supported in Secure features._
	IsAllZones *bool `json:"isAllZones,omitempty"`

	// IsDefaultTeam Specifies if the team is the default team. The default team is used to automatically assign new users to a team.
	IsDefaultTeam *bool `json:"isDefaultTeam,omitempty"`

	// Name The name of the team. It must be unique.
	Name string `json:"name"`

	// Product The product to which the team is assigned to. Teams can only be part of a single product at a time.
	Product Product `json:"product"`

	// Scopes Scopes is a list of different scope types and filter values that will be applied to resources
	// when accessed through the team.
	Scopes *[]ScopeV1 `json:"scopes,omitempty"`

	// StandardTeamRole The standard team role assigned by default to users added to this team. **Mutually exclusive with customTeamRoleId**.\
	// \
	// *ROLE_TEAM_SERVICE_MANAGER is only supported in Secure.*
	StandardTeamRole *TeamRoleV1 `json:"standardTeamRole,omitempty"`

	// UiSettings UI related settings.
	UiSettings *UiSettingsV1 `json:"uiSettings,omitempty"`

	// ZoneIds The list of zones that users assigned to this team will have access to. **Mutually exclusive with allZones**.\
	// \
	// _Only supported in Secure features._
	ZoneIds *[]UnlimitedLong `json:"zoneIds,omitempty"`
}

// CreateTeamServiceAccountRequestV1 defines model for CreateTeamServiceAccountRequestV1.
type CreateTeamServiceAccountRequestV1 struct {
	// ExpirationDate Time when the Service Account API key expires, | in number of milliseconds since January 1, 1970, 00:00:00 GMT
	ExpirationDate *int64 `json:"expirationDate,omitempty"`

	// Name The display name of the Service Account.
	Name *string `json:"name,omitempty"`

	// TeamRole Team role to be assigned to the team service account. | It can be a string for predefined roles or an id of a custom role.
	TeamRole *string `json:"teamRole,omitempty"`
}

// CreateUserRequestV1 Request to create the User
type CreateUserRequestV1 struct {
	// BypassSsoEnforcement When **True**, the user can bypass SSO enforcement.
	//
	// **Warning:** This allows the user to log in without SSO even when username and password login is disabled.
	BypassSsoEnforcement *bool `json:"bypassSsoEnforcement,omitempty"`

	// Email The email address of the user. If the activation flow is set, this address will
	// be used to send the activation email.
	Email openapi_types.Email `json:"email"`

	// FirstName The name of the user.
	FirstName *string `json:"firstName,omitempty"`

	// IsAdmin **True** if the user has Administration permissions.
	IsAdmin *bool `json:"isAdmin,omitempty"`

	// LastName The surname of the user.
	LastName *string `json:"lastName,omitempty"`

	// Products The user will be added to the default teams specified by this field.
	Products *[]Product `json:"products,omitempty"`
}

// CreateWebhookIntegrationRequest defines model for CreateWebhookIntegrationRequest.
type CreateWebhookIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels                           `json:"channels,omitempty"`
	ConnectionInfo CreateWebhookIntegrationRequest_ConnectionInfo `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// CreateWebhookIntegrationRequest_ConnectionInfo defines model for CreateWebhookIntegrationRequest.ConnectionInfo.
type CreateWebhookIntegrationRequest_ConnectionInfo struct {
	union json.RawMessage
}

// CreateZoneRequestV1 defines model for CreateZoneRequestV1.
type CreateZoneRequestV1 struct {
	// Description The Zone description. It can be useful for adding extra information
	Description *string `json:"description,omitempty"`

	// Name The name of the Zone. It must be unique
	Name string `json:"name"`

	// Scopes Zone attached scopes
	Scopes []CreateZoneScopeRequestV1 `json:"scopes"`
}

// CreateZoneScopeRequestV1 defines model for CreateZoneScopeRequestV1.
type CreateZoneScopeRequestV1 struct {
	// Rules Scoping rules to be applied
	Rules *string `json:"rules,omitempty"`

	// TargetType The target type of the Scope
	TargetType string `json:"targetType"`
}

// CreatedAt datetime of creation
type CreatedAt = string

// Cursor Cursor is a string used to retrieve paginated data. It acts as a pointer to the next page of data. When a cursor is defined, the `from` and `to` parameters must not be used.
type Cursor = string

// CustomJobContentV1 The yaml content of a custom Prometheus job. Must be a valid `scrape_config` as defined here: https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config
type CustomJobContentV1 = string

// CustomJobV1 Custom Prometheus job name and enablement status
type CustomJobV1 struct {
	// Enabled Enablement status
	Enabled *bool `json:"enabled,omitempty"`

	// EnablementByCluster Enablement overrides by cluster
	EnablementByCluster *map[string]bool `json:"enablementByCluster,omitempty"`

	// Name Job name
	Name *string `json:"name,omitempty"`
}

// CustomJobsEnablementV1 The enablement status of a custom Prometheus job
type CustomJobsEnablementV1 struct {
	// Enabled Enablement status
	Enabled bool `json:"enabled"`

	// EnablementByCluster Enablement overrides by cluster
	EnablementByCluster *map[string]bool `json:"enablementByCluster,omitempty"`
}

// CvssScore defines model for CvssScore.
type CvssScore struct {
	// Score CVSS score
	Score float32 `json:"score"`

	// Vector attack vector
	Vector  *string `json:"vector,omitempty"`
	Version string  `json:"version"`
}

// DateRange A date range with inclusive start and end dates.
type DateRange struct {
	// EndDate The end of the date range.
	EndDate openapi_types.Date `json:"endDate"`

	// StartDate The beginning of the date range.
	StartDate openapi_types.Date `json:"startDate"`
}

// DaysInYearInt Number of days in a year
type DaysInYearInt = int32

// DefaultRoleResponseV1 Default role response
type DefaultRoleResponseV1 struct {
	// MonitorPermissions Set of Monitor permissions assigned to the role.
	// Check the `permissions` endpoint to list the available values.
	MonitorPermissions *[]string `json:"monitorPermissions,omitempty"`

	// Name The display name of the role
	Name *string `json:"name,omitempty"`

	// SecurePermissions Set of Secure permissions assigned to the role.
	// Check the `permissions` endpoint to list the available values.
	SecurePermissions *[]string `json:"securePermissions,omitempty"`
}

// DenyCve Predicate expressing "any of these CVEs is present".
type DenyCve struct {
	Extra struct {
		VulnIds *[]string `json:"vulnIds,omitempty"`
	} `json:"extra"`
	Type DenyCveType `json:"type"`
}

// DenyCveType defines model for DenyCve.Type.
type DenyCveType string

// DenyPkg Predicate expressing "any of these packages is present".
type DenyPkg struct {
	Extra struct {
		Packages []struct {
			// Name Package name
			Name string `json:"name"`

			// Version Package version
			Version *string `json:"version,omitempty"`
		} `json:"packages"`
	} `json:"extra"`
	Type DenyPkgType `json:"type"`
}

// DenyPkgType defines model for DenyPkg.Type.
type DenyPkgType string

// DisableJobsAndMetricsV1 Get Disabled Metrics by Job name Response
type DisableJobsAndMetricsV1 struct {
	// JobName The Prometheus Job for which the collection of one or more metrics is disabled.
	JobName *string `json:"jobName,omitempty"`

	// Metrics List of metrics to be disabled.
	Metrics *[]DisableMetricV1 `json:"metrics,omitempty"`
}

// DisableMetricV1 Get Disabled Metrics by Job name Response.
type DisableMetricV1 struct {
	// IsDisabled Set as `true` to disable a metric. \
	// Set as `false` to re-enable a metric.
	IsDisabled *bool `json:"isDisabled,omitempty"`

	// MetricName The name of the metric to be disabled or re-enabled.
	MetricName *string `json:"metricName,omitempty"`
}

// DriftPreventedAction defines model for DriftPreventedAction.
type DriftPreventedAction struct {
	// ErrMsg When `isSuccessful` is `false`, details on why the action failed.
	ErrMsg *string `json:"errMsg,omitempty"`

	// IsSuccessful Whether or not the action was completed successfully.
	IsSuccessful *bool `json:"isSuccessful,omitempty"`

	// Type Action type.
	Type ActionType `json:"type"`
}

// EfoIntegrationResponseV1 Get Integration Response
type EfoIntegrationResponseV1 struct {
	union json.RawMessage
}

// Engine The engine used to generate the event out of the raw signal:
// - `drift` - engine to detect container drifts
// - `falco` - Falco open source engine
// - `list` - list matching engine for list matching rules
// - `machineLearning` - ML engine
// - `malware` - malware detection engine
type Engine = string

// EntityDefinition Defines the structure and metadata of a field in the query result.
type EntityDefinition struct {
	// Alias The alias used in the query.
	Alias *string `json:"alias,omitempty"`

	// Definition Detailed definition of the field.
	Definition struct {
		// DefType Type of the definition.
		DefType EntityDefinitionDefinitionDefType `json:"def_type"`

		// Hidden Indicates if the field is hidden from view.
		Hidden *bool `json:"hidden,omitempty"`

		// Name Name of the field.
		Name string `json:"name"`

		// Type Data type of the field.
		Type EntityDefinitionDefinitionType `json:"type"`
	} `json:"definition"`

	// Type Type of the entity.
	Type string `json:"type"`
}

// EntityDefinitionDefinitionDefType Type of the definition.
type EntityDefinitionDefinitionDefType string

// EntityDefinitionDefinitionType Data type of the field.
type EntityDefinitionDefinitionType string

// EntriesResponse The response to a GET entries call
type EntriesResponse struct {
	// Data The actual data contained in one of the supported types of entry
	Data *[]EntriesResponse_Data_Item `json:"data,omitempty"`

	// Page Pagination information.
	Page *Page `json:"page,omitempty"`
}

// EntriesResponse_Data_Item defines model for EntriesResponse.data.Item.
type EntriesResponse_Data_Item struct {
	union json.RawMessage
}

// Entry The base structure of an Activity Audit entry
type Entry struct {
	// Id The audit event id.
	Id Id `json:"id"`

	// Timestamp Timestamp the audit event occured, expressed in nanoseconds.
	Timestamp Timestamp `json:"timestamp"`
}

// EntryId The event id.
type EntryId = string

// EntryPointModuleV1 The Module is the area in Sysdig Monitor.
type EntryPointModuleV1 string

// EntryPointV1 The page you see after logging into Sysdig UI. It is defined by a Module and a Selection.
// **The Entry Point is not supported in Sysdig Secure.**
type EntryPointV1 struct {
	// Module The Module is the area in Sysdig Monitor.
	Module *EntryPointModuleV1 `json:"module,omitempty"`

	// Selection The selection is the specific page within the Module, usually defined by the resource ID.
	// It is supported only supported by **Dashboards** and **DashboardTemplates** Modules.
	Selection *string `json:"selection"`
}

// EntryResponse The response to a GET entry call
type EntryResponse struct {
	union json.RawMessage
}

// Error defines model for Error.
type Error struct {
	// Details A list of details related to the error.
	Details *[]interface{} `json:"details,omitempty"`

	// Message A human readable error message.
	Message *string `json:"message,omitempty"`

	// Type The error code.
	Type *string `json:"type,omitempty"`
}

// Event Event feed
type Event struct {
	// Actions actions that have been triggered by the event
	Actions *[]Action `json:"actions,omitempty"`

	// Category The event category:
	// - `runtime` - Agent-based threat detection events
	// - `remote` - Kubernetes admission requests and CloudConnector events
	// - `admissionController` - Kubernetes admission requests-posture checks
	// - `cloudtrail` - Agentless CloudTrail CDR events
	// - `okta` - Agentless Okta CDR events
	// - `github` - Agentless Github CDR events
	// - `falcocloud` - Agentless CDR events (excluded CloudTrail, Okta, Github)
	// - `miner` - Workload ML Crypto events
	Category Category `json:"category"`

	// Content Event data. It contains fields from the original event and attributes generated at the engine level.
	Content *EventContent `json:"content,omitempty"`

	// Cursor The cursor that can be used to fetch a set of events surrounding
	// this same event. By providing this value as `cursor` in a GET
	// `secureEvents` request, you will get the set of events surrounding
	// this current event.
	Cursor *string `json:"cursor,omitempty"`

	// Description Description of the policy the event is generated after.
	Description string `json:"description"`

	// Engine The engine used to generate the event out of the raw signal:
	// - `drift` - engine to detect container drifts
	// - `falco` - Falco open source engine
	// - `list` - list matching engine for list matching rules
	// - `machineLearning` - ML engine
	// - `malware` - malware detection engine
	Engine *Engine `json:"engine,omitempty"`

	// Id The event id.
	Id string `json:"id"`

	// Labels Key value pairs of values.
	Labels *ArbitraryMapOfStrings `json:"labels,omitempty"`

	// Name Name of the policy the event is generated after.
	Name string `json:"name"`

	// Originator Type of event:
	// - policy - Agent-based runtime threat detection events
	// - profilingDetection - Workload ML detections
	// - falcocloud - Agentless threat detections
	// - admissionController - Kubernetes admission control based posture events
	Originator Originator `json:"originator"`

	// RawEventCategory The semantic category (area) of the event in the Sysdig product:
	// - `kspm` -  Kubernetes Security Posture Management events
	// - `runtime` - Threat detection events
	RawEventCategory *RawEventCategory `json:"rawEventCategory,omitempty"`

	// RawEventOriginator The agent type, hosting the `engine`, that generated the event after the raw event
	// - `admissionController` - Admission Controller, part of the Cluster Shield
	// - `agentless` - Agentless
	// - `cloudConnector` - Cloud Connector
	// - `linuxAgent` - Linux Host Agent
	// - `serverlessAgent` - Serverless workloads Agent (CaaS) generated events
	// - `windowsAgent` - Windows Host Agent
	RawEventOriginator *RawEventOriginator `json:"rawEventOriginator,omitempty"`

	// Severity The policy severity:
	// - `0-3` - High
	// - `4-5` - Medium
	// - `6` - Low
	// - `7` - Info
	Severity int32 `json:"severity"`

	// Source Source of the event:
	// - `syscall` - a syscall within a workload
	// - `windows` - Windows event log
	// - `profiling` - ML workload threat detections
	// - `K8SAdmissionController` - Admission control request coming from the Kubernetes admission controller
	// - `k8s_audit` - Kubernetes audit logs, if the category is `runtime`, otherwise Admission control request
	// - `aws_cloudtrail` - AWS CloudTrail log, from CloudConnector
	// - `awscloudtrail` - AWS CloudTrail log, agentless only
	// - `agentless-aws-ml` - ML threat detections for AWS
	// - `gcp_auditlog` - GCP Audit log
	// - `azure_platformlogs` - Azure platform logs
	// - `okta` - Okta System Logs
	// - `agentless-okta-ml` - ML threat detections for Okta
	// - `github` - Github organization logs
	Source Source `json:"source"`

	// SourceDetails Additional details related to the Event source.
	SourceDetails *SourceDetails `json:"sourceDetails,omitempty"`

	// Timestamp The event timestamp in nanoseconds.
	Timestamp int64 `json:"timestamp"`
}

// EventContent Event data. It contains fields from the original event and attributes generated at the engine level.
type EventContent struct {
	union json.RawMessage
}

// EventContentType The type of the event content.
type EventContentType string

// EventsFeedFilter Query language expression for filtering results.
// The filter is the result of logical concatenations,
// using "and" and "or" binary operators and the "not" unary prefix operator (i.e. `pid = 1 and not ppid = 2`),
// of attribute comparisons. Attribute comparisons can be:
// - scalar, using `=`, `!=`, `>`, `>=`, `<` and `<=` comparison operators (i.e. `pid = 1`)
// - vector, using `in` to check the equality among one of the values provided between parenthesis (i.e. `pid in (1, 2)`)
// Depending on the attribute, only some operators can be available.
// Values containing double-quotes `"` need escaping using backslash `\`, i.e. name = "sample \"quoted\" value".
// The list of supported attributes and related operators supported can be retrieved through the
// `/secure/events/v1/supported-filters` endpoint.
// `freeText` is available as an additional attribute to provide free-text search capabilities.
// `freeText` supports the operators `=` (match) and `!=` (does not match).
//
// EBNF:
// ```
// attribute             = ? all available attributes ? ;
// value                 = ? attribute value ? ;
// quoted_value          = "\"", value, "\"" ;
// bin_operator          = "and" | "or";
// cmp_scalar_operator   = "=" | "!=" | ">" | ">=" | "<" | "<=" ;
// cmp_vector_operator   = "in";
// cmp_scalar_operation  = attribute, [" "], cmp_scalar_operator, [" "], quoted_value ;
// values_list           = "(", quoted_value, { [" "], ",", quoted_value }, ")" ;
// cmp_vector_operation  = attribute, " ", cmp_vector_operator, [" "], values_list ;
// freetext_operation    = "freeText ", "=" | "!=", quoted_value ;
// element               = ["not "], (cmp_scalar_operation | cmp_vector_operation | freetext_operation) ;
// filter                = element, {" ", bin_operator, " ", element} ;
// ```
type EventsFeedFilter = string

// EventsFeedLimit The number of items to return
type EventsFeedLimit = int32

// EventsFeedPage Pagination information.
type EventsFeedPage struct {
	// Next `next` is a string pointing to the next page of data.
	// Use this as the `cursor` to scroll paginated results and get the next page of data.
	// If not included, the current response is the last page.
	Next *string `json:"next,omitempty"`

	// Prev `prev` is a string pointing to the previous page of data.
	// Use this as the `cursor` to get the previous page of data.
	Prev *string `json:"prev,omitempty"`

	// Total The number of events matching the search criteria. This number is always major or equal to the number of events returned.
	Total int64 `json:"total"`
}

// ExecutionContext The context in which the Response Action is executed.\
// It may contain additional information on the Response Action being executed, such as the host name or the MAC address.\
// For example:\
// ```json
//
//	{
//	    "host.hostName": "my-host",
//	    "host.mac": "00:00:00:00:00:00",
//	    "host.id": "abc123"
//	}
//
// ```
type ExecutionContext map[string]string

// Exploit defines model for Exploit.
type Exploit struct {
	Links []string `json:"links"`

	// PublicationDate exploit publication date
	PublicationDate *time.Time `json:"publicationDate,omitempty"`
}

// Failure The reason a Response Action failed to execute.
type Failure struct {
	// FailureReason The reason for the failure.
	FailureReason string `json:"failureReason"`

	// LogMessage The log message of the action failure.
	LogMessage string `json:"logMessage"`
}

// Fileaccess defines model for Fileaccess.
type Fileaccess struct {
	// Comm The name of the command.
	Comm string `json:"comm"`

	// ContainerId The container id. `containerId` is present only if the audit event was
	// collected in a container context.
	ContainerId *ContainerId `json:"containerId,omitempty"`

	// Directory The Directory for the file access.
	Directory string `json:"directory"`

	// Filename The Filename involved in file access.
	Filename string `json:"filename"`

	// Hostname The Kubernetes hostname.
	Hostname Hostname `json:"hostname"`

	// Id The audit event id.
	Id Id `json:"id"`

	// Labels Key value pairs of labels.
	Labels *map[string]string `json:"labels,omitempty"`

	// Permissions The Permissions of the file access.
	Permissions string `json:"permissions"`

	// Pid Id of the process owning the connection.
	Pid int64 `json:"pid"`

	// Timestamp Timestamp the audit event occured, expressed in nanoseconds.
	Timestamp Timestamp `json:"timestamp"`

	// Tty TTY number.
	Tty *int64 `json:"tty,omitempty"`

	// Type The entry type
	Type FileaccessType `json:"type"`
}

// FileaccessType The entry type
type FileaccessType string

// From From, expressed in Unix nanoseconds timestamp. The difference between `from` and `to`
// cannot be greater than 2 weeks.
// If defined, `cursor` cannot be used.
type From = int64

// GetAccessKeysPaginatedResponseV1 defines model for GetAccessKeysPaginatedResponseV1.
type GetAccessKeysPaginatedResponseV1 struct {
	Data *[]AccessKeyResponseV1 `json:"data,omitempty"`

	// Page Page information.
	Page *struct {
		Next     *string `json:"next"`
		Previous *string `json:"previous"`
		Total    *int64  `json:"total,omitempty"`
	} `json:"page,omitempty"`
}

// GetAmazonSqsIntegrationResponse defines model for GetAmazonSqsIntegrationResponse.
type GetAmazonSqsIntegrationResponse struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       IntegrationChannels         `json:"channels"`
	ConnectionInfo BaseConnectionInfoAmazonSqs `json:"connectionInfo"`

	// Id The ID of the integration
	Id int64 `json:"id"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled bool `json:"isEnabled"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// GetBundleResponse Bundle definition
type GetBundleResponse struct {
	// BundleType Specifies whether the Bundle was defined by the Customer or by Sysdig
	BundleType GetBundleResponseBundleType `json:"bundleType"`

	// Description The Bundle description
	Description *string `json:"description,omitempty"`

	// Id The Bundle ID
	Id int64 `json:"id"`

	// Identifier The Policy identifier generated from the name
	Identifier string `json:"identifier"`

	// Name The human readable Bundle name
	Name string `json:"name"`

	// Rules The Rules defining this Bundle
	Rules []BundleRule `json:"rules"`
}

// GetBundleResponseBundleType Specifies whether the Bundle was defined by the Customer or by Sysdig
type GetBundleResponseBundleType string

// GetChronicleIntegrationResponse defines model for GetChronicleIntegrationResponse.
type GetChronicleIntegrationResponse struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       IntegrationChannels                            `json:"channels"`
	ConnectionInfo GetChronicleIntegrationResponse_ConnectionInfo `json:"connectionInfo"`

	// Id The ID of the integration
	Id int64 `json:"id"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled bool `json:"isEnabled"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// GetChronicleIntegrationResponse_ConnectionInfo defines model for GetChronicleIntegrationResponse.ConnectionInfo.
type GetChronicleIntegrationResponse_ConnectionInfo struct {
	union json.RawMessage
}

// GetCustomJobsPaginatedResponseV1 defines model for GetCustomJobsPaginatedResponseV1.
type GetCustomJobsPaginatedResponseV1 struct {
	Data *[]CustomJobV1 `json:"data,omitempty"`

	// Page Page information.
	Page *struct {
		Next     *string `json:"next"`
		Previous *string `json:"previous"`
		Total    *int64  `json:"total,omitempty"`
	} `json:"page,omitempty"`
}

// GetElasticsearchIntegrationResponse defines model for GetElasticsearchIntegrationResponse.
type GetElasticsearchIntegrationResponse struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       IntegrationChannels             `json:"channels"`
	ConnectionInfo BaseConnectionInfoElasticsearch `json:"connectionInfo"`

	// Id The ID of the integration
	Id int64 `json:"id"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled bool `json:"isEnabled"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// GetGooglePubSubIntegrationResponse defines model for GetGooglePubSubIntegrationResponse.
type GetGooglePubSubIntegrationResponse struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       IntegrationChannels            `json:"channels"`
	ConnectionInfo BaseConnectionInfoGooglePubSub `json:"connectionInfo"`

	// Id The ID of the integration
	Id int64 `json:"id"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled bool `json:"isEnabled"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// GetGoogleSccIntegrationResponse defines model for GetGoogleSccIntegrationResponse.
type GetGoogleSccIntegrationResponse struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       IntegrationChannels         `json:"channels"`
	ConnectionInfo BaseConnectionInfoGoogleScc `json:"connectionInfo"`

	// Id The ID of the integration
	Id int64 `json:"id"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled bool `json:"isEnabled"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// GetInhibitionRulesPaginatedResponseV1 defines model for GetInhibitionRulesPaginatedResponseV1.
type GetInhibitionRulesPaginatedResponseV1 struct {
	Data *[]InhibitionRuleResponseV1 `json:"data,omitempty"`

	// Page Page information.
	Page *struct {
		Next     *string `json:"next"`
		Previous *string `json:"previous"`
		Total    *int64  `json:"total,omitempty"`
	} `json:"page,omitempty"`
}

// GetKafkaIntegrationResponse defines model for GetKafkaIntegrationResponse.
type GetKafkaIntegrationResponse struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       IntegrationChannels                        `json:"channels"`
	ConnectionInfo GetKafkaIntegrationResponse_ConnectionInfo `json:"connectionInfo"`

	// Id The ID of the integration
	Id int64 `json:"id"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled bool `json:"isEnabled"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// GetKafkaIntegrationResponse_ConnectionInfo defines model for GetKafkaIntegrationResponse.ConnectionInfo.
type GetKafkaIntegrationResponse_ConnectionInfo struct {
	union json.RawMessage
}

// GetKafkaIntegrationResponseV1 defines model for GetKafkaIntegrationResponseV1.
type GetKafkaIntegrationResponseV1 struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       IntegrationChannels                          `json:"channels"`
	ConnectionInfo GetKafkaIntegrationResponseV1_ConnectionInfo `json:"connectionInfo"`

	// Id The ID of the integration
	Id int64 `json:"id"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled bool `json:"isEnabled"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// GetKafkaIntegrationResponseV1ConnectionInfoAuth The authentication method to optionally use. Currently supporting only GSSAPI
type GetKafkaIntegrationResponseV1ConnectionInfoAuth string

// GetKafkaIntegrationResponseV1ConnectionInfoBalancer Algorithm that the client uses to multiplex data between the multiple Brokers. For compatibility with the Java client, Murmur2 is used as the default partitioner
type GetKafkaIntegrationResponseV1ConnectionInfoBalancer string

// GetKafkaIntegrationResponseV1ConnectionInfoCompression Compression standard used for the data
type GetKafkaIntegrationResponseV1ConnectionInfoCompression string

// GetKafkaIntegrationResponseV1_ConnectionInfo defines model for GetKafkaIntegrationResponseV1.ConnectionInfo.
type GetKafkaIntegrationResponseV1_ConnectionInfo struct {
	// Auth The authentication method to optionally use. Currently supporting only GSSAPI
	Auth GetKafkaIntegrationResponseV1ConnectionInfoAuth `json:"auth"`

	// Balancer Algorithm that the client uses to multiplex data between the multiple Brokers. For compatibility with the Java client, Murmur2 is used as the default partitioner
	Balancer *GetKafkaIntegrationResponseV1ConnectionInfoBalancer `json:"balancer,omitempty"`

	// Brokers Kafka server endpoint. A Kafka cluster may provide several brokers; it follows the 'hostname: port' (without protocol scheme).
	Brokers []string `json:"brokers"`

	// Compression Compression standard used for the data
	Compression *GetKafkaIntegrationResponseV1ConnectionInfoCompression `json:"compression,omitempty"`

	// Krb5 Kerberos krb5.conf file content for GSSAPI
	Krb5 string `json:"krb5"`

	// Principal GSSAPI principal
	Principal string `json:"principal"`

	// Realm GSSAPI realm
	Realm string `json:"realm"`

	// Service GSSAPI Service name
	Service string `json:"service"`

	// Topic Kafka topic where you want to store the forwarded data
	Topic string `json:"topic"`
	union json.RawMessage
}

// GetMcmIntegrationResponse defines model for GetMcmIntegrationResponse.
type GetMcmIntegrationResponse struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       IntegrationChannels   `json:"channels"`
	ConnectionInfo BaseConnectionInfoMcm `json:"connectionInfo"`

	// Id The ID of the integration
	Id int64 `json:"id"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled bool `json:"isEnabled"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// GetMicrosoftSentinelIntegrationResponse defines model for GetMicrosoftSentinelIntegrationResponse.
type GetMicrosoftSentinelIntegrationResponse struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       IntegrationChannels                 `json:"channels"`
	ConnectionInfo BaseConnectionInfoMicrosoftSentinel `json:"connectionInfo"`

	// Id The ID of the integration
	Id int64 `json:"id"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled bool `json:"isEnabled"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// GetNotificationChannelsPaginatedResponseV1 defines model for GetNotificationChannelsPaginatedResponseV1.
type GetNotificationChannelsPaginatedResponseV1 struct {
	Data *[]NotificationChannelResponseV1 `json:"data,omitempty"`

	// Page Page information.
	Page *struct {
		Next     *string `json:"next"`
		Previous *string `json:"previous"`
		Total    *int64  `json:"total,omitempty"`
	} `json:"page,omitempty"`
}

// GetPermissionsResponseV1 Permissions response
type GetPermissionsResponseV1 struct {
	// Permissions Set of permissions
	Permissions *[]PermissionV1 `json:"permissions,omitempty"`

	// Total Total number of permissions
	Total *int32 `json:"total,omitempty"`
}

// GetPolicyResponse A Policy definition
type GetPolicyResponse struct {
	// Bundles bundles defining this policy
	Bundles []BundleRef `json:"bundles"`

	// Description policy description
	Description *string `json:"description,omitempty"`

	// Id the Policy ID
	Id int `json:"id"`

	// Identifier policy identifier generated from the name
	Identifier string `json:"identifier"`

	// Name human readable policy name
	Name string `json:"name"`

	// Stages array of stages for the policy.
	// An empty array means the policy is applied only when specifically requested by its identifier.
	Stages []Stage `json:"stages"`
}

// GetPricingPaginatedResponseV1 defines model for GetPricingPaginatedResponseV1.
type GetPricingPaginatedResponseV1 struct {
	Data *[]PricingResponseV1 `json:"data,omitempty"`

	// Page Page information.
	Page *struct {
		Next     *string `json:"next"`
		Previous *string `json:"previous"`
		Total    *int64  `json:"total,omitempty"`
	} `json:"page,omitempty"`
}

// GetPricingProjectedPaginatedResponseV1 defines model for GetPricingProjectedPaginatedResponseV1.
type GetPricingProjectedPaginatedResponseV1 struct {
	Data *[]PricingProjectedResponseV1 `json:"data,omitempty"`

	// Page Page information.
	Page *struct {
		Next     *string `json:"next"`
		Previous *string `json:"previous"`
		Total    *int64  `json:"total,omitempty"`
	} `json:"page,omitempty"`
}

// GetQradarIntegrationResponse defines model for GetQradarIntegrationResponse.
type GetQradarIntegrationResponse struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       IntegrationChannels      `json:"channels"`
	ConnectionInfo BaseConnectionInfoQradar `json:"connectionInfo"`

	// Id The ID of the integration
	Id int64 `json:"id"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled bool `json:"isEnabled"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// GetRolesPaginatedResponseV1 defines model for GetRolesPaginatedResponseV1.
type GetRolesPaginatedResponseV1 struct {
	Data *[]RoleResponseV1 `json:"data,omitempty"`

	// Page Page information.
	Page *struct {
		Next     *string `json:"next"`
		Previous *string `json:"previous"`
		Total    *int64  `json:"total,omitempty"`
	} `json:"page,omitempty"`
}

// GetServiceAccountsPaginatedResponseV1 defines model for GetServiceAccountsPaginatedResponseV1.
type GetServiceAccountsPaginatedResponseV1 struct {
	Data *[]ServiceAccountResponseV1 `json:"data,omitempty"`

	// Page Page information.
	Page *struct {
		Next     *string `json:"next"`
		Previous *string `json:"previous"`
		Total    *int64  `json:"total,omitempty"`
	} `json:"page,omitempty"`
}

// GetSplunkIntegrationResponse defines model for GetSplunkIntegrationResponse.
type GetSplunkIntegrationResponse struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       IntegrationChannels      `json:"channels"`
	ConnectionInfo BaseConnectionInfoSplunk `json:"connectionInfo"`

	// Id The ID of the integration
	Id int64 `json:"id"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled bool `json:"isEnabled"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// GetSyslogIntegrationResponse defines model for GetSyslogIntegrationResponse.
type GetSyslogIntegrationResponse struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       IntegrationChannels      `json:"channels"`
	ConnectionInfo BaseConnectionInfoSyslog `json:"connectionInfo"`

	// Id The ID of the integration
	Id int64 `json:"id"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled bool `json:"isEnabled"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// GetTeamUsersPaginatedResponseV1 defines model for GetTeamUsersPaginatedResponseV1.
type GetTeamUsersPaginatedResponseV1 struct {
	Data *[]TeamUserResponseV1 `json:"data,omitempty"`

	// Page Page information.
	Page *struct {
		Next     *string `json:"next"`
		Previous *string `json:"previous"`
		Total    *int64  `json:"total,omitempty"`
	} `json:"page,omitempty"`
}

// GetTeamsPaginatedResponseV1 defines model for GetTeamsPaginatedResponseV1.
type GetTeamsPaginatedResponseV1 struct {
	Data *[]TeamResponseV1 `json:"data,omitempty"`

	// Page Page information.
	Page *struct {
		Next     *string `json:"next"`
		Previous *string `json:"previous"`
		Total    *int64  `json:"total,omitempty"`
	} `json:"page,omitempty"`
}

// GetUsersPaginatedResponseV1 defines model for GetUsersPaginatedResponseV1.
type GetUsersPaginatedResponseV1 struct {
	Data *[]UserResponseV1 `json:"data,omitempty"`

	// Page Page information.
	Page *struct {
		Next     *string `json:"next"`
		Previous *string `json:"previous"`
		Total    *int64  `json:"total,omitempty"`
	} `json:"page,omitempty"`
}

// GetWebhookIntegrationResponse defines model for GetWebhookIntegrationResponse.
type GetWebhookIntegrationResponse struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       IntegrationChannels       `json:"channels"`
	ConnectionInfo BaseConnectionInfoWebhook `json:"connectionInfo"`

	// Id The ID of the integration
	Id int64 `json:"id"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled bool `json:"isEnabled"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// GlobalSsoSettingsRequestV1 defines model for GlobalSsoSettingsRequestV1.
type GlobalSsoSettingsRequestV1 struct {
	// IsPasswordLoginEnabled Set to `true` to enable password login when SSO is enabled, or `false` to disable it.
	IsPasswordLoginEnabled bool `json:"isPasswordLoginEnabled"`
}

// GlobalSsoSettingsResponseV1 defines model for GlobalSsoSettingsResponseV1.
type GlobalSsoSettingsResponseV1 struct {
	// IsPasswordLoginEnabled Indicates whether password login is enabled.
	IsPasswordLoginEnabled *bool `json:"isPasswordLoginEnabled,omitempty"`
}

// GroupMappingResponseV1 defines model for GroupMappingResponseV1.
type GroupMappingResponseV1 struct {
	// CustomTeamRoleId The custom team role ID assigned for the user in this team. **Mutually exclusive with standardTeamRole**.
	CustomTeamRoleId *UnlimitedLong `json:"customTeamRoleId"`

	// DateCreated The date in which this group mapping was created in ISO 8601 format.
	DateCreated *time.Time `json:"dateCreated,omitempty"`

	// GroupName The group name matching the external provider name.
	GroupName *string `json:"groupName,omitempty"`

	Id *UnlimitedLong `json:"id,omitempty"`

	// IsAdmin Flag that indicates if the group is an admin group.
	IsAdmin *bool `json:"isAdmin,omitempty"`

	// LastUpdated The date in which this group mapping was last updated in ISO 8601 format.
	LastUpdated *time.Time `json:"lastUpdated,omitempty"`

	// StandardTeamRole The standard team role assigned for the user in this team. **Mutually exclusive with customTeamRoleId**.
	StandardTeamRole *TeamRoleV1 `json:"standardTeamRole"`

	// TeamMap Determines the teams to which a group is mapped.
	TeamMap *TeamMapV1 `json:"teamMap,omitempty"`

	// Weight The weight of the group mapping that is used to determine the priority - a lower number has higher priority.
	Weight *int16 `json:"weight,omitempty"`
}

// GroupMappingSettingsV1 The request to save group mapping settings.
// Currently settings for conflict resolution strategies are supported.
type GroupMappingSettingsV1 struct {
	// DifferentRolesSameTeamStrategy Strategy for handling different roles on the same team.
	DifferentRolesSameTeamStrategy GroupMappingSettingsV1DifferentRolesSameTeamStrategy `json:"differentRolesSameTeamStrategy"`

	// NoMappingStrategy Strategy for handling no mappings.
	NoMappingStrategy GroupMappingSettingsV1NoMappingStrategy `json:"noMappingStrategy"`

	// NoMappingsErrorRedirectUrl Redirect URL when NO_MAPPINGS_ERROR_REDIRECT is selected.
	NoMappingsErrorRedirectUrl *string `json:"noMappingsErrorRedirectUrl"`
}

// GroupMappingSettingsV1DifferentRolesSameTeamStrategy Strategy for handling different roles on the same team.
type GroupMappingSettingsV1DifferentRolesSameTeamStrategy string

// GroupMappingSettingsV1NoMappingStrategy Strategy for handling no mappings.
type GroupMappingSettingsV1NoMappingStrategy string

// GroupMappingsPaginatedResponseV1 defines model for GroupMappingsPaginatedResponseV1.
type GroupMappingsPaginatedResponseV1 struct {
	Data *[]GroupMappingResponseV1 `json:"data,omitempty"`

	// Page Page information.
	Page *struct {
		Next     *string `json:"next"`
		Previous *string `json:"previous"`
		Total    *int64  `json:"total,omitempty"`
	} `json:"page,omitempty"`
}

// GssapiConnectionInfoKafkaV1 defines model for GssapiConnectionInfoKafkaV1.
type GssapiConnectionInfoKafkaV1 struct {
	// Auth The authentication method to optionally use. Currently supporting only GSSAPI
	Auth GssapiConnectionInfoKafkaV1Auth `json:"auth"`

	// Krb5 Kerberos krb5.conf file content for GSSAPI
	Krb5 string `json:"krb5"`

	// Principal GSSAPI principal
	Principal string `json:"principal"`

	// Realm GSSAPI realm
	Realm string `json:"realm"`

	// Service GSSAPI Service name
	Service string `json:"service"`
}

// GssapiConnectionInfoKafkaV1Auth The authentication method to optionally use. Currently supporting only GSSAPI
type GssapiConnectionInfoKafkaV1Auth string

// HostMetadata defines model for HostMetadata.
type HostMetadata struct {
	// Architecture host architecture
	Architecture *string `json:"architecture,omitempty"`

	// HostId host id
	HostId string `json:"hostId"`

	// HostName host name
	HostName string `json:"hostName"`

	// Os host os
	Os string `json:"os"`
}

// HostName defines model for HostName.
type HostName struct {
	// ContextType Matcher type to apply
	ContextType *HostNameContextType `json:"contextType,omitempty"`

	// ContextValue Value to match
	ContextValue *string `json:"contextValue,omitempty"`
}

// HostNameContextType Matcher type to apply
type HostNameContextType string

// HostNameContains defines model for HostNameContains.
type HostNameContains struct {
	// ContextType Matcher type to apply
	ContextType *HostNameContainsContextType `json:"contextType,omitempty"`

	// ContextValue Value to match
	ContextValue *string `json:"contextValue,omitempty"`
}

// HostNameContainsContextType Matcher type to apply
type HostNameContainsContextType string

// Hostname The Kubernetes hostname.
type Hostname = string

// Id The audit event id.
type Id = string

// Image An Image resource that returns as part of of the image summary.
type Image struct {
	// Hash Resource unique identifier
	Hash string `json:"hash"`

	// InUseVulnerabilitySummary Vulnerability summary of a resource
	InUseVulnerabilitySummary VulnerabilitySummary `json:"inUseVulnerabilitySummary"`

	// Name Resource name
	Name string `json:"name"`

	// PullString The pull string for the image.
	PullString string `json:"pullString"`

	// Type The resource type
	Type string `json:"type"`

	// VmApiEndpoint A link that provides vulnerability management information about an image (Images only).
	VmApiEndpoint string `json:"vmApiEndpoint"`

	// VulnerabilitySummary Vulnerability summary of a resource
	VulnerabilitySummary VulnerabilitySummary `json:"vulnerabilitySummary"`
}

// ImageConfigCreationDateWithAge Predicate expressing "the image has been created before the specified amount of days".
type ImageConfigCreationDateWithAge struct {
	Extra struct {
		Key *int32 `json:"key,omitempty"`
	} `json:"extra"`
	Type ImageConfigCreationDateWithAgeType `json:"type"`
}

// ImageConfigCreationDateWithAgeType defines model for ImageConfigCreationDateWithAge.Type.
type ImageConfigCreationDateWithAgeType string

// ImageConfigDefaultUserIsNot Predicate expressing "the container user does not default to the specified user".
type ImageConfigDefaultUserIsNot struct {
	Extra struct {
		User string `json:"user"`
	} `json:"extra"`
	Type ImageConfigDefaultUserIsNotType `json:"type"`
}

// ImageConfigDefaultUserIsNotType defines model for ImageConfigDefaultUserIsNot.Type.
type ImageConfigDefaultUserIsNotType string

// ImageConfigDefaultUserIsRoot Predicate expressing "the container user defaults to root user".
type ImageConfigDefaultUserIsRoot struct {
	Type ImageConfigDefaultUserIsRootType `json:"type"`
}

// ImageConfigDefaultUserIsRootType defines model for ImageConfigDefaultUserIsRoot.Type.
type ImageConfigDefaultUserIsRootType string

// ImageConfigDefaultUserList Configuration to set the default user for the specified image.
type ImageConfigDefaultUserList struct {
	Extra struct {
		Operator ImageConfigDefaultUserListExtraOperator `json:"operator"`
		Users    []string                                `json:"users"`
	} `json:"extra"`
	Type ImageConfigDefaultUserListType `json:"type"`
}

// ImageConfigDefaultUserListExtraOperator defines model for ImageConfigDefaultUserList.Extra.Operator.
type ImageConfigDefaultUserListExtraOperator string

// ImageConfigDefaultUserListType defines model for ImageConfigDefaultUserList.Type.
type ImageConfigDefaultUserListType string

// ImageConfigEnvVariableContains Predicate expressing "the container has the specified environment variable and value".
type ImageConfigEnvVariableContains struct {
	Extra struct {
		Key   string  `json:"key"`
		Value *string `json:"value,omitempty"`
	} `json:"extra"`
	Type ImageConfigEnvVariableContainsType `json:"type"`
}

// ImageConfigEnvVariableContainsType defines model for ImageConfigEnvVariableContains.Type.
type ImageConfigEnvVariableContainsType string

// ImageConfigEnvVariableExists Predicate expressing "the container has the specified environment variable".
type ImageConfigEnvVariableExists struct {
	Extra struct {
		Key string `json:"key"`
	} `json:"extra"`
	Type ImageConfigEnvVariableExistsType `json:"type"`
}

// ImageConfigEnvVariableExistsType defines model for ImageConfigEnvVariableExists.Type.
type ImageConfigEnvVariableExistsType string

// ImageConfigEnvVariableNotExists Predicate expressing "the container does not have the specified environment variable".
type ImageConfigEnvVariableNotExists struct {
	Extra struct {
		Key string `json:"key"`
	} `json:"extra"`
	Type ImageConfigEnvVariableNotExistsType `json:"type"`
}

// ImageConfigEnvVariableNotExistsType defines model for ImageConfigEnvVariableNotExists.Type.
type ImageConfigEnvVariableNotExistsType string

// ImageConfigFailure defines model for ImageConfigFailure.
type ImageConfigFailure struct {
	Arguments map[string]interface{} `json:"arguments"`

	// Description image configuration failure description
	Description *string `json:"description,omitempty"`

	// PackageRef reference to the affected package
	PackageRef *string `json:"packageRef,omitempty"`

	// Remediation image configuration failure remediation
	Remediation string `json:"remediation"`

	// RiskAcceptRefs list of accepted risks for the failure
	RiskAcceptRefs *[]string `json:"riskAcceptRefs,omitempty"`

	// VulnerabilityRef reference to the vulnerability
	VulnerabilityRef *string `json:"vulnerabilityRef,omitempty"`
}

// ImageConfigInstructionIsPkgManager Predicate expressing "the image history contains a package manager command (eg. apk, npm, rpm, etc)".
type ImageConfigInstructionIsPkgManager struct {
	Type ImageConfigInstructionIsPkgManagerType `json:"type"`
}

// ImageConfigInstructionIsPkgManagerType defines model for ImageConfigInstructionIsPkgManager.Type.
type ImageConfigInstructionIsPkgManagerType string

// ImageConfigInstructionNotRecommended Predicate expressing "the image history contains not recommended instruction (ADD, ...)".
type ImageConfigInstructionNotRecommended struct {
	Type ImageConfigInstructionNotRecommendedType `json:"type"`
}

// ImageConfigInstructionNotRecommendedType defines model for ImageConfigInstructionNotRecommended.Type.
type ImageConfigInstructionNotRecommendedType string

// ImageConfigLabelExists Predicate expressing "the image has the specified label".
type ImageConfigLabelExists struct {
	Extra struct {
		Key string `json:"key"`
	} `json:"extra"`
	Type ImageConfigLabelExistsType `json:"type"`
}

// ImageConfigLabelExistsType defines model for ImageConfigLabelExists.Type.
type ImageConfigLabelExistsType string

// ImageConfigLabelNotContains Predicate expressing "the image has the specified label and value".
type ImageConfigLabelNotContains struct {
	Extra struct {
		Key   string `json:"key"`
		Value string `json:"value"`
	} `json:"extra"`
	Type ImageConfigLabelNotContainsType `json:"type"`
}

// ImageConfigLabelNotContainsType defines model for ImageConfigLabelNotContains.Type.
type ImageConfigLabelNotContainsType string

// ImageConfigLabelNotExists Predicate expressing "the image does not have the specified label".
type ImageConfigLabelNotExists struct {
	Extra struct {
		Key string `json:"key"`
	} `json:"extra"`
	Type ImageConfigLabelNotExistsType `json:"type"`
}

// ImageConfigLabelNotExistsType defines model for ImageConfigLabelNotExists.Type.
type ImageConfigLabelNotExistsType string

// ImageConfigSensitiveInformationAndSecrets Predicate expressing "the image contains sensitive information and secrets".
type ImageConfigSensitiveInformationAndSecrets struct {
	Type ImageConfigSensitiveInformationAndSecretsType `json:"type"`
}

// ImageConfigSensitiveInformationAndSecretsType defines model for ImageConfigSensitiveInformationAndSecrets.Type.
type ImageConfigSensitiveInformationAndSecretsType string

// ImageMetadata defines model for ImageMetadata.
type ImageMetadata struct {
	// Architecture image architecture
	Architecture *ImageMetadataArchitecture `json:"architecture,omitempty"`

	// Author image author
	Author *string `json:"author,omitempty"`

	// BaseOs image base os
	BaseOs string `json:"baseOs"`

	// CreatedAt datetime of creation
	CreatedAt CreatedAt `json:"createdAt"`

	// Digest image digest
	Digest *string `json:"digest,omitempty"`

	// ImageId image id
	ImageId string `json:"imageId"`

	// Labels image labels
	Labels *map[string]interface{} `json:"labels,omitempty"`

	// Os image os
	Os string `json:"os"`

	// PullString image pull string
	PullString string `json:"pullString"`

	// Size image size in bytes
	Size int64 `json:"size"`
}

// ImageMetadataArchitecture image architecture
type ImageMetadataArchitecture string

// ImageName defines model for ImageName.
type ImageName struct {
	// ContextType Matcher type to apply
	ContextType *ImageNameContextType `json:"contextType,omitempty"`

	// ContextValue Value to match
	ContextValue *string `json:"contextValue,omitempty"`
}

// ImageNameContextType Matcher type to apply
type ImageNameContextType string

// ImageNameContains defines model for ImageNameContains.
type ImageNameContains struct {
	// ContextType Matcher type to apply
	ContextType *ImageNameContainsContextType `json:"contextType,omitempty"`

	// ContextValue Value to match
	ContextValue *string `json:"contextValue,omitempty"`
}

// ImageNameContainsContextType Matcher type to apply
type ImageNameContainsContextType string

// ImagePrefix defines model for ImagePrefix.
type ImagePrefix struct {
	// ContextType Matcher type to apply
	ContextType *ImagePrefixContextType `json:"contextType,omitempty"`

	// ContextValue Value to match
	ContextValue *string `json:"contextValue,omitempty"`
}

// ImagePrefixContextType Matcher type to apply
type ImagePrefixContextType string

// ImageSuffix defines model for ImageSuffix.
type ImageSuffix struct {
	// ContextType Matcher type to apply
	ContextType *ImageSuffixContextType `json:"contextType,omitempty"`

	// ContextValue Value to match
	ContextValue *string `json:"contextValue,omitempty"`
}

// ImageSuffixContextType Matcher type to apply
type ImageSuffixContextType string

// InhibitionRuleResponseV1 defines model for InhibitionRuleResponseV1.
type InhibitionRuleResponseV1 struct {
	// CreatedOn Creation date.
	CreatedOn *time.Time `json:"createdOn,omitempty"`

	// CustomerId ID of customer that owns the inhibition rule.
	CustomerId *int32 `json:"customerId,omitempty"`

	// Description Description of the inhibition rule.
	Description *string `json:"description"`

	// Equal List of labels that must have an equal value in the source and target alert for the inhibition to take effect.
	Equal *[]string `json:"equal"`

	// Id Unique ID of the resource.
	Id *UnlimitedLong `json:"id,omitempty"`

	// IsEnabled Indicates if the inhibition rule is enabled or not.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// ModifiedOn Last modification date.
	ModifiedOn *time.Time `json:"modifiedOn,omitempty"`

	// Name Name of the inhibition rule.
	Name *string `json:"name"`

	// SourceMatchers List of source matchers for which one or more alerts have to exist for the inhibition to take effect.
	SourceMatchers *[]LabelMatcherV1 `json:"sourceMatchers,omitempty"`

	// TargetMatchers List of target matchers that have to be fulfilled by the target alerts to be muted.
	TargetMatchers *[]LabelMatcherV1 `json:"targetMatchers,omitempty"`

	// TeamId ID of team that owns the inhibition rule.
	TeamId *int32 `json:"teamId,omitempty"`

	// Version The current version of the resource.
	Version *UnlimitedLong `json:"version,omitempty"`
}

// IntegrationChannel Type of data to forward
type IntegrationChannel string

// IntegrationChannels Data types to forward. Must be compatible with the specified Integration type
type IntegrationChannels = []IntegrationChannel

// IntegrationChannelsResponse Integration Channels Response
type IntegrationChannelsResponse struct {
	// Data Data types to forward. Must be compatible with the specified Integration type
	Data IntegrationChannels `json:"data"`
}

// IntegrationResponse Get Integration Response
type IntegrationResponse struct {
	union json.RawMessage
}

// IntegrationResponseV1 defines model for IntegrationResponseV1.
type IntegrationResponseV1 struct {
	// ID Integration id.
	ID UnlimitedLong `json:"id"`

	// Name Integration name.
	Name string `json:"name"`

	// CreatedAt Integration creation date.
	CreatedAt time.Time `json:"createdAt"`

	// ModifiedAt Integration modification date.
	ModifiedAt time.Time `json:"modifiedAt"`

	// DeletedAt Integration deletion date.
	DeletedAt *time.Time `json:"deletedAt,omitempty"`

	// CustomerID Customer identifier for which the integration was created.
	CustomerID UnlimitedLong `json:"customerId"`

	// IsEnabled Integration enabled status.
	IsEnabled bool `json:"isEnabled"`

	// IsValid Integration valid status.
	IsValid bool `json:"isValid"`

	// IsAllTeams **True** if the integration is enabled for all teams, **false** otherwise and the *teamIds* for which is accessible will be defined.
	IsAllTeams bool `json:"isAllTeams"`

	// TeamIDs The list of internal Sysdig team ids that the integration is enabled for.
	TeamIDs *[]UnlimitedLong `json:"teamIds,omitempty"`

	// JiraProjectID Jira project id.
	JiraProjectID string `json:"jiraProjectId"`

	// JiraProjectName Jira project name.
	JiraProjectName *string `json:"jiraProjectName,omitempty"`

	// JiraURL Customer's Jira URL.
	JiraURL string `json:"jiraUrl"`

	// JiraEmail User's Jira email.
	JiraEmail openapi_types.Email `json:"jiraEmail"`

	// JiraAssignee The default assignee account id for this integration.
	JiraAssignee *string `json:"jiraAssignee,omitempty"`

	// JiraLabels The list of labels available for this integration.
	JiraLabels *[]string `json:"jiraLabels,omitempty"`

	// ParentIssueType Parent issue type for the integration.
	ParentIssueType *IssueTypeResponseV1 `json:"parentIssueType,omitempty"`

	// ChildIssueType Child issue type for the integration.
	ChildIssueType *IssueTypeResponseV1 `json:"childIssueType,omitempty"`
}

// IntegrationType The platform to which data will be forwarded
type IntegrationType string

// IntegrationTypesResponse The list of supported integration types
type IntegrationTypesResponse struct {
	Data []IntegrationType `json:"data"`
}

// InventoryPage The total number of pages the matched the filter, and the next and previous page numbers.
type InventoryPage struct {
	// Next The next page
	Next *int32 `json:"next,omitempty"`

	// Previous The previous page
	Previous *int32 `json:"previous,omitempty"`

	// Total Total page count
	Total int32 `json:"total"`
}

// InventoryResource An Inventory Resource
type InventoryResource struct {
	// Category The resource category
	Category string `json:"category"`

	// ConfigApiEndpoint A link that provides the resource configuration.
	ConfigApiEndpoint *string `json:"configApiEndpoint,omitempty"`

	// ContainerInfo List of containers (with some of kubernetes metadata) belonging to this kubernetes workload. If resource is not kubernetes workload this fild will be empty.
	ContainerInfo *[]ContainerInfo `json:"containerInfo,omitempty"`

	// Hash Resource unique identifier
	Hash string `json:"hash"`

	// InUseVulnerabilitySummary Vulnerability summary of a resource
	InUseVulnerabilitySummary *VulnerabilitySummary `json:"inUseVulnerabilitySummary,omitempty"`

	// IsExposed Indicates if a resource is exposed to the internet
	IsExposed *bool `json:"isExposed,omitempty"`

	// Labels The resource labels
	Labels []string `json:"labels"`

	// LastSeen Last scan date as unix timestamp
	LastSeen int64 `json:"lastSeen"`

	// Metadata The resource metadata
	Metadata map[string]interface{} `json:"metadata"`

	// Name Resource name
	Name string `json:"name"`

	// Platform The resource platform (such as AWS, GCP, Kubernetes, or Azure)
	Platform string `json:"platform"`

	// PostureControlSummaryApiEndpoint A link that provides the posture control summary.
	PostureControlSummaryApiEndpoint *string `json:"postureControlSummaryApiEndpoint,omitempty"`

	// PosturePolicySummary The posture policy summary
	PosturePolicySummary *PosturePolicySummary `json:"posturePolicySummary,omitempty"`

	// ResourceOrigin Where a resource was collected (Code, Deployed)
	ResourceOrigin string `json:"resourceOrigin"`

	// Type The resource type
	Type string `json:"type"`

	// ValidatedExposure Indicates if a resource which is exposed to the internet could be reach by our network exposure validator
	ValidatedExposure *bool `json:"validatedExposure,omitempty"`

	// VmApiEndpoint A link that provides vulnerability management information about an image (Images only).
	VmApiEndpoint *string `json:"vmApiEndpoint,omitempty"`

	// VulnerabilitySummary Vulnerability summary of a resource
	VulnerabilitySummary *VulnerabilitySummary `json:"vulnerabilitySummary,omitempty"`

	// Zones Resource zones
	Zones []InventoryZone `json:"zones"`
}

// InventoryResourceExtended defines model for InventoryResourceExtended.
type InventoryResourceExtended struct {
	// Category The resource category
	Category string `json:"category"`

	// ConfigApiEndpoint A link that provides the resource configuration.
	ConfigApiEndpoint *string `json:"configApiEndpoint,omitempty"`

	// ContainerInfo List of containers (with some of kubernetes metadata) belonging to this kubernetes workload. If resource is not kubernetes workload this fild will be empty.
	ContainerInfo *[]ContainerInfo `json:"containerInfo,omitempty"`

	// Hash Resource unique identifier
	Hash string `json:"hash"`

	// ImageSummary Images used by the workload (Workloads only)
	ImageSummary *[]Image `json:"imageSummary,omitempty"`

	// InUseVulnerabilitySummary Vulnerability summary of a resource
	InUseVulnerabilitySummary *VulnerabilitySummary `json:"inUseVulnerabilitySummary,omitempty"`

	// IsExposed Indicates if a resource is exposed to the internet
	IsExposed *bool `json:"isExposed,omitempty"`

	// Labels The resource labels
	Labels []string `json:"labels"`

	// LastSeen Last scan date as unix timestamp
	LastSeen int64 `json:"lastSeen"`

	// Metadata The resource metadata
	Metadata map[string]interface{} `json:"metadata"`

	// Name Resource name
	Name string `json:"name"`

	// Platform The resource platform (such as AWS, GCP, Kubernetes, or Azure)
	Platform string `json:"platform"`

	// PostureControlSummaryApiEndpoint A link that provides the posture control summary.
	PostureControlSummaryApiEndpoint *string `json:"postureControlSummaryApiEndpoint,omitempty"`

	// PosturePolicySummary The posture policy summary
	PosturePolicySummary *PosturePolicySummary `json:"posturePolicySummary,omitempty"`

	// ResourceOrigin Where a resource was collected (Code, Deployed)
	ResourceOrigin string `json:"resourceOrigin"`

	// Type The resource type
	Type string `json:"type"`

	// ValidatedExposure Indicates if a resource which is exposed to the internet could be reach by our network exposure validator
	ValidatedExposure *bool `json:"validatedExposure,omitempty"`

	// VmApiEndpoint A link that provides vulnerability management information about an image (Images only).
	VmApiEndpoint *string `json:"vmApiEndpoint,omitempty"`

	// VulnerabilitySummary Vulnerability summary of a resource
	VulnerabilitySummary *VulnerabilitySummary `json:"vulnerabilitySummary,omitempty"`

	// Zones Resource zones
	Zones []InventoryZone `json:"zones"`
}

// InventoryResourceResponse A paged response of resources that match the filter.
type InventoryResourceResponse struct {
	// Data The resources that matches the filter
	Data []InventoryResource `json:"data"`

	// Page The total number of pages the matched the filter, and the next and previous page numbers.
	Page InventoryPage `json:"page"`
}

// InventoryZone a Zone
type InventoryZone struct {
	// Id The zone identifier
	Id int64 `json:"id"`

	// Name The zone name
	Name string `json:"name"`
}

// IpFilterResponseV1 defines model for IpFilterResponseV1.
type IpFilterResponseV1 struct {
	Id *UnlimitedLong `json:"id,omitempty"`

	// IpRange IP range in CIDR notation
	IpRange *string `json:"ipRange,omitempty"`

	// IsAllowed Whether the IP range is allowed or not.
	IsAllowed *bool `json:"isAllowed,omitempty"`
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// LastUpdated The date when IP filter was last updated.
	LastUpdated *time.Time `json:"lastUpdated,omitempty"`
	Note        *string    `json:"note"`
}

// IpFiltersPaginatedResponseV1 defines model for IpFiltersPaginatedResponseV1.
type IpFiltersPaginatedResponseV1 struct {
	Data *[]IpFilterResponseV1 `json:"data,omitempty"`

	// Page Page information.
	Page *struct {
		Next     *string `json:"next"`
		Previous *string `json:"previous"`
		Total    *int64  `json:"total,omitempty"`
	} `json:"page,omitempty"`
}

// IpFiltersSettingsV1 Used to configure IP filters settings.
type IpFiltersSettingsV1 struct {
	// IsFilteringEnabled Specifies if IP filtering is enabled.
	IsFilteringEnabled *bool `json:"isFilteringEnabled,omitempty"`
}

// IssueTypeFieldResponseV1 defines model for IssueTypeFieldResponseV1.
type IssueTypeFieldResponseV1 struct {
	// ID Issue type field id.
	ID UnlimitedLong `json:"id"`

	// JiraID Issue type field id on Jira.
	JiraID string `json:"jiraId"`

	// JiraName Jira issue type field name.
	JiraName string `json:"jiraName"`

	// Type Issue type field type.
	Type IssueTypeFieldResponseV1Type `json:"type"`

	// IsRequired Indicates if the field is required.
	IsRequired bool `json:"isRequired"`

	// HasDefaultValue Indicates if the field has a default value.
	HasDefaultValue bool `json:"hasDefaultValue"`

	// AllowedValues Allowed values for the field.
	AllowedValues *[]IssueTypeFieldResponseV1_AllowedValues_Item `json:"allowedValues,omitempty"`
}

// IssueTypeFieldResponseV1Type Issue type field type.
type IssueTypeFieldResponseV1Type string

// IssueTypeFieldResponseV1_AllowedValues_Item defines model for IssueTypeFieldResponseV1.allowedValues.Item.
type IssueTypeFieldResponseV1_AllowedValues_Item struct {
	union json.RawMessage
}

// IssueTypeResponseV1 defines model for IssueTypeResponseV1.
type IssueTypeResponseV1 struct {
	// ID Issue type ID.
	ID UnlimitedLong `json:"id"`

	// JiraID Issue type ID on Jira.
	JiraID string `json:"jiraId"`

	// JiraName Jira issue type name.
	JiraName string `json:"jiraName"`

	// JiraHierarchyLevel Issue type hierarchy level on Jira.
	JiraHierarchyLevel int32 `json:"jiraHierarchyLevel"`

	// JiraOpenStatusID Jira status ID mapped to open status.
	JiraOpenStatusID string `json:"jiraOpenStatusId"`

	// JiraInProgressStatusID Jira status ID mapped to in progress status.
	JiraInProgressStatusID string `json:"jiraInProgressStatusId"`

	// JiraClosedStatusID Jira status ID mapped to closed status.
	JiraClosedStatusID string `json:"jiraClosedStatusId"`

	// StandardFields Standard fields for the issue type.
	StandardFields []IssueTypeFieldResponseV1 `json:"standardFields"`

	// CustomFields Custom fields for the issue type.
	CustomFields *[]IssueTypeFieldResponseV1 `json:"customFields,omitempty"`
}

// IssueTypesResponseV1 defines model for IssueTypesResponseV1.
type IssueTypesResponseV1 struct {
	// Data List of issue types.
	Data *[]IssueTypeResponseV1 `json:"data,omitempty"`
}

// JobResponse Schema for a job response
type JobResponse struct {
	// CompletedOn Timestamp when the job was completed
	CompletedOn *time.Time `json:"completedOn,omitempty"`

	// CreatedBy Email of the user who created the job
	CreatedBy string `json:"createdBy"`

	// CustomerId ID of the user associated with the job.
	CustomerId int64 `json:"customerId"`

	// FileName File name of the report
	FileName *string `json:"fileName,omitempty"`

	// FilePath File path of the report
	FilePath *string `json:"filePath,omitempty"`

	// IacTaskId ID of the IAC scheduled task.
	IacTaskId *int64 `json:"iacTaskId,omitempty"`

	// Id Unique identifier for the job.
	Id string `json:"id"`

	// IsReportTemplate Indicates if the report is a template
	IsReportTemplate bool `json:"isReportTemplate"`

	// JobName Name of the job
	JobName *string `json:"jobName,omitempty"`

	// JobType Type of the job
	JobType string `json:"jobType"`

	// Policies List of policy IDs
	Policies *[]int64 `json:"policies,omitempty"`

	// ReportFormat Format of the report
	ReportFormat string `json:"reportFormat"`

	// ReportId ID of the report
	ReportId int64 `json:"reportId"`

	// ScheduleId ID of the schedule associated with the job
	ScheduleId *string `json:"scheduleId,omitempty"`

	// ScheduledOn Timestamp when the job was scheduled
	ScheduledOn time.Time `json:"scheduledOn"`

	// StartedOn Timestamp when the job was started
	StartedOn *time.Time `json:"startedOn,omitempty"`

	// Status Status of the job
	Status string `json:"status"`

	// TeamId ID of the team the job was created under.
	TeamId int64 `json:"teamId"`

	// TimeFrame The start and end time of the request
	TimeFrame *TimeFrame `json:"timeFrame,omitempty"`

	// Timezone Timezone of the request time frame
	Timezone *string `json:"timezone,omitempty"`

	// UserId ID of the user who created the job.
	UserId int64 `json:"userId"`

	// Zones List of zone IDs
	Zones []int64 `json:"zones"`
}

// K8sAdmissionReviewContent defines model for K8sAdmissionReviewContent.
type K8sAdmissionReviewContent struct {
	// ClusterName Kubernetes cluster name
	ClusterName *string `json:"clusterName,omitempty"`

	// Namespace Kubernetes namespace
	Namespace *string `json:"namespace,omitempty"`

	// ResourceKind Kubernetes resource kind
	ResourceKind *string `json:"resourceKind,omitempty"`

	// ResourceName Kubernetes resource name
	ResourceName *string           `json:"resourceName,omitempty"`
	ScanResult   map[string]string `json:"scanResult"`

	// Type The type of the event content.
	Type EventContentType `json:"type"`

	// Zones List of zones that match the scope of the resource.
	Zones *[]Zone `json:"zones,omitempty"`
}

// KafkaAuthenticatedConnectionInfo Get Kafka Authenticated Integration Request
type KafkaAuthenticatedConnectionInfo struct {
	// Auth The authentication method to optionally use.  Currently supporting GSSAPI, SASL/PLAIN and SASL/SCRAM, plaintext only (no SSL).
	Auth  KafkaAuthenticatedConnectionInfoAuth `json:"auth"`
	union json.RawMessage
}

// KafkaAuthenticatedConnectionInfoAuth The authentication method to optionally use.  Currently supporting GSSAPI, SASL/PLAIN and SASL/SCRAM, plaintext only (no SSL).
type KafkaAuthenticatedConnectionInfoAuth string

// KafkaAuthenticatedPrivateConnectionInfo Create Kafka Authenticated Integration Request
type KafkaAuthenticatedPrivateConnectionInfo struct {
	// Auth The authentication method to optionally use.  Currently supporting GSSAPI, SASL/PLAIN and SASL/SCRAM, plaintext only (no SSL).
	Auth  KafkaAuthenticatedPrivateConnectionInfoAuth `json:"auth"`
	union json.RawMessage
}

// KafkaAuthenticatedPrivateConnectionInfoAuth The authentication method to optionally use.  Currently supporting GSSAPI, SASL/PLAIN and SASL/SCRAM, plaintext only (no SSL).
type KafkaAuthenticatedPrivateConnectionInfoAuth string

// KafkaGssapiAuthenticatedConnectionInfo defines model for KafkaGssapiAuthenticatedConnectionInfo.
type KafkaGssapiAuthenticatedConnectionInfo struct {
	// Auth The authentication method to optionally use.  Currently supporting GSSAPI, SASL/PLAIN and SASL/SCRAM, plaintext only (no SSL).
	Auth KafkaGssapiAuthenticatedConnectionInfoAuth `json:"auth"`

	// Balancer Algorithm that the client uses to multiplex data between the multiple Brokers. For compatibility with the Java client, Murmur2 is used as the default partitioner
	Balancer *KafkaGssapiAuthenticatedConnectionInfoBalancer `json:"balancer,omitempty"`

	// Brokers Kafka server endpoint. A Kafka cluster may provide several brokers; it follows the 'hostname: port' (without protocol scheme).
	Brokers []string `json:"brokers"`

	// Compression Compression standard used for the data
	Compression *KafkaGssapiAuthenticatedConnectionInfoCompression `json:"compression,omitempty"`

	// Krb5 Kerberos krb5.conf file content for GSSAPI
	Krb5 string `json:"krb5"`

	// Principal GSSAPI principal
	Principal string `json:"principal"`

	// Realm GSSAPI realm
	Realm string `json:"realm"`

	// Service GSSAPI Service name
	Service string `json:"service"`

	// Topic Kafka topic where you want to store the forwarded data
	Topic string `json:"topic"`
	union json.RawMessage
}

// KafkaGssapiAuthenticatedConnectionInfoAuth The authentication method to optionally use.  Currently supporting GSSAPI, SASL/PLAIN and SASL/SCRAM, plaintext only (no SSL).
type KafkaGssapiAuthenticatedConnectionInfoAuth string

// KafkaGssapiAuthenticatedConnectionInfoBalancer Algorithm that the client uses to multiplex data between the multiple Brokers. For compatibility with the Java client, Murmur2 is used as the default partitioner
type KafkaGssapiAuthenticatedConnectionInfoBalancer string

// KafkaGssapiAuthenticatedConnectionInfoCompression Compression standard used for the data
type KafkaGssapiAuthenticatedConnectionInfoCompression string

// KafkaGssapiAuthenticatedPrivateConnectionInfo defines model for KafkaGssapiAuthenticatedPrivateConnectionInfo.
type KafkaGssapiAuthenticatedPrivateConnectionInfo struct {
	// Auth The authentication method to optionally use.  Currently supporting GSSAPI, SASL/PLAIN and SASL/SCRAM, plaintext only (no SSL).
	Auth KafkaGssapiAuthenticatedPrivateConnectionInfoAuth `json:"auth"`

	// Balancer Algorithm that the client uses to multiplex data between the multiple Brokers. For compatibility with the Java client, Murmur2 is used as the default partitioner
	Balancer *KafkaGssapiAuthenticatedPrivateConnectionInfoBalancer `json:"balancer,omitempty"`

	// Brokers Kafka server endpoint. A Kafka cluster may provide several brokers; it follows the 'hostname: port' (without protocol scheme).
	Brokers []string `json:"brokers"`

	// Compression Compression standard used for the data
	Compression *KafkaGssapiAuthenticatedPrivateConnectionInfoCompression `json:"compression,omitempty"`

	// Keytab base64 encoded Kerberos keytab
	Keytab string `json:"keytab"`

	// Krb5 Kerberos krb5.conf file content for GSSAPI
	Krb5 string `json:"krb5"`

	// Principal GSSAPI principal
	Principal string `json:"principal"`

	// Realm GSSAPI realm
	Realm string `json:"realm"`

	// Service GSSAPI Service name
	Service string `json:"service"`

	// Topic Kafka topic where you want to store the forwarded data
	Topic string `json:"topic"`
	union json.RawMessage
}

// KafkaGssapiAuthenticatedPrivateConnectionInfoAuth The authentication method to optionally use.  Currently supporting GSSAPI, SASL/PLAIN and SASL/SCRAM, plaintext only (no SSL).
type KafkaGssapiAuthenticatedPrivateConnectionInfoAuth string

// KafkaGssapiAuthenticatedPrivateConnectionInfoBalancer Algorithm that the client uses to multiplex data between the multiple Brokers. For compatibility with the Java client, Murmur2 is used as the default partitioner
type KafkaGssapiAuthenticatedPrivateConnectionInfoBalancer string

// KafkaGssapiAuthenticatedPrivateConnectionInfoCompression Compression standard used for the data
type KafkaGssapiAuthenticatedPrivateConnectionInfoCompression string

// KafkaGssapiConnectionInfo defines model for KafkaGssapiConnectionInfo.
type KafkaGssapiConnectionInfo struct {
	// Auth The authentication method to optionally use.  Currently supporting GSSAPI, SASL/PLAIN and SASL/SCRAM, plaintext only (no SSL).
	Auth KafkaGssapiConnectionInfoAuth `json:"auth"`

	// Krb5 Kerberos krb5.conf file content for GSSAPI
	Krb5 string `json:"krb5"`

	// Principal GSSAPI principal
	Principal string `json:"principal"`

	// Realm GSSAPI realm
	Realm string `json:"realm"`

	// Service GSSAPI Service name
	Service string `json:"service"`
}

// KafkaGssapiConnectionInfoAuth The authentication method to optionally use.  Currently supporting GSSAPI, SASL/PLAIN and SASL/SCRAM, plaintext only (no SSL).
type KafkaGssapiConnectionInfoAuth string

// KafkaGssapiPrivateConnectionInfo defines model for KafkaGssapiPrivateConnectionInfo.
type KafkaGssapiPrivateConnectionInfo struct {
	// Keytab base64 encoded Kerberos keytab
	Keytab string `json:"keytab"`
}

// KafkaPlaintext defines model for KafkaPlaintext.
type KafkaPlaintext struct {
	IsTlsEnabled *KafkaPlaintextIsTlsEnabled `json:"isTlsEnabled,omitempty"`
}

// KafkaPlaintextIsTlsEnabled defines model for KafkaPlaintext.IsTlsEnabled.
type KafkaPlaintextIsTlsEnabled bool

// KafkaPlaintextV1 defines model for KafkaPlaintextV1.
type KafkaPlaintextV1 struct {
	IsTlsEnabled *KafkaPlaintextV1IsTlsEnabled `json:"isTlsEnabled,omitempty"`
}

// KafkaPlaintextV1IsTlsEnabled defines model for KafkaPlaintextV1.IsTlsEnabled.
type KafkaPlaintextV1IsTlsEnabled bool

// KafkaSaslPlainAuthenticatedConnectionInfo defines model for KafkaSaslPlainAuthenticatedConnectionInfo.
type KafkaSaslPlainAuthenticatedConnectionInfo struct {
	// Auth The authentication method to optionally use.  Currently supporting GSSAPI, SASL/PLAIN and SASL/SCRAM, plaintext only (no SSL).
	Auth KafkaSaslPlainAuthenticatedConnectionInfoAuth `json:"auth"`

	// Balancer Algorithm that the client uses to multiplex data between the multiple Brokers. For compatibility with the Java client, Murmur2 is used as the default partitioner
	Balancer *KafkaSaslPlainAuthenticatedConnectionInfoBalancer `json:"balancer,omitempty"`

	// Brokers Kafka server endpoint. A Kafka cluster may provide several brokers; it follows the 'hostname: port' (without protocol scheme).
	Brokers []string `json:"brokers"`

	// Compression Compression standard used for the data
	Compression *KafkaSaslPlainAuthenticatedConnectionInfoCompression `json:"compression,omitempty"`

	// Topic Kafka topic where you want to store the forwarded data
	Topic string `json:"topic"`

	// Username Username
	Username string `json:"username"`
	union    json.RawMessage
}

// KafkaSaslPlainAuthenticatedConnectionInfoAuth The authentication method to optionally use.  Currently supporting GSSAPI, SASL/PLAIN and SASL/SCRAM, plaintext only (no SSL).
type KafkaSaslPlainAuthenticatedConnectionInfoAuth string

// KafkaSaslPlainAuthenticatedConnectionInfoBalancer Algorithm that the client uses to multiplex data between the multiple Brokers. For compatibility with the Java client, Murmur2 is used as the default partitioner
type KafkaSaslPlainAuthenticatedConnectionInfoBalancer string

// KafkaSaslPlainAuthenticatedConnectionInfoCompression Compression standard used for the data
type KafkaSaslPlainAuthenticatedConnectionInfoCompression string

// KafkaSaslPlainAuthenticatedPrivateConnectionInfo defines model for KafkaSaslPlainAuthenticatedPrivateConnectionInfo.
type KafkaSaslPlainAuthenticatedPrivateConnectionInfo struct {
	// Auth The authentication method to optionally use.  Currently supporting GSSAPI, SASL/PLAIN and SASL/SCRAM, plaintext only (no SSL).
	Auth KafkaSaslPlainAuthenticatedPrivateConnectionInfoAuth `json:"auth"`

	// Balancer Algorithm that the client uses to multiplex data between the multiple Brokers. For compatibility with the Java client, Murmur2 is used as the default partitioner
	Balancer *KafkaSaslPlainAuthenticatedPrivateConnectionInfoBalancer `json:"balancer,omitempty"`

	// Brokers Kafka server endpoint. A Kafka cluster may provide several brokers; it follows the 'hostname: port' (without protocol scheme).
	Brokers []string `json:"brokers"`

	// Compression Compression standard used for the data
	Compression *KafkaSaslPlainAuthenticatedPrivateConnectionInfoCompression `json:"compression,omitempty"`

	// Password Password
	Password string `json:"password"`

	// Topic Kafka topic where you want to store the forwarded data
	Topic string `json:"topic"`

	// Username Username
	Username string `json:"username"`
	union    json.RawMessage
}

// KafkaSaslPlainAuthenticatedPrivateConnectionInfoAuth The authentication method to optionally use.  Currently supporting GSSAPI, SASL/PLAIN and SASL/SCRAM, plaintext only (no SSL).
type KafkaSaslPlainAuthenticatedPrivateConnectionInfoAuth string

// KafkaSaslPlainAuthenticatedPrivateConnectionInfoBalancer Algorithm that the client uses to multiplex data between the multiple Brokers. For compatibility with the Java client, Murmur2 is used as the default partitioner
type KafkaSaslPlainAuthenticatedPrivateConnectionInfoBalancer string

// KafkaSaslPlainAuthenticatedPrivateConnectionInfoCompression Compression standard used for the data
type KafkaSaslPlainAuthenticatedPrivateConnectionInfoCompression string

// KafkaSaslPlainConnectionInfo defines model for KafkaSaslPlainConnectionInfo.
type KafkaSaslPlainConnectionInfo struct {
	// Auth The authentication method to optionally use.  Currently supporting GSSAPI, SASL/PLAIN and SASL/SCRAM, plaintext only (no SSL).
	Auth KafkaSaslPlainConnectionInfoAuth `json:"auth"`

	// Username Username
	Username string `json:"username"`
}

// KafkaSaslPlainConnectionInfoAuth The authentication method to optionally use.  Currently supporting GSSAPI, SASL/PLAIN and SASL/SCRAM, plaintext only (no SSL).
type KafkaSaslPlainConnectionInfoAuth string

// KafkaSaslPlainPrivateConnectionInfo defines model for KafkaSaslPlainPrivateConnectionInfo.
type KafkaSaslPlainPrivateConnectionInfo struct {
	// Password Password
	Password string `json:"password"`
}

// KafkaSaslScramAuthenticatedConnectionInfo defines model for KafkaSaslScramAuthenticatedConnectionInfo.
type KafkaSaslScramAuthenticatedConnectionInfo struct {
	// Algorithm Hashing algorithm to use
	Algorithm KafkaSaslScramAuthenticatedConnectionInfoAlgorithm `json:"algorithm"`

	// Auth The authentication method to optionally use.  Currently supporting GSSAPI, SASL/PLAIN and SASL/SCRAM, plaintext only (no SSL).
	Auth KafkaSaslScramAuthenticatedConnectionInfoAuth `json:"auth"`

	// Balancer Algorithm that the client uses to multiplex data between the multiple Brokers. For compatibility with the Java client, Murmur2 is used as the default partitioner
	Balancer *KafkaSaslScramAuthenticatedConnectionInfoBalancer `json:"balancer,omitempty"`

	// Brokers Kafka server endpoint. A Kafka cluster may provide several brokers; it follows the 'hostname: port' (without protocol scheme).
	Brokers []string `json:"brokers"`

	// Compression Compression standard used for the data
	Compression *KafkaSaslScramAuthenticatedConnectionInfoCompression `json:"compression,omitempty"`

	// Topic Kafka topic where you want to store the forwarded data
	Topic string `json:"topic"`

	// Username Username
	Username string `json:"username"`
	union    json.RawMessage
}

// KafkaSaslScramAuthenticatedConnectionInfoAlgorithm Hashing algorithm to use
type KafkaSaslScramAuthenticatedConnectionInfoAlgorithm string

// KafkaSaslScramAuthenticatedConnectionInfoAuth The authentication method to optionally use.  Currently supporting GSSAPI, SASL/PLAIN and SASL/SCRAM, plaintext only (no SSL).
type KafkaSaslScramAuthenticatedConnectionInfoAuth string

// KafkaSaslScramAuthenticatedConnectionInfoBalancer Algorithm that the client uses to multiplex data between the multiple Brokers. For compatibility with the Java client, Murmur2 is used as the default partitioner
type KafkaSaslScramAuthenticatedConnectionInfoBalancer string

// KafkaSaslScramAuthenticatedConnectionInfoCompression Compression standard used for the data
type KafkaSaslScramAuthenticatedConnectionInfoCompression string

// KafkaSaslScramAuthenticatedPrivateConnectionInfo defines model for KafkaSaslScramAuthenticatedPrivateConnectionInfo.
type KafkaSaslScramAuthenticatedPrivateConnectionInfo struct {
	// Algorithm Hashing algorithm to use
	Algorithm KafkaSaslScramAuthenticatedPrivateConnectionInfoAlgorithm `json:"algorithm"`

	// Auth The authentication method to optionally use.  Currently supporting GSSAPI, SASL/PLAIN and SASL/SCRAM, plaintext only (no SSL).
	Auth KafkaSaslScramAuthenticatedPrivateConnectionInfoAuth `json:"auth"`

	// Balancer Algorithm that the client uses to multiplex data between the multiple Brokers. For compatibility with the Java client, Murmur2 is used as the default partitioner
	Balancer *KafkaSaslScramAuthenticatedPrivateConnectionInfoBalancer `json:"balancer,omitempty"`

	// Brokers Kafka server endpoint. A Kafka cluster may provide several brokers; it follows the 'hostname: port' (without protocol scheme).
	Brokers []string `json:"brokers"`

	// Compression Compression standard used for the data
	Compression *KafkaSaslScramAuthenticatedPrivateConnectionInfoCompression `json:"compression,omitempty"`

	// Password Password
	Password string `json:"password"`

	// Topic Kafka topic where you want to store the forwarded data
	Topic string `json:"topic"`

	// Username Username
	Username string `json:"username"`
	union    json.RawMessage
}

// KafkaSaslScramAuthenticatedPrivateConnectionInfoAlgorithm Hashing algorithm to use
type KafkaSaslScramAuthenticatedPrivateConnectionInfoAlgorithm string

// KafkaSaslScramAuthenticatedPrivateConnectionInfoAuth The authentication method to optionally use.  Currently supporting GSSAPI, SASL/PLAIN and SASL/SCRAM, plaintext only (no SSL).
type KafkaSaslScramAuthenticatedPrivateConnectionInfoAuth string

// KafkaSaslScramAuthenticatedPrivateConnectionInfoBalancer Algorithm that the client uses to multiplex data between the multiple Brokers. For compatibility with the Java client, Murmur2 is used as the default partitioner
type KafkaSaslScramAuthenticatedPrivateConnectionInfoBalancer string

// KafkaSaslScramAuthenticatedPrivateConnectionInfoCompression Compression standard used for the data
type KafkaSaslScramAuthenticatedPrivateConnectionInfoCompression string

// KafkaSaslScramConnectionInfo defines model for KafkaSaslScramConnectionInfo.
type KafkaSaslScramConnectionInfo struct {
	// Algorithm Hashing algorithm to use
	Algorithm KafkaSaslScramConnectionInfoAlgorithm `json:"algorithm"`

	// Auth The authentication method to optionally use.  Currently supporting GSSAPI, SASL/PLAIN and SASL/SCRAM, plaintext only (no SSL).
	Auth KafkaSaslScramConnectionInfoAuth `json:"auth"`

	// Username Username
	Username string `json:"username"`
}

// KafkaSaslScramConnectionInfoAlgorithm Hashing algorithm to use
type KafkaSaslScramConnectionInfoAlgorithm string

// KafkaSaslScramConnectionInfoAuth The authentication method to optionally use.  Currently supporting GSSAPI, SASL/PLAIN and SASL/SCRAM, plaintext only (no SSL).
type KafkaSaslScramConnectionInfoAuth string

// KafkaSaslScramPrivateConnectionInfo defines model for KafkaSaslScramPrivateConnectionInfo.
type KafkaSaslScramPrivateConnectionInfo struct {
	// Password Password
	Password string `json:"password"`
}

// KafkaTlsEncrypted defines model for KafkaTlsEncrypted.
type KafkaTlsEncrypted struct {
	// IsInsecure Skip TLS certificate verification
	IsInsecure   *bool                          `json:"isInsecure,omitempty"`
	IsTlsEnabled *KafkaTlsEncryptedIsTlsEnabled `json:"isTlsEnabled,omitempty"`
}

// KafkaTlsEncryptedIsTlsEnabled defines model for KafkaTlsEncrypted.IsTlsEnabled.
type KafkaTlsEncryptedIsTlsEnabled bool

// KafkaTlsEncryptedV1 defines model for KafkaTlsEncryptedV1.
type KafkaTlsEncryptedV1 struct {
	// IsInsecure Skip TLS certificate verification
	IsInsecure   *bool                            `json:"isInsecure,omitempty"`
	IsTlsEnabled *KafkaTlsEncryptedV1IsTlsEnabled `json:"isTlsEnabled,omitempty"`
}

// KafkaTlsEncryptedV1IsTlsEnabled defines model for KafkaTlsEncryptedV1.IsTlsEnabled.
type KafkaTlsEncryptedV1IsTlsEnabled bool

// KeyValueObject defines model for KeyValueObject.
type KeyValueObject struct {
	// Key The key
	Key string `json:"key"`

	// Value The value
	Value string `json:"value"`
}

// Kubernetes defines model for Kubernetes.
type Kubernetes struct {
	// Args Arguments specific for the different types of Kubernetes audit
	// entries. In case of `pods:exec`, `args` will contain the fields
	// `command` and `container` representing the command called and
	// the name of the container in the pod where the command was
	// executed respectively.
	Args map[string]interface{} `json:"args"`

	// ContainerId The container id. `containerId` is present only if the audit event was
	// collected in a container context.
	ContainerId ContainerId `json:"containerId"`

	// Hostname The Kubernetes hostname.
	Hostname Hostname `json:"hostname"`

	// Id The audit event id.
	Id Id `json:"id"`

	// Labels Key value pairs of labels.
	Labels *map[string]string `json:"labels,omitempty"`

	// Name The name of the resource.
	Name string `json:"name"`

	// Namespace The Kubernetes namespace.
	Namespace string `json:"namespace"`

	// Resource The Kubernetes resource.
	Resource        string   `json:"resource"`
	SourceAddresses []string `json:"sourceAddresses"`

	// SubResource The Kubernetes subresource.
	SubResource string `json:"subResource"`

	// Timestamp Timestamp the audit event occured, expressed in nanoseconds.
	Timestamp Timestamp `json:"timestamp"`

	// Type The entry type
	Type KubernetesType `json:"type"`

	// User The full representation of a User
	User User `json:"user"`

	// UserAgent The user agent of the client
	UserAgent string `json:"userAgent"`
}

// KubernetesType The entry type
type KubernetesType string

// LabelMatcherV1 Matcher to match alerts to inhibition rules.
type LabelMatcherV1 struct {
	// LabelName Label to match.
	LabelName string `json:"labelName"`

	// Operator Match operator.
	Operator LabelMatcherV1Operator `json:"operator"`

	// Value Label value to match in case operator is of type equality, or regular expression in case of operator is of type regex.
	Value string `json:"value"`
}

// LabelMatcherV1Operator Match operator.
type LabelMatcherV1Operator string

// Layer defines model for Layer.
type Layer struct {
	// BaseImagesRef base images refs
	BaseImagesRef *[]string `json:"baseImagesRef,omitempty"`

	// Command layer command
	Command *string `json:"command"`

	// Digest sha256 digest of the layer
	Digest string `json:"digest"`

	// Index layer's index
	Index *int64 `json:"index,omitempty"`

	// Size size of the layer in bytes
	Size *int64 `json:"size"`
}

// ListAuditEventsResponse The list of events matching a search criteria.
type ListAuditEventsResponse struct {
	// Data The list of Audit events.
	Data []AuditEvent `json:"data"`

	// Page Pagination information.
	Page AuditPage `json:"page"`
}

// ListBundlesResponse Bundles list response
type ListBundlesResponse struct {
	// Data Bundles collection
	Data []GetBundleResponse `json:"data"`

	// Page Page details, providing both returned and total count of matched elements.
	Page PoliciesPage `json:"page"`
}

// ListEfoIntegrationsResponseV1 defines model for ListEfoIntegrationsResponseV1.
type ListEfoIntegrationsResponseV1 struct {
	Data []EfoIntegrationResponseV1 `json:"data"`
}

// ListEventsResponse The list of events matching a search criteria.
type ListEventsResponse struct {
	// Data The list of events
	Data []Event `json:"data"`

	// Page Pagination information.
	Page EventsFeedPage `json:"page"`
}

// ListIntegrationsResponse defines model for ListIntegrationsResponse.
type ListIntegrationsResponse struct {
	Data []IntegrationResponse `json:"data"`
}

// ListJobAndDisabledMetricsV1 Get Disabled Metrics by Job name Response.
type ListJobAndDisabledMetricsV1 struct {
	// JobName The name of the Job reporting the metric.
	JobName *string `json:"jobName,omitempty"`

	// Metrics List of metrics that are disabled for the Job.
	Metrics *[]MetricV1 `json:"metrics,omitempty"`
}

// ListJobs defines model for ListJobs.
type ListJobs struct {
	// Data List of Jobs.
	Data []JobResponse `json:"data"`
}

// ListMonitorEventsResponse The list of events matching a search criteria.
type ListMonitorEventsResponse struct {
	// Data The list of events
	Data []MonitorEvent `json:"data"`

	// Page Pagination information.
	Page MonitorEventsPage `json:"page"`
}

// ListPoliciesResponse defines model for ListPoliciesResponse.
type ListPoliciesResponse struct {
	// Data Policies collection
	Data []PolicySummary `json:"data"`

	// Page Page details, providing both returned and total count of matched elements.
	Page PoliciesPage `json:"page"`
}

// ListRiskAcceptedResponse defines model for ListRiskAcceptedResponse.
type ListRiskAcceptedResponse struct {
	// Data List of Accepted Risks
	Data []RiskAcceptedResponse `json:"data"`

	// Page Page information.
	Page *struct {
		Next     *string `json:"next"`
		Previous *string `json:"previous"`
		Total    *int64  `json:"total,omitempty"`
	} `json:"page,omitempty"`
}

// ListSchedules defines model for ListSchedules.
type ListSchedules struct {
	// Data List of Schedules.
	Data []ScheduleResponse `json:"data"`
}

// ListZonesResponseV1 defines model for ListZonesResponseV1.
type ListZonesResponseV1 struct {
	Data *[]ZoneResponseV1 `json:"data,omitempty"`

	// Page Page information.
	Page *struct {
		Next     *string `json:"next"`
		Previous *string `json:"previous"`
		Total    *int64  `json:"total,omitempty"`
	} `json:"page,omitempty"`
}

// MalwarePreventedAction defines model for MalwarePreventedAction.
type MalwarePreventedAction struct {
	// ErrMsg When `isSuccessful` is `false`, details on why the action failed.
	ErrMsg *string `json:"errMsg,omitempty"`

	// IsSuccessful Whether or not the action was completed successfully.
	IsSuccessful *bool `json:"isSuccessful,omitempty"`

	// Type Action type.
	Type ActionType `json:"type"`
}

// MetricErrorV1 Get Disabled Metrics by Job name Response
type MetricErrorV1 struct {
	// JobName Specifies the name of the job that caused the error.
	JobName *string `json:"jobName,omitempty"`

	// Message Describes the job and metric error.
	Message *string `json:"message,omitempty"`

	// MetricName The metric name which could not be disabled or enabled.
	MetricName *string `json:"metricName,omitempty"`
}

// MetricV1 Get Disabled Metrics by Job name Response
type MetricV1 struct {
	// MetricName Specifies the name of the disabled metric.
	MetricName *string `json:"metricName,omitempty"`

	// ModifiedDate The timestamp during which the metric was disabled
	ModifiedDate *time.Time `json:"modifiedDate,omitempty"`

	// UserId The UserId responsible for disabling the metric
	UserId *int64 `json:"userId,omitempty"`

	// UserName User name of the person who disabled the metric
	UserName *string `json:"userName,omitempty"`
}

// MonitorEvent Monitor Event
type MonitorEvent struct {
	// Type The type of the event. Current supported values are ALERT, CUSTOM. As the list of supported event types may change in the future, clients should handle unknown event types gracefully.
	Type *MonitorEventType `json:"type,omitempty"`
}

// MonitorEventType The type of the event. Current supported values are ALERT, CUSTOM. As the list of supported event types may change in the future, clients should handle unknown event types gracefully.
type MonitorEventType = string

// MonitorEventsCursor Cursor is a string used to retrieve paginated data. It acts as a pointer to a page of data. When a cursor is defined, the `from` and `to` parameters must not be used.
type MonitorEventsCursor = string

// MonitorEventsFilter Query language expression for filtering results.
// The filter is the result of logical concatenations,
// using "and" and "or" binary operators and the "not" unary prefix operator (i.e. `pid = 1 and not ppid = 2`),
// of attribute comparisons. Attribute comparisons can be:
// - scalar, using `=`, `!=`
// - scalar for string values, using `starts with`, `contains`, operators
// - vector, using `in` to check the equality among one of the values provided between parenthesis (i.e. `pid in (1, 2)`)
// Depending on the attribute, only some operators can be available.
// Values containing double-quotes `"` need escaping using backslash `\`, i.e. name = "sample \"quoted\" value".
// Supported attributes are:
// * `id` - the event id, using `=`, `!=`, `starts with`, `contains`, `in`
// * `type` - the event type, using `=`, `!=`
// * `source` - the event source, using `=`, `!=`, `starts with`, `contains`
// * `severity` - the event severity, using `=`, `!=`, `in`
// * `labels.<scope label>` - the event scope label, using `=`, `!=`, `starts with`, `contains`, `in`
type MonitorEventsFilter = string

// MonitorEventsFrom From, expressed in Unix nanoseconds timestamp. The difference between `from` and `to`
// cannot be greater than 30 days. If defined, `cursor` cannot be used.
type MonitorEventsFrom = int64

// MonitorEventsPage Pagination information.
type MonitorEventsPage struct {
	// Next `next` is a string pointing to the next page of data.
	// Use this as the `cursor` to scroll paginated results and get the next page of data.
	// If not included, the current response is the last page.
	Next *string `json:"next,omitempty"`

	// Prev `prev` is a string pointing to the previous page of data.
	// Use this as the `cursor` to get the previous page of data.
	Prev *string `json:"prev,omitempty"`

	// Total The number of events matching the search criteria. This number is always major or equal to the number of events returned.
	Total int64 `json:"total"`
}

// MonitorEventsTo To, expressed in Unix nanoseconds timestamp. The difference between `from` and `to`
// cannot be greater than 30 days. If defined, `cursor` cannot be used.
type MonitorEventsTo = int64

// NewRule A Rule definition
type NewRule struct {
	// Predicates The Predicates defining this Rule
	Predicates Predicates      `json:"predicates"`
	RuleType   NewRuleRuleType `json:"ruleType"`
}

// NewRuleRuleType defines model for NewRule.RuleType.
type NewRuleRuleType string

// NewStage defines model for NewStage.
type NewStage struct {
	// Configuration Configurations for the stage
	Configuration *[]StageConfiguration `json:"configuration,omitempty"`

	// Name stage name.
	Name NewStageName `json:"name"`
}

// NewStageName stage name.
type NewStageName string

// NotificationChannel Schema for a notification channel object
type NotificationChannel struct {
	// Id Notification channel Id
	Id *int64 `json:"id,omitempty"`

	// Type Notification channel type
	Type *string `json:"type,omitempty"`
}

// NotificationChannelResponseV1 Notification Channel Response Base Schema
type NotificationChannelResponseV1 struct {
	// CreatedOn Creation date.
	CreatedOn *time.Time `json:"createdOn,omitempty"`

	// CustomerId ID of customer that owns the notification channel.
	CustomerId *int32 `json:"customerId,omitempty"`

	// Id Unique ID of the resource.
	Id *UnlimitedLong `json:"id,omitempty"`

	// ModifiedOn Last modification date.
	ModifiedOn *time.Time `json:"modifiedOn,omitempty"`
	Type       string     `json:"type"`

	// Version The current version of the resource.
	Version *UnlimitedLong `json:"version,omitempty"`
}

// NotificationChannelTypeV1 The type of the notification channel
type NotificationChannelTypeV1 string

// OffsetPaginatedResponse defines model for OffsetPaginatedResponse.
type OffsetPaginatedResponse struct {
	// Data Paginated data.
	Data *[]interface{} `json:"data,omitempty"`

	// Page Page information.
	Page *struct {
		Next     *string `json:"next"`
		Previous *string `json:"previous"`
		Total    *int64  `json:"total,omitempty"`
	} `json:"page,omitempty"`
}

// Operand A supported operand for filtering events.
type Operand string

// Originator Type of event:
// - policy - Agent-based runtime threat detection events
// - profilingDetection - Workload ML detections
// - falcocloud - Agentless threat detections
// - admissionController - Kubernetes admission control based posture events
type Originator string

// OutputParameterName The name of the output parameter.
type OutputParameterName = string

// Package defines model for Package.
type Package struct {
	// IsRemoved whether the package has been removed
	IsRemoved *bool `json:"isRemoved,omitempty"`

	// IsRunning whether the package is used by a running process
	IsRunning *bool `json:"isRunning,omitempty"`

	// LayerRef reference to layer
	LayerRef *string `json:"layerRef,omitempty"`

	// License license of the package
	License *string `json:"license,omitempty"`

	// Name name of the package
	Name string `json:"name"`

	// Path path of the package
	Path *string `json:"path,omitempty"`

	// RiskAcceptRefs Reference to the accepted risk.
	RiskAcceptRefs *[]string `json:"riskAcceptRefs"`

	// SuggestedFix suggested fix for the package
	SuggestedFix *string `json:"suggestedFix,omitempty"`

	// Type scan result package type, example values are:
	//   - os
	//   - rust
	//   - java
	//   - ruby
	//   - javascript
	//   - python
	//   - php
	//   - golang
	//   - C#
	Type string `json:"type"`

	// Version version of the affected package
	Version string `json:"version"`

	// VulnerabilitiesRefs reference to vulnerabilities of the package
	VulnerabilitiesRefs *[]string `json:"vulnerabilitiesRefs"`
}

// PackageName defines model for PackageName.
type PackageName struct {
	// ContextType Matcher type to apply
	ContextType *PackageNameContextType `json:"contextType,omitempty"`

	// ContextValue Value to match
	ContextValue *string `json:"contextValue,omitempty"`
}

// PackageNameContextType Matcher type to apply
type PackageNameContextType string

// PackageNameVersion defines model for PackageNameVersion.
type PackageNameVersion struct {
	// ContextType Matcher type to apply
	ContextType *PackageNameVersionContextType `json:"contextType,omitempty"`

	// ContextValue Value to match
	ContextValue *string `json:"contextValue,omitempty"`
}

// PackageNameVersionContextType Matcher type to apply
type PackageNameVersionContextType string

// PackagePath defines model for PackagePath.
type PackagePath struct {
	// ContextType Matcher type to apply
	ContextType *PackagePathContextType `json:"contextType,omitempty"`

	// ContextValue Value to match
	ContextValue *string `json:"contextValue,omitempty"`
}

// PackagePathContextType Matcher type to apply
type PackagePathContextType string

// PackagePathVersion defines model for PackagePathVersion.
type PackagePathVersion struct {
	// ContextType Matcher type to apply
	ContextType *PackagePathVersionContextType `json:"contextType,omitempty"`

	// ContextValue Value to match
	ContextValue *string `json:"contextValue,omitempty"`
}

// PackagePathVersionContextType Matcher type to apply
type PackagePathVersionContextType string

// PackageVersion defines model for PackageVersion.
type PackageVersion struct {
	// ContextType Matcher type to apply
	ContextType *PackageVersionContextType `json:"contextType,omitempty"`

	// ContextValue Value to match
	ContextValue *string `json:"contextValue,omitempty"`
}

// PackageVersionContextType Matcher type to apply
type PackageVersionContextType string

// Page Pagination information.
type Page struct {
	// Next The cursor that can be used to fetch a set of events after the last
	// event returned in the `data` array.
	// If this value is unset, then there are no events after the last
	// event returned  in the `data` array.
	// By providing this value as `cursor`
	// you will get the events following last event returned in the
	// `data` array.
	Next *string `json:"next,omitempty"`

	// Prev The cursor that can be used to fetch a set of events before the
	// first event returned in the `data` array.
	// If this value is unset, then there are no events before the first
	// event returned in the `data` array.
	// By providing this value as `cursor`
	// you will get the events preceding the first event returned
	// in the `data` array.
	Prev *string `json:"prev,omitempty"`

	// Total The number of events matching the search criteria. This number is always major or equal to the number of events returned.
	Total int64 `json:"total"`
}

// PaginatedIntegrationsResponseV1 defines model for PaginatedIntegrationsResponseV1.
type PaginatedIntegrationsResponseV1 struct {
	Data *[]IntegrationResponseV1 `json:"data,omitempty"`

	// Page Page information.
	Page *struct {
		Next     *string `json:"next"`
		Previous *string `json:"previous"`
		Total    *int64  `json:"total,omitempty"`
	} `json:"page,omitempty"`
}

// ParameterType The type of an Response Action parameter.\
// It may assume the following values:\
// * string\
// * integer\
// * boolean\
// This list of possible values may grow in the future.
type ParameterType = string

// PermissionV1 Permission to perform an action on the Sysdig platform.
type PermissionV1 struct {
	// Dependencies List of permissions that this permission depends on.
	Dependencies *[]string `json:"dependencies,omitempty"`

	// Description Permission description.
	Description *string `json:"description,omitempty"`

	// Id Permission Authority.
	Id *string `json:"id,omitempty"`

	// Products Specifies the Sysdig product the permission applies to (Secure = SDS; Monitor = SDC).
	Products *[]string `json:"products,omitempty"`
}

// PipelineResult pipeline result
type PipelineResult struct {
	// CreatedAt datetime of creation
	CreatedAt *CreatedAt `json:"createdAt,omitempty"`

	// ImageId Identifier of the image (hash).
	ImageId *string `json:"imageId,omitempty"`

	// PolicyEvaluationResult Policy evaluation result
	PolicyEvaluationResult *PolicyEvaluationResult `json:"policyEvaluationResult,omitempty"`

	// PullString image pull string
	PullString *string `json:"pullString,omitempty"`

	// ResultId Identifier of the scan result
	ResultId *string `json:"resultId,omitempty"`

	// VulnTotalBySeverity total vulnerabilities by severity
	VulnTotalBySeverity *VulnTotalBySeverity `json:"vulnTotalBySeverity,omitempty"`
}

// PipelineResultsResponse pipeline results
type PipelineResultsResponse struct {
	Data *[]PipelineResult `json:"data,omitempty"`

	// Page API paging response
	Page *VulnerabilityManagementPage `json:"page,omitempty"`
}

// PkgVulnFailure defines model for PkgVulnFailure.
type PkgVulnFailure struct {
	// Description description of the failure
	Description string `json:"description"`

	// PackageRef reference to the affected package
	PackageRef *string `json:"packageRef,omitempty"`

	// RiskAcceptRefs list of accepted risks for the failure
	RiskAcceptRefs *[]string `json:"riskAcceptRefs,omitempty"`

	// VulnerabilityRef reference to the vulnerability
	VulnerabilityRef *string `json:"vulnerabilityRef,omitempty"`
}

// Policies defines model for Policies.
type Policies struct {
	Evaluations      *[]PolicyEvaluation       `json:"evaluations,omitempty"`
	GlobalEvaluation *PoliciesGlobalEvaluation `json:"globalEvaluation,omitempty"`
}

// PoliciesGlobalEvaluation defines model for Policies.GlobalEvaluation.
type PoliciesGlobalEvaluation string

// PoliciesPage Page details, providing both returned and total count of matched elements.
type PoliciesPage struct {
	// Matched Total count of elements matched the provided filter.
	Matched int64 `json:"matched"`

	// Next Cursor used to retrieve the next page of results.
	Next *string `json:"next"`

	// Returned The number returned elements: always less or equal the limit specified in the request.
	Returned int32 `json:"returned"`
}

// PoliciesSummaryEntry A Policy summary that indicates whether a policy failed or passed.
type PoliciesSummaryEntry struct {
	// Id Policy Id
	Id int64 `json:"id"`

	// IsPassed True for passed, false for failed
	IsPassed bool `json:"isPassed"`

	// Name Policy Name
	Name string `json:"name"`
}

// PolicyEvaluation defines model for PolicyEvaluation.
type PolicyEvaluation struct {
	Bundles *[]Bundle `json:"bundles,omitempty"`

	// CreatedAt datetime of creation
	CreatedAt CreatedAt `json:"createdAt"`

	// Description policy evaluation description
	Description *string                    `json:"description,omitempty"`
	Evaluation  PolicyEvaluationEvaluation `json:"evaluation"`

	// Identifier policy evaluation id
	Identifier string `json:"identifier"`

	// Name policy evaluation name
	Name string `json:"name"`

	// UpdatedAt datetime of last update
	UpdatedAt UpdatedAt `json:"updatedAt"`
}

// PolicyEvaluationEvaluation defines model for PolicyEvaluation.Evaluation.
type PolicyEvaluationEvaluation string

// PolicyEvaluationResult Policy evaluation result
type PolicyEvaluationResult string

// PolicyId ID of the policy that generated the event
type PolicyId = int64

// PolicyNotificationChannelIds The list of notification channels where an alert is sent after event is generated.
// Doesn't account for aggregations and eventual thresholds.
type PolicyNotificationChannelIds = []int64

// PolicyOrigin The policy author:
// - `Sysdig` - default and managed policies
// - `Sysdig UI` - users interacting with Sysdig
// - `Tuner` - the automated tuner
type PolicyOrigin string

// PolicySummary Policy summary definition.
type PolicySummary struct {
	// Description policy description
	Description *string `json:"description,omitempty"`

	// Id The Policy ID
	Id int64 `json:"id"`

	// Identifier policy identifier generated from the name.
	Identifier string `json:"identifier"`

	// Name human readable policy name.
	Name string `json:"name"`

	// Stages array of stages for the policy.
	// An empty array means the policy is applied only when specifically requested by its identifier.
	// It may be one of the following:
	//   - runtime
	//   - pipeline
	//   - registry
	Stages []string `json:"stages"`
}

// PosturePolicySummary The posture policy summary
type PosturePolicySummary struct {
	// PassPercentage Percentage of policies passing
	PassPercentage int32 `json:"passPercentage"`

	// Policies The policies list
	Policies []PoliciesSummaryEntry `json:"policies"`
}

// Predicate defines model for Predicate.
type Predicate struct {
	Extra *map[string]interface{} `json:"extra"`

	// Type predicate type
	Type *string `json:"type,omitempty"`
}

// Predicates The Predicates defining this Rule
type Predicates = []Predicates_Item

// Predicates_Item defines model for Predicates.Item.
type Predicates_Item struct {
	union json.RawMessage
}

// PricingProjectedResponseV1 The monthly projected cost for a specific cluster.
type PricingProjectedResponseV1 struct {
	// ClusterName The name of the cluster.
	ClusterName *string `json:"clusterName,omitempty"`

	// MonthlyProjectedCost Monthly projected cost.
	MonthlyProjectedCost *float32 `json:"monthlyProjectedCost,omitempty"`
}

// PricingResponseV1 The pricing configuration used to compute costs.
type PricingResponseV1 struct {
	// ClusterName The name of the cluster. Required when `type` is `CLUSTER`.
	ClusterName *string `json:"clusterName"`

	Id *UnlimitedLong `json:"id,omitempty"`

	// Name The name of the pricing profile.
	Name *string `json:"name,omitempty"`

	// SpotLabel The name of a node label that is used to identify the node as a spot node.
	SpotLabel *string `json:"spotLabel"`

	// SpotLabelValue The value of the spot node label.
	SpotLabelValue *string `json:"spotLabelValue"`

	// Type The type of the pricing.
	Type *PricingType `json:"type,omitempty"`

	// UnitPricing The unit pricing configuration used to compute costs.
	UnitPricing *UnitPricingV1 `json:"unitPricing,omitempty"`

	// Version The current version of the resource.
	Version *UnlimitedLong `json:"version,omitempty"`
}

// PricingType The type of the pricing.
type PricingType string

// PrivateConnectionInfoAmazonSqs defines model for PrivateConnectionInfoAmazonSqs.
type PrivateConnectionInfoAmazonSqs struct {
	// AccessKey Access Key for authenticating on AWS to send data on the queue
	AccessKey *string `json:"accessKey,omitempty"`

	// AccessSecret Access Secret for authenticating on AWS to send data on the queue
	AccessSecret *string `json:"accessSecret,omitempty"`
}

// PrivateConnectionInfoChronicle defines model for PrivateConnectionInfoChronicle.
type PrivateConnectionInfoChronicle struct {
	// ApiKey The Chronicle v2 API key
	ApiKey *string `json:"apiKey,omitempty"`
}

// PrivateConnectionInfoChronicleV2 defines model for PrivateConnectionInfoChronicleV2.
type PrivateConnectionInfoChronicleV2 struct {
	// CredentialsOAuth2 The Chronicle v2 OAuth2 credentials
	CredentialsOAuth2 *string `json:"credentialsOAuth2,omitempty"`
}

// PrivateConnectionInfoElasticsearch defines model for PrivateConnectionInfoElasticsearch.
type PrivateConnectionInfoElasticsearch struct {
	// Auth Authentication method
	Auth *PrivateConnectionInfoElasticsearchAuth `json:"auth,omitempty"`

	// Secret Authentication secret. To be set if auth is specified
	Secret *string `json:"secret,omitempty"`
}

// PrivateConnectionInfoElasticsearchAuth Authentication method
type PrivateConnectionInfoElasticsearchAuth string

// PrivateConnectionInfoGooglePubSub defines model for PrivateConnectionInfoGooglePubSub.
type PrivateConnectionInfoGooglePubSub struct {
	// CredentialsJson JSON credentials for the service account Sysdig will use to send data
	CredentialsJson *string `json:"credentialsJson,omitempty"`
}

// PrivateConnectionInfoGoogleScc defines model for PrivateConnectionInfoGoogleScc.
type PrivateConnectionInfoGoogleScc struct {
	// CredentialsJson JSON credentials for the service account Sysdig will use to send data
	CredentialsJson *string `json:"credentialsJson,omitempty"`
}

// PrivateConnectionInfoKafkaV1 defines model for PrivateConnectionInfoKafkaV1.
type PrivateConnectionInfoKafkaV1 struct {
	// Keytab base64 encoded Kerberos keytab
	Keytab *string `json:"keytab,omitempty"`
}

// PrivateConnectionInfoMcm defines model for PrivateConnectionInfoMcm.
type PrivateConnectionInfoMcm struct {
	// ApiKey IBM Cloud API Key
	ApiKey *string `json:"apiKey,omitempty"`
}

// PrivateConnectionInfoMicrosoftSentinel defines model for PrivateConnectionInfoMicrosoftSentinel.
type PrivateConnectionInfoMicrosoftSentinel struct {
	// Secret Log analytics primary key
	Secret *string `json:"secret,omitempty"`
}

// PrivateConnectionInfoSplunk defines model for PrivateConnectionInfoSplunk.
type PrivateConnectionInfoSplunk struct {
	// Token HTTP Event Collector Token
	Token *string `json:"token,omitempty"`
}

// PrivateConnectionInfoWebhook defines model for PrivateConnectionInfoWebhook.
type PrivateConnectionInfoWebhook struct {
	// Secret Secret to use, according to the "auth" value.
	Secret *string `json:"secret,omitempty"`
}

// ProcessKilledAction defines model for ProcessKilledAction.
type ProcessKilledAction struct {
	// ErrMsg When `isSuccessful` is `false`, details on why the action failed.
	ErrMsg *string `json:"errMsg,omitempty"`

	// IsSuccessful Whether or not the action was completed successfully.
	IsSuccessful *bool `json:"isSuccessful,omitempty"`

	// Type Action type.
	Type ActionType `json:"type"`
}

// Producer defines model for Producer.
type Producer struct {
	// ProducedAt time of result production
	ProducedAt *time.Time `json:"producedAt,omitempty"`
}

// Product The Sysdig product
type Product string

// PrometheusLabel A valid Prometheus label name. Must match ^[a-zA-Z_][a-zA-Z0-9_]*$
type PrometheusLabel = string

// PromqlMatcher A PromQL-style filter that narrows the dataset to resources
// matching specific labels. If not provided, no additional filtering
// is applied.
type PromqlMatcher struct {
	// Label A valid Prometheus label name. Must match ^[a-zA-Z_][a-zA-Z0-9_]*$
	Label PrometheusLabel `json:"label"`

	// Operator The operator to use in the filter:
	//   - `EQUAL` (`=`): Exact match
	//   - `NOT_EQUAL` (`!=`): Exclude exact match
	//   - `REGEX_MATCH` (`=~`): Regular expression match
	//   - `REGEX_NOT_MATCH` (`!~`): Regular expression mismatch
	Operator PromqlMatcherOperator `json:"operator"`

	// Value The value to match against.
	Value string `json:"value"`
}

// PromqlMatcherOperator The operator to use in the filter:
//   - `EQUAL` (`=`): Exact match
//   - `NOT_EQUAL` (`!=`): Exclude exact match
//   - `REGEX_MATCH` (`=~`): Regular expression match
//   - `REGEX_NOT_MATCH` (`!~`): Regular expression mismatch
type PromqlMatcherOperator string

// QueryResponse Response object containing query results and metadata.
type QueryResponse struct {
	// Entities Metadata about the returned fields.
	Entities QueryResponse_Entities `json:"entities"`

	// Id Unique identifier for the query execution.
	Id openapi_types.UUID `json:"id"`

	// Items Array of query results based on the query fields.
	Items []map[string]interface{} `json:"items"`

	// Summary Summary of query execution metrics and timing information.
	Summary QuerySummary `json:"summary"`
}

// QueryResponse_Entities Metadata about the returned fields.
type QueryResponse_Entities struct {
	// Fields Defines the structure and metadata of a field in the query result.
	Fields               *EntityDefinition      `json:"fields,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// QuerySummary Summary of query execution metrics and timing information.
type QuerySummary struct {
	// AvailableAfter Time taken for results to become available in milliseconds.
	AvailableAfter int64 `json:"available_after"`

	// ConsumedAfter Time taken to consume results in milliseconds.
	ConsumedAfter int64 `json:"consumed_after"`

	// TotalTime Total query execution time in milliseconds.
	TotalTime int64 `json:"total_time"`
}

// RawEventCategory The semantic category (area) of the event in the Sysdig product:
// - `kspm` -  Kubernetes Security Posture Management events
// - `runtime` - Threat detection events
type RawEventCategory = string

// RawEventOriginator The agent type, hosting the `engine`, that generated the event after the raw event
// - `admissionController` - Admission Controller, part of the Cluster Shield
// - `agentless` - Agentless
// - `cloudConnector` - Cloud Connector
// - `linuxAgent` - Linux Host Agent
// - `serverlessAgent` - Serverless workloads Agent (CaaS) generated events
// - `windowsAgent` - Windows Host Agent
type RawEventOriginator = string

// RegistryResult Registry result
type RegistryResult struct {
	// CreatedAt datetime of creation
	CreatedAt *CreatedAt `json:"createdAt,omitempty"`

	// ImageId Identifier of the image (hash).
	ImageId *string `json:"imageId,omitempty"`

	// PullString Name of the scanned asset
	PullString *string `json:"pullString,omitempty"`

	// ResultId Identifier of the scan result
	ResultId *string `json:"resultId,omitempty"`

	// Vendor Identifier the vendor of the image
	Vendor *string `json:"vendor,omitempty"`

	// VulnTotalBySeverity total vulnerabilities by severity
	VulnTotalBySeverity *VulnTotalBySeverity `json:"vulnTotalBySeverity,omitempty"`
}

// RegistryResultsResponse registry results response
type RegistryResultsResponse struct {
	Data *[]RegistryResult `json:"data,omitempty"`

	// Page API paging response
	Page *VulnerabilityManagementPage `json:"page,omitempty"`
}

// RequestBodyDisabledMetricsV1 Change Disabled Metrics per JobName
type RequestBodyDisabledMetricsV1 struct {
	Data []DisableJobsAndMetricsV1 `json:"data"`
}

// ResponderType The type of Responder executing an action.
type ResponderType string

// ResponseAction The action metadata
type ResponseAction struct {
	// Description The description of the action.
	Description string `json:"description"`

	// IsUndoable Whether the action is undoable.
	IsUndoable bool                     `json:"isUndoable"`
	Outputs    *[]ActionOutputsMetadata `json:"outputs,omitempty"`

	// Parameters the list of parameters that the action supports
	Parameters []ActionParameterMetadata `json:"parameters"`

	// ResponderType The type of Responder executing an action.
	ResponderType ResponderType `json:"responderType"`

	// Type The name of the Response Action to execute.
	// It may be one of the following:
	// - KILL_PROCESS
	// - KILL_CONTAINER
	// - STOP_CONTAINER
	// - PAUSE_CONTAINER
	// - FILE_QUARANTINE
	// - FILE_ACQUIRE
	// - UNPAUSE_CONTAINER
	// - FILE_UNQUARANTINE
	// - START_CONTAINER
	// - DELETE_POD
	// - ROLLOUT_RESTART
	// - KUBERNETES_VOLUME_SNAPSHOT
	// - KUBERNETES_DELETE_VOLUME_SNAPSHOT
	// - GET_LOGS
	// - ISOLATE_NETWORK
	// - DELETE_NETWORK_POLICY
	//
	// The following actions serve as the undo for previous actions:
	// - START_CONTAINER: undo for STOP_CONTAINER\
	// - UNPAUSE_CONTAINER: undo for PAUSE_CONTAINER\
	// - FILE_UNQUARANTINE: undo for FILE_QUARANTINE\
	// - KUBERNETES_DELETE_VOLUME_SNAPSHOT: undo for KUBERNETES_VOLUME_SNAPSHOT\
	// - DELETE_NETWORK_POLICY: undo for ISOLATE_NETWORK\
	//
	// Do not use undo actions in [submitActionExecutionv1](#tag/Response-actions/operation/submitActionExecutionv1).
	//
	// You can execute an undo actions using the service [undoActionExecutionV1](#tag/Response-actions/operation/undoActionExecutionV1).
	Type ResponseActionType `json:"type"`
}

// ResponseActionType The name of the Response Action to execute.
// It may be one of the following:
// - KILL_PROCESS
// - KILL_CONTAINER
// - STOP_CONTAINER
// - PAUSE_CONTAINER
// - FILE_QUARANTINE
// - FILE_ACQUIRE
// - UNPAUSE_CONTAINER
// - FILE_UNQUARANTINE
// - START_CONTAINER
// - DELETE_POD
// - ROLLOUT_RESTART
// - KUBERNETES_VOLUME_SNAPSHOT
// - KUBERNETES_DELETE_VOLUME_SNAPSHOT
// - GET_LOGS
// - ISOLATE_NETWORK
// - DELETE_NETWORK_POLICY
//
// The following actions serve as the undo for previous actions:
// - START_CONTAINER: undo for STOP_CONTAINER\
// - UNPAUSE_CONTAINER: undo for PAUSE_CONTAINER\
// - FILE_UNQUARANTINE: undo for FILE_QUARANTINE\
// - KUBERNETES_DELETE_VOLUME_SNAPSHOT: undo for KUBERNETES_VOLUME_SNAPSHOT\
// - DELETE_NETWORK_POLICY: undo for ISOLATE_NETWORK\
//
// Do not use undo actions in [submitActionExecutionv1](#tag/Response-actions/operation/submitActionExecutionv1).
//
// You can execute an undo actions using the service [undoActionExecutionV1](#tag/Response-actions/operation/undoActionExecutionV1).
type ResponseActionType = string

// ResponseListDisabledMetricsAndErrorV1 Get Disabled Metrics by Job name Response
type ResponseListDisabledMetricsAndErrorV1 struct {
	Data   []ListJobAndDisabledMetricsV1 `json:"data"`
	Errors []MetricErrorV1               `json:"errors"`
}

// ResponseListDisabledMetricsV1 Get Disabled Metrics by Job name Response
type ResponseListDisabledMetricsV1 struct {
	Data   []ListJobAndDisabledMetricsV1 `json:"data"`
	Errors *[]MetricErrorV1              `json:"errors,omitempty"`
}

// RiskAcceptanceDefinition defines model for RiskAcceptanceDefinition.
type RiskAcceptanceDefinition struct {
	Context []Context `json:"context"`

	// CreatedAt datetime of creation
	CreatedAt CreatedAt `json:"createdAt"`

	// Description risk acceptance description
	Description *string `json:"description,omitempty"`

	// EntityType entity type for the risk
	EntityType string `json:"entityType"`

	// EntityValue entity value relative to the the entity type
	EntityValue    string              `json:"entityValue"`
	ExpirationDate *openapi_types.Date `json:"expirationDate"`

	// Id id of the risk acceptance
	Id string `json:"id"`

	// Reason risk acceptance reason
	Reason *string                        `json:"reason,omitempty"`
	Status RiskAcceptanceDefinitionStatus `json:"status"`

	// UpdatedAt datetime of last update
	UpdatedAt UpdatedAt `json:"updatedAt"`
}

// RiskAcceptanceDefinitionStatus defines model for RiskAcceptanceDefinition.Status.
type RiskAcceptanceDefinitionStatus string

// RiskAcceptedResponse defines model for RiskAcceptedResponse.
type RiskAcceptedResponse struct {
	// Context If entityType is not `vulnerability`, `policyRule` or `package`, you should use `Empty Matcher` in the context.
	Context RiskAcceptedResponse_Context `json:"context"`

	// CreatedAt Date when the Accepted Risk was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// CreatedBy User who created the risk acceptance
	CreatedBy *string `json:"createdBy,omitempty"`

	// Description Description of why the accepted risk was created
	Description string `json:"description"`

	// EntityType The entity where the Accepted Risk will be applied.
	EntityType RiskAcceptedResponseEntityType `json:"entityType"`

	// EntityValue A value to match with the entityType
	EntityValue string `json:"entityValue"`

	// ExpirationDate Date when the accepted risk will expire (in YYYY-MM-DD format)
	ExpirationDate *openapi_types.Date `json:"expirationDate,omitempty"`

	// Id The Accepted Risk ID
	Id string `json:"id"`

	// Reason Reason for acceptance
	Reason RiskAcceptedResponseReason `json:"reason"`

	// Stages List of stages where the risk acceptance is applied, empty list enables risk acceptance for all the stages
	Stages *[]RiskAcceptedResponseStages `json:"stages"`

	// Status Specifies whether the Accepted Risk is enabled or expired
	Status RiskAcceptedResponseStatus `json:"status"`

	// UpdatedAt Date when the Accepted Risk was updated
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// UpdatedBy User who last updated the risk acceptance
	UpdatedBy *string `json:"updatedBy,omitempty"`
}

// RiskAcceptedResponse_Context If entityType is not `vulnerability`, `policyRule` or `package`, you should use `Empty Matcher` in the context.
type RiskAcceptedResponse_Context struct {
	union json.RawMessage
}

// RiskAcceptedResponseEntityType The entity where the Accepted Risk will be applied.
type RiskAcceptedResponseEntityType string

// RiskAcceptedResponseReason Reason for acceptance
type RiskAcceptedResponseReason string

// RiskAcceptedResponseStages defines model for RiskAcceptedResponse.Stages.
type RiskAcceptedResponseStages string

// RiskAcceptedResponseStatus Specifies whether the Accepted Risk is enabled or expired
type RiskAcceptedResponseStatus string

// RoleRequestV1 Create or update role request
type RoleRequestV1 struct {
	// Description Describes the role
	Description *string `json:"description,omitempty"`

	// MonitorPermissions Set of Monitor permissions assigned to the role.
	// Check the `permissions` endpoint to list the available values.
	MonitorPermissions *[]string `json:"monitorPermissions,omitempty"`

	// Name The display name of the role
	Name string `json:"name"`

	// SecurePermissions Set of Secure permissions assigned to the role.
	// Check the `permissions` endpoint to list the available values.
	SecurePermissions *[]string `json:"securePermissions,omitempty"`
}

// RoleResponseV1 Create role response
type RoleResponseV1 struct {
	// Description Describes the role
	Description *string `json:"description,omitempty"`

	Id *UnlimitedLong `json:"id,omitempty"`

	// MonitorPermissions Set of Monitor permissions assigned to the role.
	// Check the `permissions` endpoint to list the available values.
	MonitorPermissions *[]string `json:"monitorPermissions,omitempty"`

	// Name The display name of the role
	Name *string `json:"name,omitempty"`

	// SecurePermissions Set of Secure permissions assigned to the role.
	// Check the `permissions` endpoint to list the available values.
	SecurePermissions *[]string `json:"securePermissions,omitempty"`
}

// Rule defines model for Rule.
type Rule struct {
	// Description rule description
	Description string `json:"description"`

	// EvaluationResult result of rule evaluation
	EvaluationResult *RuleEvaluationResult `json:"evaluationResult,omitempty"`

	// FailureType rule failure type
	FailureType RuleFailureType `json:"failureType"`

	// Failures list of rule failures
	Failures *[]Rule_Failures_Item `json:"failures,omitempty"`

	// Predicates list of rule's predicates
	Predicates *[]Predicate `json:"predicates"`

	// RuleId rule's id
	RuleId *string `json:"ruleId,omitempty"`

	// RuleType rule type
	RuleType string `json:"ruleType"`
}

// RuleEvaluationResult result of rule evaluation
type RuleEvaluationResult string

// RuleFailureType rule failure type
type RuleFailureType string

// Rule_Failures_Item defines model for Rule.failures.Item.
type Rule_Failures_Item struct {
	union json.RawMessage
}

// RuleName Name of the rule the event is generated after
type RuleName = string

// RuleSubType Rule subtype:
// - 1 - List matching - network - inbound
// - 2 - List matching - network - outbound
// - 3 - List matching - network - listening
// - 4 - List matching - file - readwrite
// - 5 - List matching - file - read only
type RuleSubType = int32

// RuleTags The tags attached to the rule
type RuleTags = []string

// RuleType Rule type:
// - 1 - List matching - process
// - 2 - List matching - container
// - 3 - List matching - file
// - 4 - List matching - network
// - 5 - List matching - syscall
// - 6 - Falco
// - 7 - Drift detection
// - 8 - Malware detection
// - 11 - ML - Cryptominer detection
// - 13 - ML - AWS anomalous login
// - 14 - ML - Okta anomalous login
type RuleType = int32

// RuntimeResult Runtime result
type RuntimeResult struct {
	// IsRiskSpotlightEnabled Whether risk spotlight is enabled or not
	IsRiskSpotlightEnabled *bool `json:"isRiskSpotlightEnabled,omitempty"`

	// MainAssetName Name of the scanned asset
	MainAssetName *string `json:"mainAssetName,omitempty"`

	// PolicyEvaluationResult Policy evaluation result
	PolicyEvaluationResult *PolicyEvaluationResult `json:"policyEvaluationResult,omitempty"`

	// ResourceId Identifier of the scanned resource: it will be the image ID for container images or the host ID for hosts.
	ResourceId *string `json:"resourceId,omitempty"`

	// ResultId Identifier of the scan result
	ResultId *string `json:"resultId,omitempty"`

	// RunningVulnTotalBySeverity total vulnerabilities by severity
	RunningVulnTotalBySeverity *VulnTotalBySeverity `json:"runningVulnTotalBySeverity,omitempty"`

	// SbomId Identifier of the sbom
	SbomId *string `json:"sbomId"`

	// Scope Scope labels that define the asset
	Scope *Scope `json:"scope,omitempty"`

	// VulnTotalBySeverity total vulnerabilities by severity
	VulnTotalBySeverity *VulnTotalBySeverity `json:"vulnTotalBySeverity,omitempty"`
}

// RuntimeResultsResponse runtime results response
type RuntimeResultsResponse struct {
	Data *[]RuntimeResult `json:"data,omitempty"`

	// Page API paging response
	Page *VulnerabilityManagementPage `json:"page,omitempty"`
}

// SaveCaptureStorageConfigurationRequestV1 defines model for SaveCaptureStorageConfigurationRequestV1.
type SaveCaptureStorageConfigurationRequestV1 struct {
	// Buckets The list of buckets where the captures are stored. Currently only one bucket is supported.
	Buckets *[]BucketConfigurationV1 `json:"buckets,omitempty"`

	// EncryptionKey AES-256 encryption key to be used for server-side encryption (base64 encoded).
	EncryptionKey *string `json:"encryptionKey,omitempty"`

	// IsEnabled Specifies if capture storage is enabled.
	IsEnabled bool `json:"isEnabled"`

	// IsEncryptionWithProvidedKeyEnabled Specifies if server-side encryption with provided encryption key (SSE-C) is enabled.
	IsEncryptionWithProvidedKeyEnabled *bool `json:"isEncryptionWithProvidedKeyEnabled,omitempty"`
}

// SaveTeamUserRequestV1 defines model for SaveTeamUserRequestV1.
type SaveTeamUserRequestV1 struct {
	// CustomTeamRoleId The custom team role ID assigned for the user in this team. **Mutually exclusive with standardTeamRole**.
	CustomTeamRoleId *UnlimitedLong `json:"customTeamRoleId,omitempty"`

	// StandardTeamRole The standard team role assigned for the user in this team. **Mutually exclusive with customTeamRoleId**.\
	// \
	// *ROLE_TEAM_SERVICE_MANAGER is only supported in Secure.*
	StandardTeamRole *TeamRoleV1 `json:"standardTeamRole,omitempty"`
}

// SbomComponent defines model for SbomComponent.
type SbomComponent struct {
	// BomRef An optional identifier which can be used to reference the component elsewhere in the BOM. Every bom-ref MUST be unique within the BOM.
	BomRef *string `json:"bom-ref,omitempty"`

	// Group The grouping name or identifier. This will often be a shortened, single name of the company or project that produced the component, or the source package or domain name. Whitespace and special characters should be avoided. Examples include: apache, org.apache.commons, and apache.org.
	Group *string `json:"group,omitempty"`

	// Name The name of the component. This will often be a shortened, single name of the component. Examples: commons-lang3 and jquery
	Name string `json:"name"`

	// Purl Specifies the package-url (purl). The purl, if specified, MUST be valid and conform to the specification defined at: [https://github.com/package-url/purl-spec](https://github.com/package-url/purl-spec)
	Purl *string `json:"purl,omitempty"`

	// Type Specifies the type of component. For software components, classify as application if no more specific appropriate classification is available or cannot be determined for the component. Types include:
	//
	// * __application__ = A software application. Refer to [https://en.wikipedia.org/wiki/Application_software](https://en.wikipedia.org/wiki/Application_software) for information about applications.
	// * __framework__ = A software framework. Refer to [https://en.wikipedia.org/wiki/Software_framework](https://en.wikipedia.org/wiki/Software_framework) for information on how frameworks vary slightly from libraries.
	// * __library__ = A software library. Refer to [https://en.wikipedia.org/wiki/Library_(computing)](https://en.wikipedia.org/wiki/Library_(computing))
	//  for information about libraries. All third-party and open source reusable components will likely be a library. If the library also has key features of a framework, then it should be classified as a framework. If not, or is unknown, then specifying library is RECOMMENDED.
	// * __container__ = A packaging and/or runtime format, not specific to any particular technology, which isolates software inside the container from software outside of a container through virtualization technology. Refer to [https://en.wikipedia.org/wiki/OS-level_virtualization](https://en.wikipedia.org/wiki/OS-level_virtualization)
	// * __platform__ = A runtime environment which interprets or executes software. This may include runtimes such as those that execute bytecode or low-code/no-code application platforms.
	// * __operating-system__ = A software operating system without regard to deployment model (i.e. installed on physical hardware, virtual machine, image, etc) Refer to [https://en.wikipedia.org/wiki/Operating_system](https://en.wikipedia.org/wiki/Operating_system)
	// * __device__ = A hardware device such as a processor, or chip-set. A hardware device containing firmware SHOULD include a component for the physical hardware itself, and another component of type 'firmware' or 'operating-system' (whichever is relevant), describing information about the software running on the device.
	//   See also the list of [known device properties](https://github.com/CycloneDX/cyclonedx-property-taxonomy/blob/main/cdx/device.md).
	// * __device-driver__ = A special type of software that operates or controls a particular type of device. Refer to [https://en.wikipedia.org/wiki/Device_driver](https://en.wikipedia.org/wiki/Device_driver)
	// * __firmware__ = A special type of software that provides low-level control over a devices hardware. Refer to [https://en.wikipedia.org/wiki/Firmware](https://en.wikipedia.org/wiki/Firmware)
	// * __file__ = A computer file. Refer to [https://en.wikipedia.org/wiki/Computer_file](https://en.wikipedia.org/wiki/Computer_file) for information about files.
	// * __machine-learning-model__ = A model based on training data that can make predictions or decisions without being explicitly programmed to do so.
	// * __data__ = A collection of discrete values that convey information.
	Type string `json:"type"`

	// Version The component version. The version should ideally comply with semantic versioning but is not enforced.
	Version *string `json:"version,omitempty"`
}

// SbomResultResponse SBOM of the requested asset
type SbomResultResponse struct {
	// BomFormat Specifies the format of the BOM. This helps to identify the file as CycloneDX since BOMs do not have a filename convention nor does JSON schema support namespaces. This value MUST be "CycloneDX".
	BomFormat SbomResultResponseBomFormat `json:"bomFormat"`

	// Components A list of software and hardware components.
	Components *[]SbomComponent `json:"components,omitempty"`

	// Compositions Compositions describe constituent parts (including components, services, and dependency relationships) and their completeness. The completeness of vulnerabilities expressed in a BOM may also be described.
	Compositions *[]struct {
		// Aggregate Specifies an aggregate type that describe how complete a relationship is.
		//
		// * __complete__ = The relationship is complete. No further relationships including constituent components, services, or dependencies are known to exist.
		// * __incomplete__ = The relationship is incomplete. Additional relationships exist and may include constituent components, services, or dependencies.
		// * __incomplete&#95;first&#95;party&#95;only__ = The relationship is incomplete. Only relationships for first-party components, services, or their dependencies are represented.
		// * __incomplete&#95;first&#95;party&#95;proprietary&#95;only__ = The relationship is incomplete. Only relationships for first-party components, services, or their dependencies are represented, limited specifically to those that are proprietary.
		// * __incomplete&#95;first&#95;party&#95;opensource&#95;only__ = The relationship is incomplete. Only relationships for first-party components, services, or their dependencies are represented, limited specifically to those that are opensource.
		// * __incomplete&#95;third&#95;party&#95;only__ = The relationship is incomplete. Only relationships for third-party components, services, or their dependencies are represented.
		// * __incomplete&#95;third&#95;party&#95;proprietary&#95;only__ = The relationship is incomplete. Only relationships for third-party components, services, or their dependencies are represented, limited specifically to those that are proprietary.
		// * __incomplete&#95;third&#95;party&#95;opensource&#95;only__ = The relationship is incomplete. Only relationships for third-party components, services, or their dependencies are represented, limited specifically to those that are opensource.
		// * __unknown__ = The relationship may be complete or incomplete. This usually signifies a 'best-effort' to obtain constituent components, services, or dependencies but the completeness is inconclusive.
		// * __not&#95;specified__ = The relationship completeness is not specified.
		Aggregate SbomResultResponseCompositionsAggregate `json:"aggregate"`

		// Assemblies The bom-ref identifiers of the components or services being described. Assemblies refer to nested relationships whereby a constituent part may include other constituent parts. References do not cascade to child parts. References are explicit for the specified constituent part only.
		Assemblies *[]string `json:"assemblies,omitempty"`

		// Dependencies The bom-ref identifiers of the components or services being described. Assemblies refer to nested relationships whereby a constituent part may include other constituent parts. References do not cascade to child parts. References are explicit for the specified constituent part only.
		Dependencies *[]string `json:"dependencies,omitempty"`
	} `json:"compositions,omitempty"`

	// Dependencies Provides the ability to document dependency relationships.
	Dependencies *[]struct {
		// DependsOn The bom-ref identifiers of the components or services that are dependencies of this dependency object.
		DependsOn *[]string `json:"dependsOn,omitempty"`

		// Ref References a component or service by its bom-ref attribute
		Ref string `json:"ref"`
	} `json:"dependencies,omitempty"`

	// Metadata Provides additional information about a BOM.
	Metadata *struct {
		Component *SbomComponent `json:"component,omitempty"`

		// Lifecycle The product lifecycle(s) that this BOM represents.
		Lifecycle *SbomResultResponseMetadataLifecycle `json:"lifecycle,omitempty"`

		// Timestamp The date and time (timestamp) when the BOM was created.
		Timestamp *time.Time `json:"timestamp,omitempty"`

		// Tools The tool(s) used in the creation of the BOM.
		Tools *map[string]interface{} `json:"tools,omitempty"`
	} `json:"metadata,omitempty"`

	// SerialNumber Every BOM generated SHOULD have a unique serial number, even if the contents of the BOM have not changed over time. If specified, the serial number MUST conform to RFC-4122. Use of serial numbers are RECOMMENDED.
	SerialNumber *string `json:"serialNumber,omitempty"`

	// SpecVersion The version of the CycloneDX specification a BOM conforms to (starting at version 1.2).
	SpecVersion string `json:"specVersion"`

	// Version Whenever an existing BOM is modified, either manually or through automated processes, the version of the BOM SHOULD be incremented by 1. When a system is presented with multiple BOMs with identical serial numbers, the system SHOULD use the most recent version of the BOM. The default version is '1'.
	Version *int32 `json:"version,omitempty"`
}

// SbomResultResponseBomFormat Specifies the format of the BOM. This helps to identify the file as CycloneDX since BOMs do not have a filename convention nor does JSON schema support namespaces. This value MUST be "CycloneDX".
type SbomResultResponseBomFormat string

// SbomResultResponseCompositionsAggregate Specifies an aggregate type that describe how complete a relationship is.
//
// * __complete__ = The relationship is complete. No further relationships including constituent components, services, or dependencies are known to exist.
// * __incomplete__ = The relationship is incomplete. Additional relationships exist and may include constituent components, services, or dependencies.
// * __incomplete&#95;first&#95;party&#95;only__ = The relationship is incomplete. Only relationships for first-party components, services, or their dependencies are represented.
// * __incomplete&#95;first&#95;party&#95;proprietary&#95;only__ = The relationship is incomplete. Only relationships for first-party components, services, or their dependencies are represented, limited specifically to those that are proprietary.
// * __incomplete&#95;first&#95;party&#95;opensource&#95;only__ = The relationship is incomplete. Only relationships for first-party components, services, or their dependencies are represented, limited specifically to those that are opensource.
// * __incomplete&#95;third&#95;party&#95;only__ = The relationship is incomplete. Only relationships for third-party components, services, or their dependencies are represented.
// * __incomplete&#95;third&#95;party&#95;proprietary&#95;only__ = The relationship is incomplete. Only relationships for third-party components, services, or their dependencies are represented, limited specifically to those that are proprietary.
// * __incomplete&#95;third&#95;party&#95;opensource&#95;only__ = The relationship is incomplete. Only relationships for third-party components, services, or their dependencies are represented, limited specifically to those that are opensource.
// * __unknown__ = The relationship may be complete or incomplete. This usually signifies a 'best-effort' to obtain constituent components, services, or dependencies but the completeness is inconclusive.
// * __not&#95;specified__ = The relationship completeness is not specified.
type SbomResultResponseCompositionsAggregate string

// SbomResultResponseMetadataLifecycle The product lifecycle(s) that this BOM represents.
type SbomResultResponseMetadataLifecycle string

// ScanResultResponse defines model for ScanResultResponse.
type ScanResultResponse struct {
	// AssetType scan result asset type
	AssetType  ScanResultResponseAssetType `json:"assetType"`
	BaseImages *map[string]BaseImage       `json:"baseImages"`
	Layers     *map[string]Layer           `json:"layers,omitempty"`

	// Metadata metadata of the scan result
	Metadata    ScanResultResponse_Metadata          `json:"metadata"`
	Packages    map[string]Package                   `json:"packages"`
	Policies    *Policies                            `json:"policies,omitempty"`
	Producer    *Producer                            `json:"producer,omitempty"`
	RiskAccepts *map[string]RiskAcceptanceDefinition `json:"riskAccepts,omitempty"`

	// Stage scan result stage
	Stage           ScanResultResponseStage   `json:"stage"`
	Vulnerabilities *map[string]Vulnerability `json:"vulnerabilities,omitempty"`
}

// ScanResultResponseAssetType scan result asset type
type ScanResultResponseAssetType string

// ScanResultResponse_Metadata metadata of the scan result
type ScanResultResponse_Metadata struct {
	union json.RawMessage
}

// ScanResultResponseStage scan result stage
type ScanResultResponseStage string

// ScheduleResponse Schema for a scheduled report
type ScheduleResponse struct {
	// Compression Compression format
	Compression *string `json:"compression,omitempty"`

	// CreatedBy Email of the user who created the schedule
	CreatedBy string `json:"createdBy"`

	// CreatedOn Timestamp when the schedule was created
	CreatedOn time.Time `json:"createdOn"`

	// CustomerId ID of the customer associated with the schedule
	CustomerId int64 `json:"customerId"`

	// Description Description of the schedule
	Description *string `json:"description,omitempty"`

	// Enabled Indicates if the schedule is enabled
	Enabled bool `json:"enabled"`

	// IacTaskId ID of the IaC task
	IacTaskId *int64 `json:"iacTaskId,omitempty"`

	// Id Unique identifier for the schedule
	Id string `json:"id"`

	// IsReportTemplate Indicates if the report is a template
	IsReportTemplate bool `json:"isReportTemplate"`

	// LastCompletedOn Timestamp when the schedule was last completed
	LastCompletedOn *time.Time `json:"lastCompletedOn,omitempty"`

	// LastScheduledOn Timestamp when the schedule was last run
	LastScheduledOn *time.Time `json:"lastScheduledOn,omitempty"`

	// LastStartedOn Timestamp when the schedule was last started
	LastStartedOn *time.Time `json:"lastStartedOn,omitempty"`

	// ModifiedOn Timestamp when the schedule was last modified
	ModifiedOn *time.Time `json:"modifiedOn,omitempty"`

	// Name Name of the schedule
	Name *string `json:"name,omitempty"`

	// NotificationChannels List of notification channels
	NotificationChannels *[]NotificationChannel `json:"notificationChannels,omitempty"`

	// PasswordEnabled Indicates if password protection is enabled
	PasswordEnabled *bool `json:"passwordEnabled,omitempty"`

	// Policies List of policy IDs
	Policies *[]int64 `json:"policies,omitempty"`

	// ReportFormat Format of the report
	ReportFormat string `json:"reportFormat"`

	// ReportId ID of the report
	ReportId int64 `json:"reportId"`

	// ReportName Name of the report
	ReportName *string `json:"reportName,omitempty"`

	// Schedule Cron expression for the schedule
	Schedule string `json:"schedule"`

	// TeamId ID of the team associated with the schedule
	TeamId int64 `json:"teamId"`

	// Timezone Timezone for the schedule
	Timezone *string `json:"timezone,omitempty"`

	// UpdatedBy Email of the user who last updated the schedule
	UpdatedBy *string `json:"updatedBy,omitempty"`

	// UserId ID of the user who created the schedule
	UserId int64 `json:"userId"`

	// Zones List of zone IDs
	Zones []int64 `json:"zones"`
}

// Scope Scope labels that define the asset
type Scope = map[string]interface{}

// ScopeTypeV1 defines model for ScopeTypeV1.
type ScopeTypeV1 string

// ScopeV1 defines model for ScopeV1.
type ScopeV1 struct {
	Expression string      `json:"expression"`
	Type       ScopeTypeV1 `json:"type"`
}

// Sequence The sequence of events that occurred to trigger the event.
// The sequence is represented as a list of events, where each event is a map of key-value pairs.
type Sequence = []SequenceEvent

// SequenceEvent One of the events that occurred to trigger the stateful detection event.
type SequenceEvent struct {
	// EventId The unique identifier of the log event.
	EventId string `json:"eventId"`

	// EventName The name of the event.
	EventName string `json:"eventName"`

	// EventTime The time when the event occurred.
	EventTime time.Time `json:"eventTime"`

	// IngestionId The unique identifier of the ingestion.
	IngestionId string `json:"ingestionId"`

	// Region The region where the event occurred.
	Region string `json:"region"`

	// Source The source of the event.
	Source string `json:"source"`

	// SourceIpAddress The IP address of the source.
	SourceIpAddress string `json:"sourceIpAddress"`

	// SubIngestionId The unique identifier of the sub ingestion.
	SubIngestionId string `json:"subIngestionId"`
}

// ServiceAccountResponseV1 defines model for ServiceAccountResponseV1.
type ServiceAccountResponseV1 struct {
	// DateCreated Date and time when the Service Account was created.
	DateCreated *time.Time `json:"dateCreated,omitempty"`

	// ExpirationDate Date and time when the Service Account API key expires.
	ExpirationDate *time.Time `json:"expirationDate,omitempty"`

	Id *UnlimitedLong `json:"id,omitempty"`

	// LastUpdated Date and time when the Service Account was last updated.
	LastUpdated *time.Time `json:"lastUpdated,omitempty"`

	// LastUsed Date and time when the Service Account API key was last used.
	LastUsed *time.Time `json:"lastUsed,omitempty"`

	// Name Service Account display name.
	Name *string `json:"name,omitempty"`

	// SystemRoles Array of System roles assigned to the global service account.
	SystemRoles *[]string `json:"systemRoles,omitempty"`

	// TeamId Team ID of the team the service account is associated with.
	TeamId *int64 `json:"teamId,omitempty"`

	// TeamRole The predefined team role for a Service Account, or an ID of a custom role.
	TeamRole *string `json:"teamRole,omitempty"`
}

// ServiceAccountWithKeyResponseV1 defines model for ServiceAccountWithKeyResponseV1.
type ServiceAccountWithKeyResponseV1 struct {
	// ApiKey Service Account API key
	ApiKey *string `json:"apiKey,omitempty"`

	// DateCreated Date and time when the Service Account was created.
	DateCreated *time.Time `json:"dateCreated,omitempty"`

	// ExpirationDate Date and time when the Service Account API key expires.
	ExpirationDate *time.Time `json:"expirationDate,omitempty"`

	Id *UnlimitedLong `json:"id,omitempty"`

	// LastUpdated Date and time when the Service Account was last updated.
	LastUpdated *time.Time `json:"lastUpdated,omitempty"`

	// LastUsed Date and time when the Service Account API key was last used.
	LastUsed *time.Time `json:"lastUsed,omitempty"`

	// Name Service Account display name.
	Name *string `json:"name,omitempty"`

	// SystemRoles Array of System roles assigned to the global service account.
	SystemRoles *[]string `json:"systemRoles,omitempty"`

	// TeamId Team ID of the team the service account is associated with.
	TeamId *int64 `json:"teamId,omitempty"`

	// TeamRole The predefined team role for a Service Account, or an ID of a custom role.
	TeamRole *string `json:"teamRole,omitempty"`
}

// ServiceAccountsNotificationSettingsResponseV1 The base schema for the service accounts notification settings.
type ServiceAccountsNotificationSettingsResponseV1 = ServiceAccountsNotificationSettinsBase

// ServiceAccountsNotificationSettinsBase The base schema for the service accounts notification settings.
type ServiceAccountsNotificationSettinsBase struct {
	// DaysBeforeExpiry The number of days before the expiry of the service account when the notifications are to be sent.
	DaysBeforeExpiry *[]int32 `json:"daysBeforeExpiry,omitempty"`

	// IsEnabled Whether the notification settings are enabled or not.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// NotificationChannelIds The list of notification channel IDs to which the notifications are to be sent.\
	// \
	// Supported types are **EMAIL** and **SLACK**.
	NotificationChannelIds *[]UnlimitedLong `json:"notificationChannelIds,omitempty"`
}

// Services Certificate registrations
type Services struct {
	// CertificateId The certificate ID.
	CertificateId int64 `json:"certificateId"`

	// RegisteredAt The timestamp the service was configured to use this certificate.
	RegisteredAt time.Time `json:"registeredAt"`

	// ServiceId The integration ID for the service owning the integration that uses the certificate.
	ServiceId string `json:"serviceId"`

	// ServiceType The service type.
	ServiceType ServicesServiceType `json:"serviceType"`
}

// ServicesServiceType The service type.
type ServicesServiceType string

// ServicesResponse LedgersResponse
type ServicesResponse struct {
	Data []Services `json:"data"`
}

// Source Source of the event:
// - `syscall` - a syscall within a workload
// - `windows` - Windows event log
// - `profiling` - ML workload threat detections
// - `K8SAdmissionController` - Admission control request coming from the Kubernetes admission controller
// - `k8s_audit` - Kubernetes audit logs, if the category is `runtime`, otherwise Admission control request
// - `aws_cloudtrail` - AWS CloudTrail log, from CloudConnector
// - `awscloudtrail` - AWS CloudTrail log, agentless only
// - `agentless-aws-ml` - ML threat detections for AWS
// - `gcp_auditlog` - GCP Audit log
// - `azure_platformlogs` - Azure platform logs
// - `okta` - Okta System Logs
// - `agentless-okta-ml` - ML threat detections for Okta
// - `github` - Github organization logs
type Source string

// SourceDetails Additional details related to the Event source.
type SourceDetails struct {
	// SubType A deeper particularization for the type of component that generated the raw event:
	// - `auditlogs` - Audit logs of platforms/apps
	// - `auditWebhooks` - Kubernetes Audit
	// - `caas` - Container As A Service workload
	// - `dynamicAdmissionControl` - Dynamic admission control
	// - `host` - Non-containerized host
	// - `container` - Container
	// - `workforce` - Workforce type IAM
	SubType *string `json:"subType,omitempty"`

	// Type The type of component that generated the raw event:
	// - `cloud` - Cloud platform
	// - `git` - Git platform
	// - `iam` - Identity and Access Management platform
	// - `kubernetes` - Kubernetes control plane
	// - `workload` - Workload (from bare metal to *aaS compute)
	Type string `json:"type"`
}

// SsoSettingsBaseSchemaV1 defines model for SsoSettingsBaseSchemaV1.
type SsoSettingsBaseSchemaV1 struct {
	// CreateUserOnLogin Flag to indicate if the user will be created automatically if not found in the system.
	CreateUserOnLogin *bool `json:"createUserOnLogin,omitempty"`

	// GroupMappingAttributeName The group mapping attribute name.
	GroupMappingAttributeName *string `json:"groupMappingAttributeName"`

	// IntegrationName The name of this SSO config.
	IntegrationName *string `json:"integrationName"`

	// IsActive Flag to indicate if the SSO settings is active.
	IsActive *bool `json:"isActive,omitempty"`

	// IsGroupMappingEnabled Flag to indicate if group mapping support is enabled.
	IsGroupMappingEnabled *bool `json:"isGroupMappingEnabled,omitempty"`

	// IsPasswordLoginEnabled Flag to indicate if the user will be able to login with password. Deprecated: use the API endpoint `/platform/v1/global-sso-settings` for this functionality. This is now a global setting: if this flag is defined here and this SSO setting is set to be active, the setting will be applied at global level.
	// Deprecated:
	IsPasswordLoginEnabled *bool `json:"isPasswordLoginEnabled,omitempty"`

	// IsSingleLogoutEnabled Flag to indicate if the single logout support is enabled.
	IsSingleLogoutEnabled *bool `json:"isSingleLogoutEnabled,omitempty"`

	// Product The product to which SSO settings is applied to. SSO settings are configured per specific product.
	Product *Product `json:"product,omitempty"`
}

// SsoSettingsCreateRequestBaseV1 Create Request SSO Settings Base Schema
type SsoSettingsCreateRequestBaseV1 struct {
	// Type Supported SSO types
	Type SsoTypeV1 `json:"type"`
}

// SsoSettingsResponseBaseV1 Response SSO Settings Base Schema
type SsoSettingsResponseBaseV1 struct {
	// Type Supported SSO types
	Type SsoTypeV1 `json:"type"`
}

// SsoSettingsResponseV1 defines model for SsoSettingsResponseV1.
type SsoSettingsResponseV1 struct {
	// Config Response SSO Settings Base Schema
	Config *SsoSettingsResponseBaseV1 `json:"config,omitempty"`

	// CreateUserOnLogin Flag to indicate if the user will be created automatically if not found in the system.
	CreateUserOnLogin *bool `json:"createUserOnLogin,omitempty"`

	// DateCreated The date (in ISO 8601 format) when this SSO config was created.
	DateCreated *time.Time `json:"dateCreated,omitempty"`

	// GroupMappingAttributeName The group mapping attribute name.
	GroupMappingAttributeName *string `json:"groupMappingAttributeName"`

	Id *UnlimitedLong `json:"id,omitempty"`

	// IntegrationName The name of this SSO config.
	IntegrationName *string `json:"integrationName"`

	// IsActive Flag to indicate if the SSO settings is active.
	IsActive *bool `json:"isActive,omitempty"`

	// IsGroupMappingEnabled Flag to indicate if group mapping support is enabled.
	IsGroupMappingEnabled *bool `json:"isGroupMappingEnabled,omitempty"`

	// IsPasswordLoginEnabled Flag to indicate if the user will be able to login with password. Deprecated: use the API endpoint `/platform/v1/global-sso-settings` for this functionality. This is now a global setting: if this flag is defined here and this SSO setting is set to be active, the setting will be applied at global level.
	// Deprecated:
	IsPasswordLoginEnabled *bool `json:"isPasswordLoginEnabled,omitempty"`

	// IsSingleLogoutEnabled Flag to indicate if the single logout support is enabled.
	IsSingleLogoutEnabled *bool `json:"isSingleLogoutEnabled,omitempty"`

	// LastUpdated The date (in ISO 8601 format) when this SSO config was last updated.
	LastUpdated *time.Time `json:"lastUpdated,omitempty"`

	// Product The product to which SSO settings is applied to. SSO settings are configured per specific product.
	Product *Product `json:"product,omitempty"`

	Version *UnlimitedLong `json:"version,omitempty"`
}

// SsoSettingsUpdateRequestBaseV1 Update Request SSO Settings Base Schema
type SsoSettingsUpdateRequestBaseV1 struct {
	// Type Supported SSO types
	Type SsoTypeV1 `json:"type"`
}

// SsoTypeV1 Supported SSO types
type SsoTypeV1 string

// Stage defines model for Stage.
type Stage struct {
	// Configuration Configurations for the stage.
	Configuration *[]StageConfiguration `json:"configuration,omitempty"`

	// Name stage name.
	Name string `json:"name"`
}

// StageConfiguration defines model for StageConfiguration.
type StageConfiguration struct {
	// Scope Scope to apply the policies for the given stage. An empty string or missing property implies the policies are always active.
	// The scope is defined using a query language expression, which is a subset of the full metrics query language used in monitoring.
	Scope *string `json:"scope,omitempty"`
}

// StatefulDetectionsContent defines model for StatefulDetectionsContent.
type StatefulDetectionsContent struct {
	Fields map[string]string `json:"fields"`

	// Output Event output, generated after the configured rule
	Output string `json:"output"`

	// PolicyId ID of the policy that generated the event
	PolicyId PolicyId `json:"policyId"`

	// PolicyNotificationChannelIds The list of notification channels where an alert is sent after event is generated.
	// Doesn't account for aggregations and eventual thresholds.
	PolicyNotificationChannelIds PolicyNotificationChannelIds `json:"policyNotificationChannelIds"`

	// PolicyOrigin The policy author:
	// - `Sysdig` - default and managed policies
	// - `Sysdig UI` - users interacting with Sysdig
	// - `Tuner` - the automated tuner
	PolicyOrigin PolicyOrigin `json:"policyOrigin"`

	// RuleName Name of the rule the event is generated after
	RuleName RuleName `json:"ruleName"`

	// RuleTags The tags attached to the rule
	RuleTags RuleTags `json:"ruleTags"`

	// RuleType Rule type:
	// - 1 - List matching - process
	// - 2 - List matching - container
	// - 3 - List matching - file
	// - 4 - List matching - network
	// - 5 - List matching - syscall
	// - 6 - Falco
	// - 7 - Drift detection
	// - 8 - Malware detection
	// - 11 - ML - Cryptominer detection
	// - 13 - ML - AWS anomalous login
	// - 14 - ML - Okta anomalous login
	RuleType RuleType `json:"ruleType"`

	// Sequence The sequence of events that occurred to trigger the event.
	// The sequence is represented as a list of events, where each event is a map of key-value pairs.
	Sequence *Sequence `json:"sequence,omitempty"`

	// Stats An array representing the relevant APIs and how often they were called in the time window.
	Stats *Stats `json:"stats,omitempty"`

	// Type The type of the event content.
	Type EventContentType `json:"type"`
}

// Stats An array representing the relevant APIs and how often they were called in the time window.
type Stats = []struct {
	Api   *string `json:"api,omitempty"`
	Count *int32  `json:"count,omitempty"`
}

// SubmitActionExecutionRequest The request for the execution of a Response Action.
type SubmitActionExecutionRequest struct {
	// ActionType The name of the Response Action to execute.
	// It may be one of the following:
	// - KILL_PROCESS
	// - KILL_CONTAINER
	// - STOP_CONTAINER
	// - PAUSE_CONTAINER
	// - FILE_QUARANTINE
	// - FILE_ACQUIRE
	// - UNPAUSE_CONTAINER
	// - FILE_UNQUARANTINE
	// - START_CONTAINER
	// - DELETE_POD
	// - ROLLOUT_RESTART
	// - KUBERNETES_VOLUME_SNAPSHOT
	// - KUBERNETES_DELETE_VOLUME_SNAPSHOT
	// - GET_LOGS
	// - ISOLATE_NETWORK
	// - DELETE_NETWORK_POLICY
	//
	// The following actions serve as the undo for previous actions:
	// - START_CONTAINER: undo for STOP_CONTAINER\
	// - UNPAUSE_CONTAINER: undo for PAUSE_CONTAINER\
	// - FILE_UNQUARANTINE: undo for FILE_QUARANTINE\
	// - KUBERNETES_DELETE_VOLUME_SNAPSHOT: undo for KUBERNETES_VOLUME_SNAPSHOT\
	// - DELETE_NETWORK_POLICY: undo for ISOLATE_NETWORK\
	//
	// Do not use undo actions in [submitActionExecutionv1](#tag/Response-actions/operation/submitActionExecutionv1).
	//
	// You can execute an undo actions using the service [undoActionExecutionV1](#tag/Response-actions/operation/undoActionExecutionV1).
	ActionType ResponseActionType `json:"actionType"`

	// CallerId The ID of the user that executed the Response action.
	CallerId *CallerId `json:"callerId,omitempty"`

	// Parameters The parameters used to request the Response Action execution.
	Parameters ActionExecutionParameters `json:"parameters"`
}

// SupportedFilter A supported field for filtering events.
type SupportedFilter struct {
	// Id Attribute onto which filtering is supported.
	Id string `json:"id"`

	// Operands The list of supported operands for filtering events.
	Operands *[]Operand `json:"operands,omitempty"`

	// Type Data type for the attribute values.
	Type SupportedFilterType `json:"type"`
}

// SupportedFilterType Data type for the attribute values.
type SupportedFilterType string

// SupportedFiltersResponse The list of supported attributes for filtering events.
type SupportedFiltersResponse struct {
	// Data The list of supported attributes for filtering events.
	Data []SupportedFilter `json:"data"`
}

// SysdigQueryLanguageFilter Query language expression for filtering results.
// The filter is the result of logical concatenations,
// using "and" and "or" binary operators and the "not" unary prefix operator (i.e. `pid = 1 and not ppid = 2`),
// of attribute comparisons. Attribute comparisons can be:
// - Scalar: Using `=`, `!=`, `>`, `>=`, `<` and `<=` comparison operators. For example, `pid = 1`.
// - Vector: Using `in` to check the equality among the values provided between parenthesis. For example, `pid in (1, 2)`.
// The operators available depends on the attribute.
// Values containing double-quotes `"` need escaping using backslash `\`, i.e. name = "sample \"quoted\" value".
// You can retrieve the list of supported attributes and related operators through the
// `/secure/activity-audit/v1/supported-filters` endpoint.
// `freeText` is available as an additional attribute to provide free-text search capabilities.
// `freeText` supports the operators `=` (match) and `!=` (does not match).
//
// EBNF:
// ```
// attribute             = ? all available attributes ? ;
// value                 = ? attribute value ? ;
// quoted_value          = "\"", value, "\"" ;
// bin_operator          = "and" | "or";
// cmp_scalar_operator   = "=" | "!=" | ">" | ">=" | "<" | "<=" ;
// cmp_vector_operator   = "in";
// cmp_scalar_operation  = attribute, [" "], cmp_scalar_operator, [" "], quoted_value ;
// values_list           = "(", quoted_value, { [" "], ",", quoted_value }, ")" ;
// cmp_vector_operation  = attribute, " ", cmp_vector_operator, [" "], values_list ;
// freetext_operation    = "freeText ", "=" | "!=", quoted_value ;
// element               = ["not "], (cmp_scalar_operation | cmp_vector_operation | freetext_operation) ;
// filter                = element, {" ", bin_operator, " ", element} ;
// ```
type SysdigQueryLanguageFilter = string

// TeamMapV1 Determines the teams to which a group is mapped.
type TeamMapV1 struct {
	// IsForAllTeams If true, the group is mapped to all teams.
	IsForAllTeams *bool `json:"isForAllTeams,omitempty"`

	// TeamIds The list of teams to which group is mapped. It is empty when 'isForAllTeams' is true, otherwise it should have at least 1 element.
	TeamIds *[]UnlimitedLong `json:"teamIds,omitempty"`
}

// TeamResponseV1 defines model for TeamResponseV1.
type TeamResponseV1 struct {
	// AdditionalTeamPermissions Additional permissions available to the users of the team.
	AdditionalTeamPermissions *AdditionalTeamPermissionsV1 `json:"additionalTeamPermissions,omitempty"`

	// CustomTeamRoleId The custom team role assigned by default to users added to this team. Mutually exclusive with 'standardTeamRoleId'.
	CustomTeamRoleId *UnlimitedLong `json:"customTeamRoleId"`

	// DateCreated The date (in ISO 8601 format) when this team was created.
	DateCreated *time.Time `json:"dateCreated,omitempty"`

	// Description A description of the team explaining what is it used for.
	Description *string `json:"description"`

	Id *UnlimitedLong `json:"id,omitempty"`

	// IsAllZones 'True' if the users belonging to this team have access to all zones. Mutually exclusive with 'zoneIds'.
	IsAllZones *bool `json:"isAllZones,omitempty"`

	// IsDefaultTeam Specifies if the team is the default team. The default team is used to automatically assign new users to a team.
	IsDefaultTeam *bool `json:"isDefaultTeam,omitempty"`

	// IsImmutableTeam Specifies if the team is immutable. This is true if the team was created by the system with full access. It cannot be modified.
	IsImmutableTeam *bool `json:"isImmutableTeam,omitempty"`

	// LastUpdated The date (in ISO 8601 format) when this team was last updated.
	LastUpdated *time.Time `json:"lastUpdated,omitempty"`

	// Name The name of the team. It must be unique.
	Name *string `json:"name,omitempty"`

	// Product The product to which the team is assigned to.
	Product *Product `json:"product,omitempty"`

	// Scopes The scopes available to the users of this team.
	Scopes *[]ScopeV1 `json:"scopes,omitempty"`

	// StandardTeamRole The standard team role assigned by default to users added to this team. Mutually exclusive with 'customTeamRoleId'.
	StandardTeamRole *TeamRoleV1 `json:"standardTeamRole"`

	// UiSettings UI related settings.
	UiSettings *UiSettingsV1 `json:"uiSettings,omitempty"`

	Version *UnlimitedLong `json:"version,omitempty"`

	// ZoneIds The list of zones that users assigned to this team will have access to. Mutually exclusive with 'allZones'.
	ZoneIds *[]UnlimitedLong `json:"zoneIds,omitempty"`
}

// TeamRoleV1 The standard team role provided by Sysdig.
type TeamRoleV1 string

// TeamUserResponseV1 defines model for TeamUserResponseV1.
type TeamUserResponseV1 struct {
	CustomTeamRoleId *UnlimitedLong `json:"customTeamRoleId"`
	StandardTeamRole *TeamRoleV1    `json:"standardTeamRole"`

	TeamId *UnlimitedLong `json:"teamId,omitempty"`

	UserId *UnlimitedLong `json:"userId,omitempty"`
}

// TimeFrame The start and end time of the request
type TimeFrame struct {
	From *UnlimitedLong `json:"from,omitempty"`

	To *UnlimitedLong `json:"to,omitempty"`
}

// Timestamp Timestamp the audit event occured, expressed in nanoseconds.
type Timestamp = int64

// To To, expressed in Unix nanoseconds timestamp. The difference between `from` and `to` cannot be greater than 2 weeks.
// If defined, `cursor` cannot be used.
type To = int64

// Types The entry types to filter. This query parameter can be set multiple times
// to filter for different entry types.
type Types string

// UiSettingsV1 UI related settings.
type UiSettingsV1 struct {
	// EntryPoint The page you see after logging into Sysdig UI. It is defined by a Module and a Selection.
	// **The Entry Point is not supported in Sysdig Secure.**
	EntryPoint *EntryPointV1 `json:"entryPoint,omitempty"`

	// Theme The color assigned to the team.
	Theme *string `json:"theme,omitempty"`
}

// UnitPricingV1 The unit pricing configuration used to compute costs.
type UnitPricingV1 struct {
	// Cpu Hourly cost of one CPU.
	Cpu float32 `json:"cpu"`

	// Ram Hourly cost of one GB of RAM.
	Ram float32 `json:"ram"`

	// SpotCpu Hourly cost of one CPU for a spot node.
	SpotCpu *float32 `json:"spotCpu"`

	// SpotRam Hourly cost of one GB of RAM for a spot node.
	SpotRam *float32 `json:"spotRam"`

	// Storage Hourly cost of one GB of storage.
	Storage float32 `json:"storage"`
}

type UnlimitedLong = int64

// UpdateAccessKeyRequestV1 Update access key request
type UpdateAccessKeyRequestV1 struct {
	// AgentLimit Maximum number of agents that can be connected with the access key
	AgentLimit *int32 `json:"agentLimit,omitempty"`

	// AgentReservation Number of agents that are guaranteed to be available for the access key
	AgentReservation *int32 `json:"agentReservation,omitempty"`

	// IsEnabled Flag that indicates if the access key should be disabled or enabled
	IsEnabled bool `json:"isEnabled"`

	// Metadata Access key metadata (maximum of 20 key-value pairs where key can be up to 25 characters long and value can be up to 50 characters long)
	Metadata *map[string]string `json:"metadata,omitempty"`

	// TeamId ID of team that owns the access key
	TeamId *int32 `json:"teamId,omitempty"`
}

// UpdateAmazonSqsIntegrationRequest defines model for UpdateAmazonSqsIntegrationRequest.
type UpdateAmazonSqsIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels `json:"channels,omitempty"`
	ConnectionInfo struct {
		// AccessKey Access Key for authenticating on AWS to send data on the queue
		AccessKey *string `json:"accessKey,omitempty"`

		// AccessSecret Access Secret for authenticating on AWS to send data on the queue
		AccessSecret *string `json:"accessSecret,omitempty"`

		// Delay Delay, in seconds, applied to the data
		Delay *int64 `json:"delay,omitempty"`

		// Headers Extra headers to add to the payload. Each header mapping requires 2 keys: 'key' for the header key and 'value' for its value
		Headers *[]KeyValueObject `json:"headers,omitempty"`

		// IsFifo If the queue is of FIFO type
		IsFifo *bool `json:"isFifo,omitempty"`

		// OwnerAccount The AWS account ID of the account that created the queue
		OwnerAccount *string `json:"ownerAccount,omitempty"`

		// Queue Queue name
		Queue string `json:"queue"`

		// Region Region in which the SQS queue is hosted
		Region string `json:"region"`
	} `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// UpdateChronicleIntegrationConnInfo defines model for UpdateChronicleIntegrationConnInfo.
type UpdateChronicleIntegrationConnInfo struct {
	// ApiKey The Chronicle v2 API key
	ApiKey *string `json:"apiKey,omitempty"`

	// Region The target region
	Region *UpdateChronicleIntegrationConnInfoRegion `json:"region,omitempty"`
}

// UpdateChronicleIntegrationConnInfoRegion The target region
type UpdateChronicleIntegrationConnInfoRegion string

// UpdateChronicleIntegrationConnInfoV2 defines model for UpdateChronicleIntegrationConnInfoV2.
type UpdateChronicleIntegrationConnInfoV2 struct {
	// ChronicleCustomerId Unique identifier (UUID) corresponding to a particular Chronicle instance
	ChronicleCustomerId string `json:"chronicleCustomerId"`

	// CredentialsOAuth2 The Chronicle v2 OAuth2 credentials
	CredentialsOAuth2 *string `json:"credentialsOAuth2,omitempty"`

	// Namespace User-configured environment namespace to identify the data domain the logs originated from
	Namespace string `json:"namespace"`

	// Region The target region
	Region *UpdateChronicleIntegrationConnInfoV2Region `json:"region,omitempty"`
}

// UpdateChronicleIntegrationConnInfoV2Region The target region
type UpdateChronicleIntegrationConnInfoV2Region string

// UpdateChronicleIntegrationRequest defines model for UpdateChronicleIntegrationRequest.
type UpdateChronicleIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels                             `json:"channels,omitempty"`
	ConnectionInfo UpdateChronicleIntegrationRequest_ConnectionInfo `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// UpdateChronicleIntegrationRequest_ConnectionInfo defines model for UpdateChronicleIntegrationRequest.ConnectionInfo.
type UpdateChronicleIntegrationRequest_ConnectionInfo struct {
	union json.RawMessage
}

// UpdateEfoIntegrationRequestV1 Update Integration Request
type UpdateEfoIntegrationRequestV1 struct {
	union json.RawMessage
}

// UpdateElasticsearchIntegrationRequest defines model for UpdateElasticsearchIntegrationRequest.
type UpdateElasticsearchIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels `json:"channels,omitempty"`
	ConnectionInfo struct {
		// Auth Authentication method
		Auth *UpdateElasticsearchIntegrationRequestConnectionInfoAuth `json:"auth,omitempty"`

		// Endpoint Elasticsearch instance endpoint URL
		Endpoint string `json:"endpoint"`

		// Format If specified, transforms `content.fields` and `labels`
		// * `KV_PAIRS` - from objects (i.e. `{"foo": "bar", ...}`) to arrays of objects with "key" and "value" properties {i.e. `[{"key" : "foo", "value": "bar"}, ...]`)
		Format *UpdateElasticsearchIntegrationRequestConnectionInfoFormat `json:"format,omitempty"`

		// Index Name of the index to store the data in
		Index string `json:"index"`

		// IsInsecure Don't verify TLS certificate
		IsInsecure *bool `json:"isInsecure,omitempty"`

		// Secret Authentication secret. To be set if auth is specified
		Secret *string `json:"secret,omitempty"`
	} `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// UpdateElasticsearchIntegrationRequestConnectionInfoAuth Authentication method
type UpdateElasticsearchIntegrationRequestConnectionInfoAuth string

// UpdateElasticsearchIntegrationRequestConnectionInfoFormat If specified, transforms `content.fields` and `labels`
// * `KV_PAIRS` - from objects (i.e. `{"foo": "bar", ...}`) to arrays of objects with "key" and "value" properties {i.e. `[{"key" : "foo", "value": "bar"}, ...]`)
type UpdateElasticsearchIntegrationRequestConnectionInfoFormat string

// UpdateGooglePubSubIntegrationRequest defines model for UpdateGooglePubSubIntegrationRequest.
type UpdateGooglePubSubIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels `json:"channels,omitempty"`
	ConnectionInfo struct {
		// Attributes Extra headers to add to the request. Each header mapping requires 2 keys: "key" for the header key and "value" for its value
		Attributes *[]KeyValueObject `json:"attributes,omitempty"`

		// CredentialsJson JSON credentials for the service account Sysdig will use to send data
		CredentialsJson *string `json:"credentialsJson,omitempty"`

		// OrderingKey The key to use to order the messages. Required to enable ordered delivery
		OrderingKey *string `json:"orderingKey,omitempty"`

		// Project GCP project ID hosting the target pub/sub
		Project string `json:"project"`

		// Topic pub/sub topic onto which publish the data
		Topic string `json:"topic"`
	} `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// UpdateGoogleSccIntegrationRequest defines model for UpdateGoogleSccIntegrationRequest.
type UpdateGoogleSccIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels `json:"channels,omitempty"`
	ConnectionInfo struct {
		// CredentialsJson JSON credentials for the service account Sysdig will use to send data
		CredentialsJson *string `json:"credentialsJson,omitempty"`

		// Organization ID of your GCP organization
		Organization string `json:"organization"`

		// SecurityMarks additional annotations to add to assets or findings as they get forwarded to Security Command Center
		SecurityMarks *[]KeyValueObject `json:"securityMarks,omitempty"`
	} `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// UpdateGroupMappingRequestV1 defines model for UpdateGroupMappingRequestV1.
type UpdateGroupMappingRequestV1 struct {
	// CustomTeamRoleId The custom team role ID assigned for the user in this team. **Mutually exclusive with standardTeamRole**.
	CustomTeamRoleId *UnlimitedLong `json:"customTeamRoleId"`

	// GroupName The group name matching the external provider name.
	GroupName string `json:"groupName"`

	// IsAdmin Flag that indicates if the group is an admin group.
	IsAdmin bool `json:"isAdmin"`

	// StandardTeamRole The standard team role assigned for the user in this team. **Mutually exclusive with customTeamRoleId**.
	StandardTeamRole *TeamRoleV1 `json:"standardTeamRole"`

	// TeamMap Determines the teams to which a group is mapped.
	TeamMap TeamMapV1 `json:"teamMap"`

	// Weight The weight of the group mapping that is used to determine the priority - a lower number has higher priority.
	Weight int16 `json:"weight"`
}

// UpdateInhibitionRuleRequestV1 defines model for UpdateInhibitionRuleRequestV1.
type UpdateInhibitionRuleRequestV1 struct {
	// Description Description of the inhibition rule.
	Description *string `json:"description"`

	// Equal List of labels that must have an equal value in the source and target alert for the inhibition to take effect.
	Equal *[]string `json:"equal"`

	// IsEnabled Indicates if the inhibition rule is enabled or not.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name Name of the inhibition rule. If provided, must be unique.
	Name *string `json:"name"`

	// SourceMatchers List of source matchers for which one or more alerts have to exist for the inhibition to take effect.
	SourceMatchers []LabelMatcherV1 `json:"sourceMatchers"`

	// TargetMatchers List of target matchers that have to be fulfilled by the target alerts to be muted.
	TargetMatchers []LabelMatcherV1 `json:"targetMatchers"`

	// Version The current version of the resource.
	Version UnlimitedLong `json:"version"`
}

// UpdateIntegrationRequest Update Integration Request
type UpdateIntegrationRequest struct {
	union json.RawMessage
}

// UpdateIntegrationRequestV1 defines model for UpdateIntegrationRequestV1.
type UpdateIntegrationRequestV1 struct {
	// Name Integration name.
	Name string `json:"name"`

	// IsEnabled Integration enabled status.
	IsEnabled *bool `json:"isEnabled"`

	// IsAllTeams If **true**, the integration will be enabled for all teams.
	// If **false**, the integration will be enabled for the teams specified in the *teamIds* field.
	IsAllTeams *bool `json:"isAllTeams"`

	// TeamIDs List of Sysdig's internal team ids for which the integration will be enabled.
	// This field is required if *isAllTeams* is **false**.
	TeamIDs []UnlimitedLong `json:"teamIds"`

	// JiraURL Customer's Jira URL.
	JiraURL string `json:"jiraUrl"`

	// JiraEmail The user email associated with the Jira account.
	JiraEmail openapi_types.Email `json:"jiraEmail"`

	// JiraAccessToken Jira access token for the provided Jira account.
	JiraAccessToken string `json:"jiraAccessToken"`

	// JiraAssignee The default assignee Jira account ID for this integration.
	// Please refer to the [Jira documentation](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-user-search/#api-group-user-search "Jira user documentation") for more info.
	JiraAssignee *string `json:"jiraAssignee"`

	// JiraLabels The list of Jira labels available for this integration.
	// Please refer to the [Jira documentation](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-labels/#api-group-labels "Jira labels documentation") for more info.
	JiraLabels []string `json:"jiraLabels"`

	// ParentIssueTypeID Internal Sysdig's issue type id, which will act as a parent issue type for the integration.
	ParentIssueTypeID *UnlimitedLong `json:"parentIssueTypeId"`

	// ChildIssueTypeID Internal Sysdig's issue type id, which will act as a child issue type for the integration.
	ChildIssueTypeID *UnlimitedLong `json:"childIssueTypeId"`
}

// UpdateIpFilterV1 Request to update IP filter.
type UpdateIpFilterV1 struct {
	// IpRange IP range in CIDR notation
	IpRange   string `json:"ipRange"`
	IsEnabled bool   `json:"isEnabled"`
	Note      string `json:"note"`
}

// UpdateIssueTypeRequestV1 defines model for UpdateIssueTypeRequestV1.
type UpdateIssueTypeRequestV1 struct {
	// JiraOpenStatusID Jira status id mapped to open status.
	// Please refer to the [Jira documentation](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-status/#api-group-status "Jira status documentation") for more info.
	JiraOpenStatusID string `json:"jiraOpenStatusId"`

	// JiraInProgressStatusID Jira status id mapped to in progress status.
	// Please refer to the [Jira documentation](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-status/#api-group-status "Jira status documentation") for more info.
	JiraInProgressStatusID string `json:"jiraInProgressStatusId"`

	// JiraClosedStatusID Jira status id mapped to closed status.
	// Please refer to the [Jira documentation](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-status/#api-group-status "Jira status documentation") for more info.
	JiraClosedStatusID string `json:"jiraClosedStatusId"`

	// CustomFieldIDs List of supported custom field ids for the issue type.
	// Please refer to the [Jira documentation](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issues/#api-rest-api-3-issue-createmeta-get "Jira issue type fields documentation") for more info.
	CustomFieldIDs []string `json:"customFieldIds"`
}

// UpdateKafkaIntegrationRequest defines model for UpdateKafkaIntegrationRequest.
type UpdateKafkaIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels                         `json:"channels,omitempty"`
	ConnectionInfo UpdateKafkaIntegrationRequest_ConnectionInfo `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// UpdateKafkaIntegrationRequest_ConnectionInfo defines model for UpdateKafkaIntegrationRequest.ConnectionInfo.
type UpdateKafkaIntegrationRequest_ConnectionInfo struct {
	union json.RawMessage
}

// UpdateKafkaIntegrationRequestV1 defines model for UpdateKafkaIntegrationRequestV1.
type UpdateKafkaIntegrationRequestV1 struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels                           `json:"channels,omitempty"`
	ConnectionInfo UpdateKafkaIntegrationRequestV1_ConnectionInfo `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// UpdateKafkaIntegrationRequestV1ConnectionInfoAuth The authentication method to optionally use. Currently supporting only GSSAPI
type UpdateKafkaIntegrationRequestV1ConnectionInfoAuth string

// UpdateKafkaIntegrationRequestV1ConnectionInfoBalancer Algorithm that the client uses to multiplex data between the multiple Brokers. For compatibility with the Java client, Murmur2 is used as the default partitioner
type UpdateKafkaIntegrationRequestV1ConnectionInfoBalancer string

// UpdateKafkaIntegrationRequestV1ConnectionInfoCompression Compression standard used for the data
type UpdateKafkaIntegrationRequestV1ConnectionInfoCompression string

// UpdateKafkaIntegrationRequestV1_ConnectionInfo defines model for UpdateKafkaIntegrationRequestV1.ConnectionInfo.
type UpdateKafkaIntegrationRequestV1_ConnectionInfo struct {
	// Auth The authentication method to optionally use. Currently supporting only GSSAPI
	Auth UpdateKafkaIntegrationRequestV1ConnectionInfoAuth `json:"auth"`

	// Balancer Algorithm that the client uses to multiplex data between the multiple Brokers. For compatibility with the Java client, Murmur2 is used as the default partitioner
	Balancer *UpdateKafkaIntegrationRequestV1ConnectionInfoBalancer `json:"balancer,omitempty"`

	// Brokers Kafka server endpoint. A Kafka cluster may provide several brokers; it follows the 'hostname: port' (without protocol scheme).
	Brokers []string `json:"brokers"`

	// Compression Compression standard used for the data
	Compression *UpdateKafkaIntegrationRequestV1ConnectionInfoCompression `json:"compression,omitempty"`

	// Keytab base64 encoded Kerberos keytab
	Keytab *string `json:"keytab,omitempty"`

	// Krb5 Kerberos krb5.conf file content for GSSAPI
	Krb5 string `json:"krb5"`

	// Principal GSSAPI principal
	Principal string `json:"principal"`

	// Realm GSSAPI realm
	Realm string `json:"realm"`

	// Service GSSAPI Service name
	Service string `json:"service"`

	// Topic Kafka topic where you want to store the forwarded data
	Topic string `json:"topic"`
	union json.RawMessage
}

// UpdateMcmIntegrationRequest defines model for UpdateMcmIntegrationRequest.
type UpdateMcmIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels `json:"channels,omitempty"`
	ConnectionInfo struct {
		// AccountId IBM Account ID
		AccountId *string `json:"accountId,omitempty"`

		// ApiKey IBM Cloud API Key
		ApiKey *string `json:"apiKey,omitempty"`

		// Endpoint The URL, including protocol and port (if non standard), to your IBM Cloud Pak for Multicloud Management API endpoint
		Endpoint string `json:"endpoint"`

		// IsInsecure Skip TLS certificate verification
		IsInsecure *bool `json:"isInsecure,omitempty"`

		// NoteName The note to use. If unspecified, a note with `policy-event` ID will be created and used
		NoteName *string `json:"noteName,omitempty"`

		// ProviderId The provider the findings will be associated to
		ProviderId *string `json:"providerId,omitempty"`
	} `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// UpdateMicrosoftSentinelIntegrationRequest defines model for UpdateMicrosoftSentinelIntegrationRequest.
type UpdateMicrosoftSentinelIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels `json:"channels,omitempty"`
	ConnectionInfo struct {
		// Secret Log analytics primary key
		Secret *string `json:"secret,omitempty"`

		// WorkspaceId Log Analytics workspace ID
		WorkspaceId string `json:"workspaceId"`
	} `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// UpdateNotificationChannelRequestV1 defines model for UpdateNotificationChannelRequestV1.
type UpdateNotificationChannelRequestV1 struct {
	// Type The type of the notification channel
	Type NotificationChannelTypeV1 `json:"type"`

	// Version The current version of the resource.
	Version *UnlimitedLong `json:"version,omitempty"`
}

// UpdatePricingRequestV1 defines model for UpdatePricingRequestV1.
type UpdatePricingRequestV1 struct {
	// ClusterName The name of the cluster. Required when `type` is `CLUSTER`.
	ClusterName *string `json:"clusterName"`

	// Name The name of the pricing profile.
	Name string `json:"name"`

	// SpotLabel The name of a node label that is used to identify the node as a spot node.
	SpotLabel *string `json:"spotLabel"`

	// SpotLabelValue The value of the spot node label.
	SpotLabelValue *string `json:"spotLabelValue"`

	// Type The type of the pricing.
	Type PricingType `json:"type"`

	// UnitPricing The unit pricing configuration used to compute costs.
	UnitPricing UnitPricingV1 `json:"unitPricing"`

	// Version The current version of the resource.
	Version UnlimitedLong `json:"version"`
}

// UpdateQradarIntegrationRequest defines model for UpdateQradarIntegrationRequest.
type UpdateQradarIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels     `json:"channels,omitempty"`
	ConnectionInfo BaseConnectionInfoQradar `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// UpdateRiskAccepted defines model for UpdateRiskAccepted.
type UpdateRiskAccepted struct {
	// Description Description of why the accepted risk was created
	Description *string `json:"description,omitempty"`

	// ExpirationDate Date when the accepted risk expires. Setting this to null will make the accepted risk never expire.
	ExpirationDate *string `json:"expirationDate"`

	// Reason Reason for acceptance
	Reason *UpdateRiskAcceptedReason `json:"reason,omitempty"`
}

// UpdateRiskAcceptedReason Reason for acceptance
type UpdateRiskAcceptedReason string

// UpdateServiceAccountsNotificationSettingsRequestV1 The base schema for the service accounts notification settings.
type UpdateServiceAccountsNotificationSettingsRequestV1 = ServiceAccountsNotificationSettinsBase

// UpdateSplunkIntegrationRequest defines model for UpdateSplunkIntegrationRequest.
type UpdateSplunkIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels `json:"channels,omitempty"`
	ConnectionInfo struct {
		// CertificateId ID of a certificate stored in Sysdig's [Certificates Management tool](#tag/Certificates). Note that the RFC 5425 (TLS) protocol is required for you to see this field
		CertificateId *int64 `json:"certificateId,omitempty"`

		// Endpoint URL of the Splunk instance
		Endpoint string `json:"endpoint"`

		// Index index to send data to. If unspecified, it will be used the index specified on the HTTP Event Collector configuration on Splunk
		Index *string `json:"index,omitempty"`

		// IsInsecure Skip TLS certificate verification
		IsInsecure *bool `json:"isInsecure,omitempty"`

		// SourceType Source type to override [Sysdig standard data type to source type mapping](https://docs.sysdig.com/en/forward-splunk#reference-data-categories-mapped-to-source-types)
		SourceType *string `json:"sourceType,omitempty"`

		// Token HTTP Event Collector Token
		Token *string `json:"token,omitempty"`
	} `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// UpdateSsoSettingsRequestV1 defines model for UpdateSsoSettingsRequestV1.
type UpdateSsoSettingsRequestV1 struct {
	// Config Update Request SSO Settings Base Schema
	Config *SsoSettingsUpdateRequestBaseV1 `json:"config,omitempty"`

	// CreateUserOnLogin Flag to indicate if the user will be created automatically if not found in the system.
	CreateUserOnLogin *bool `json:"createUserOnLogin,omitempty"`

	// GroupMappingAttributeName The group mapping attribute name.
	GroupMappingAttributeName *string `json:"groupMappingAttributeName"`

	// IntegrationName The name of this SSO config.
	IntegrationName *string `json:"integrationName"`

	// IsActive Flag to indicate if the SSO settings is active.
	IsActive *bool `json:"isActive,omitempty"`

	// IsGroupMappingEnabled Flag to indicate if group mapping support is enabled.
	IsGroupMappingEnabled *bool `json:"isGroupMappingEnabled,omitempty"`

	// IsPasswordLoginEnabled Flag to indicate if the user will be able to login with password. Deprecated: use the API endpoint `/platform/v1/global-sso-settings` for this functionality. This is now a global setting: if this flag is defined here and this SSO setting is set to be active, the setting will be applied at global level.
	// Deprecated:
	IsPasswordLoginEnabled *bool `json:"isPasswordLoginEnabled,omitempty"`

	// IsSingleLogoutEnabled Flag to indicate if the single logout support is enabled.
	IsSingleLogoutEnabled *bool `json:"isSingleLogoutEnabled,omitempty"`

	// Product The product to which SSO settings is applied to. SSO settings are configured per specific product.
	Product *Product `json:"product,omitempty"`

	Version *UnlimitedLong `json:"version,omitempty"`
}

// UpdateSyslogIntegrationRequest defines model for UpdateSyslogIntegrationRequest.
type UpdateSyslogIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels     `json:"channels,omitempty"`
	ConnectionInfo BaseConnectionInfoSyslog `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// UpdateTeamRequestV1 defines model for UpdateTeamRequestV1.
type UpdateTeamRequestV1 struct {
	// AdditionalTeamPermissions Additional permissions available to the users of the team.
	AdditionalTeamPermissions AdditionalTeamPermissionsV1 `json:"additionalTeamPermissions"`

	// CustomTeamRoleId The custom team role assigned by default to users added to this team.
	CustomTeamRoleId *UnlimitedLong `json:"customTeamRoleId,omitempty"`

	// Description A description of the team explaining what is it used for.
	Description *string `json:"description,omitempty"`

	// IsAllZones **True** if the users that are members of this team have access to all zones. **Mutually exclusive with zoneIds**.\
	// \
	// _Only supported in Secure features._
	IsAllZones *bool `json:"isAllZones,omitempty"`

	// IsDefaultTeam Specifies if this is the default team. The default team is used to automatically assign new users to a team.
	IsDefaultTeam bool `json:"isDefaultTeam"`

	// Name The name of the team.
	Name string `json:"name"`

	// Scopes Scopes is a list of different scope types and filter values that will be applied to resources
	// when accessed through the team.
	Scopes []ScopeV1 `json:"scopes"`

	// StandardTeamRole The standard team role assigned by default to users added to this team.
	StandardTeamRole *TeamRoleV1 `json:"standardTeamRole,omitempty"`

	// UiSettings UI related settings.
	UiSettings UiSettingsV1 `json:"uiSettings"`

	Version UnlimitedLong `json:"version"`

	// ZoneIds The list of zones that users assigned to this team will have access to. **Mutually exclusive with allZones**.\
	// \
	// _Only supported in Secure features._
	ZoneIds *[]UnlimitedLong `json:"zoneIds,omitempty"`
}

// UpdateUserDeactivationConfigurationRequestV1 defines model for UpdateUserDeactivationConfigurationRequestV1.
type UpdateUserDeactivationConfigurationRequestV1 struct {
	// IsEnabled Specifies if user deactivation is enabled for this customer.
	IsEnabled bool `json:"isEnabled"`

	// NumberDaysBeforeDeactivation Number of days before inactive users are deactivated.
	NumberDaysBeforeDeactivation DaysInYearInt `json:"numberDaysBeforeDeactivation"`
}

// UpdateUserRequestV1 defines model for UpdateUserRequestV1.
type UpdateUserRequestV1 struct {
	// BypassSsoEnforcement When **True**, the user can bypass SSO enforcement.
	// **Warning:** This allows the user to log in without SSO even when username and password login is disabled.
	// If a field is omitted, its value will be left unchanged.
	BypassSsoEnforcement *bool `json:"bypassSsoEnforcement,omitempty"`

	// FirstName The name of the user.
	FirstName *string `json:"firstName,omitempty"`

	// IsAdmin **True** if the user has Administration permissions.
	IsAdmin *bool `json:"isAdmin,omitempty"`

	// IsEnabled When **True**, the user can bypass SSO enforcement.
	//
	// **Warning:** This allows the user to log in without SSO even when username and password login is disabled.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// LastName The surname of the user.
	LastName *string `json:"lastName,omitempty"`

	// Version The current version of the resource.
	Version UnlimitedLong `json:"version"`
}

// UpdateWebhookIntegrationRequest defines model for UpdateWebhookIntegrationRequest.
type UpdateWebhookIntegrationRequest struct {
	// Channels Data types to forward. Must be compatible with the specified Integration type
	Channels       *IntegrationChannels `json:"channels,omitempty"`
	ConnectionInfo struct {
		// Auth Authentication method
		Auth *UpdateWebhookIntegrationRequestConnectionInfoAuth `json:"auth,omitempty"`

		// CertificateId ID of a certificate stored in Sysdig's [Certificates Management tool](#tag/Certificates). Note that the RFC 5425 (TLS) protocol is required for you to see this field
		CertificateId *int64 `json:"certificateId,omitempty"`

		// Endpoint Webhook endpoint following the schema protocol
		Endpoint string `json:"endpoint"`

		// Headers Extra headers to add to the request. Each header mapping requires 2 keys: 'key' for the header key and 'value' for its value
		Headers *[]KeyValueObject `json:"headers,omitempty"`

		// IsInsecure Skip TLS certificate verification
		IsInsecure *bool `json:"isInsecure,omitempty"`

		// Output Payload format
		Output *UpdateWebhookIntegrationRequestConnectionInfoOutput `json:"output,omitempty"`

		// Secret Secret to use, according to the "auth" value.
		Secret *string `json:"secret,omitempty"`

		// TimestampFormat The resolution of the "timestamp" field in the payload
		TimestampFormat *UpdateWebhookIntegrationRequestConnectionInfoTimestampFormat `json:"timestampFormat,omitempty"`
	} `json:"connectionInfo"`

	// IsEnabled If the forwarding should be enabled or not
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// Name A descriptive name to give to the integration
	Name string `json:"name"`

	// Type The platform to which data will be forwarded
	Type IntegrationType `json:"type"`
}

// UpdateWebhookIntegrationRequestConnectionInfoAuth Authentication method
type UpdateWebhookIntegrationRequestConnectionInfoAuth string

// UpdateWebhookIntegrationRequestConnectionInfoOutput Payload format
type UpdateWebhookIntegrationRequestConnectionInfoOutput string

// UpdateWebhookIntegrationRequestConnectionInfoTimestampFormat The resolution of the "timestamp" field in the payload
type UpdateWebhookIntegrationRequestConnectionInfoTimestampFormat string

// UpdatedAt datetime of last update
type UpdatedAt = string

// UploadCertificateRequest Certificate to be uploaded
type UploadCertificateRequest struct {
	// CertificateFileName The certificate file to be uploaded
	CertificateFileName openapi_types.File `json:"certificateFileName"`

	// Name The name of the certificate that is being uploaded
	Name string `json:"name"`
}

// User The full representation of a User
type User struct {
	Groups *[]string `json:"groups,omitempty"`

	// Username The username of the User
	Username *string `json:"username,omitempty"`
}

// UserDeactivationConfigurationResponseV1 defines model for UserDeactivationConfigurationResponseV1.
type UserDeactivationConfigurationResponseV1 struct {
	// CustomerId The customer Id.
	CustomerId *UnlimitedLong `json:"customerId,omitempty"`

	// IsEnabled Specifies if user deactivation is enabled for this customer.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// NumberDaysBeforeDeactivation Number of days before inactive users are deactivated.
	NumberDaysBeforeDeactivation *DaysInYearInt `json:"numberDaysBeforeDeactivation,omitempty"`
}

// UserResponseV1 defines model for UserResponseV1.
type UserResponseV1 struct {
	// ActivationStatus The current activation status of the user.
	ActivationStatus *string `json:"activationStatus,omitempty"`

	// BypassSsoEnforcement When **True**, the user can bypass SSO enforcement.
	//
	// **Warning:** This allows the user to log in without SSO even when username and password login is disabled.
	BypassSsoEnforcement *bool `json:"bypassSsoEnforcement,omitempty"`

	// DateCreated The date and time when the user was created.
	DateCreated *time.Time `json:"dateCreated,omitempty"`

	// Email The email address of the user.
	Email *string `json:"email,omitempty"`

	// FirstName The name of the user.
	FirstName *string `json:"firstName"`

	Id *UnlimitedLong `json:"id,omitempty"`

	// IsAdmin **True** if the user has Administration permissions.
	IsAdmin *bool `json:"isAdmin,omitempty"`

	// IsEnabled **True** if the user is enabled.
	IsEnabled *bool `json:"isEnabled,omitempty"`

	// LastName The last name of the user.
	LastName *string `json:"lastName"`

	// LastUpdated The date and time when the user was last updated.
	LastUpdated *time.Time `json:"lastUpdated"`

	// Version The current version of the resource.
	Version *UnlimitedLong `json:"version,omitempty"`
}

// VulnAge Predicate expressing "the Vulnerability is older than <age> days"
type VulnAge struct {
	Extra struct {
		// Age The age of the vulnerability in days.
		Age *int32 `json:"age,omitempty"`
	} `json:"extra"`
	Type VulnAgeType `json:"type"`
}

// VulnAgeType defines model for VulnAge.Type.
type VulnAgeType string

// VulnCvss Predicate expressing "the Vulnerability CVSS Score is higher than <value>"
type VulnCvss struct {
	Extra struct {
		// Value The threshold for greater-than-or-equal comparison with CVSS Score.
		Value *float32 `json:"value,omitempty"`
	} `json:"extra"`
	Type VulnCvssType `json:"type"`
}

// VulnCvssType defines model for VulnCvss.Type.
type VulnCvssType string

// VulnCvssEquals Predicate expressing "the Vulnerability CVSS Score is exactly equal to <value>"
type VulnCvssEquals struct {
	Extra struct {
		// Value The threshold for equality comparison with the CVSS Score.
		Value *float32 `json:"value,omitempty"`
	} `json:"extra"`
	Type VulnCvssEqualsType `json:"type"`
}

// VulnCvssEqualsType defines model for VulnCvssEquals.Type.
type VulnCvssEqualsType string

// VulnDisclosureRange The start and end dates (inclusive) when vulnerabilities were disclosed.
type VulnDisclosureRange struct {
	Extra struct {
		// EndDate The end date (inclusive) of disclosed vulnerabilities.
		EndDate *openapi_types.Date `json:"endDate,omitempty"`

		// StartDate The start date (inclusive) of disclosed vulnerabilities.
		StartDate *openapi_types.Date `json:"startDate,omitempty"`
	} `json:"extra"`
	Type VulnDisclosureRangeType `json:"type"`
}

// VulnDisclosureRangeType defines model for VulnDisclosureRange.Type.
type VulnDisclosureRangeType string

// VulnEpssPercentileGte The EPSS percentile score that is greater than or equal to the specified value.
type VulnEpssPercentileGte struct {
	Extra struct {
		// Percentile Percentile value to compare.
		Percentile *int32 `json:"percentile,omitempty"`
	} `json:"extra"`
	Type VulnEpssPercentileGteType `json:"type"`
}

// VulnEpssPercentileGteType defines model for VulnEpssPercentileGte.Type.
type VulnEpssPercentileGteType string

// VulnEpssScoreGte The EPSS score that meets or exceeds the specified threshold value.
type VulnEpssScoreGte struct {
	Extra struct {
		// Score Score value to compare.
		Score *int32 `json:"score,omitempty"`
	} `json:"extra"`
	Type VulnEpssScoreGteType `json:"type"`
}

// VulnEpssScoreGteType defines model for VulnEpssScoreGte.Type.
type VulnEpssScoreGteType string

// VulnExploitable Predicate expressing "the Vulnerability is exploitable".
type VulnExploitable struct {
	Type VulnExploitableType `json:"type"`
}

// VulnExploitableType defines model for VulnExploitable.Type.
type VulnExploitableType string

// VulnExploitableNoAdmin Predicate expressing "the Vulnerability is exploitable and the exploit does not. require admin privileges"
type VulnExploitableNoAdmin struct {
	Type VulnExploitableNoAdminType `json:"type"`
}

// VulnExploitableNoAdminType defines model for VulnExploitableNoAdmin.Type.
type VulnExploitableNoAdminType string

// VulnExploitableNoUser Predicate expressing "the Vulnerability is exploitable and the exploit does not. require user interaction"
type VulnExploitableNoUser struct {
	Type VulnExploitableNoUserType `json:"type"`
}

// VulnExploitableNoUserType defines model for VulnExploitableNoUser.Type.
type VulnExploitableNoUserType string

// VulnExploitableViaNetwork Predicate expressing "the Vulnerability is exploitable via network".
type VulnExploitableViaNetwork struct {
	Type VulnExploitableViaNetworkType `json:"type"`
}

// VulnExploitableViaNetworkType defines model for VulnExploitableViaNetwork.Type.
type VulnExploitableViaNetworkType string

// VulnExploitableWithAge Predicate expressing "the Vulnerability is exploitable and the exploit is older. than <age> days"
type VulnExploitableWithAge struct {
	Extra struct {
		// Age The age of the exploit in days
		Age *int32 `json:"age,omitempty"`
	} `json:"extra"`
	Type VulnExploitableWithAgeType `json:"type"`
}

// VulnExploitableWithAgeType defines model for VulnExploitableWithAge.Type.
type VulnExploitableWithAgeType string

// VulnIsFixable Predicate expressing "the Vulnerability is Fixable".
type VulnIsFixable struct {
	Type VulnIsFixableType `json:"type"`
}

// VulnIsFixableType defines model for VulnIsFixable.Type.
type VulnIsFixableType string

// VulnIsFixableWithAge Predicate expressing "the Vulnerability is Fixable and its fix is older than <age> days".
type VulnIsFixableWithAge struct {
	Extra struct {
		// Age The age of the fix in days
		Age *int32 `json:"age,omitempty"`
	} `json:"extra"`
	Type VulnIsFixableWithAgeType `json:"type"`
}

// VulnIsFixableWithAgeType defines model for VulnIsFixableWithAge.Type.
type VulnIsFixableWithAgeType string

// VulnIsInUse The vulnerable resources currently in use.
type VulnIsInUse struct {
	Type VulnIsInUseType `json:"type"`
}

// VulnIsInUseType defines model for VulnIsInUse.Type.
type VulnIsInUseType string

// VulnPkgType Predicate expressing "the Vulnerability is related to a package of <type>".
type VulnPkgType struct {
	Extra struct {
		// PkgType The package type, either OS or non-OS. There is no enforcement on the value for future extensibility.
		PkgType VulnPkgTypeExtraPkgType `json:"pkgType"`
	} `json:"extra"`
	Type VulnPkgTypeType `json:"type"`
}

// VulnPkgTypeExtraPkgType The package type, either OS or non-OS. There is no enforcement on the value for future extensibility.
type VulnPkgTypeExtraPkgType string

// VulnPkgTypeType defines model for VulnPkgType.Type.
type VulnPkgTypeType string

// VulnSeverity Predicate expressing "the Vulnerability Severity is <level> or higher".
type VulnSeverity struct {
	Extra struct {
		Level *VulnSeverityExtraLevel `json:"level,omitempty"`
	} `json:"extra"`
	Type VulnSeverityType `json:"type"`
}

// VulnSeverityExtraLevel defines model for VulnSeverity.Extra.Level.
type VulnSeverityExtraLevel string

// VulnSeverityType defines model for VulnSeverity.Type.
type VulnSeverityType string

// VulnSeverityEquals Predicate expressing "the Vulnerability Severity is exactly <level>".
type VulnSeverityEquals struct {
	Extra struct {
		Level *VulnSeverityEqualsExtraLevel `json:"level,omitempty"`
	} `json:"extra"`
	Type VulnSeverityEqualsType `json:"type"`
}

// VulnSeverityEqualsExtraLevel defines model for VulnSeverityEquals.Extra.Level.
type VulnSeverityEqualsExtraLevel string

// VulnSeverityEqualsType defines model for VulnSeverityEquals.Type.
type VulnSeverityEqualsType string

// VulnTotalBySeverity total vulnerabilities by severity
type VulnTotalBySeverity struct {
	// Critical number of critical vulnerabilities
	Critical *int `json:"critical,omitempty"`

	// High number of high severity vulnerabilities
	High *int `json:"high,omitempty"`

	// Low number of low severity vulnerabilities
	Low *int `json:"low,omitempty"`

	// Medium number of medium severity vulnerabilities
	Medium *int `json:"medium,omitempty"`

	// Negligible number of negligible severity vulnerabilities
	Negligible *int `json:"negligible,omitempty"`
}

// Vulnerability defines model for Vulnerability.
type Vulnerability struct {
	CisaKev        *map[string]interface{} `json:"cisaKev,omitempty"`
	CvssScore      CvssScore               `json:"cvssScore"`
	DisclosureDate *openapi_types.Date     `json:"disclosureDate,omitempty"`
	Exploit        *Exploit                `json:"exploit,omitempty"`
	Exploitable    bool                    `json:"exploitable"`
	FixVersion     *string                 `json:"fixVersion,omitempty"`
	MainProvider   *string                 `json:"mainProvider,omitempty"`
	Name           string                  `json:"name"`

	// PackageRef reference to the affected package
	PackageRef        *string                 `json:"packageRef,omitempty"`
	ProvidersMetadata *map[string]interface{} `json:"providersMetadata"`
	RiskAcceptRefs    *[]string               `json:"riskAcceptRefs"`
	Severity          VulnerabilitySeverity   `json:"severity"`
	SolutionDate      *openapi_types.Date     `json:"solutionDate,omitempty"`
}

// VulnerabilitySeverity defines model for Vulnerability.Severity.
type VulnerabilitySeverity string

// VulnerabilityManagementPage API paging response
type VulnerabilityManagementPage struct {
	// Next Next cursor for pagination
	Next *string `json:"next,omitempty"`

	// Total Total of scans
	Total *int `json:"total,omitempty"`
}

// VulnerabilitySummary Vulnerability summary of a resource
type VulnerabilitySummary struct {
	// CriticalSeverityCount Number of critical severity vulnerabilities
	CriticalSeverityCount int32 `json:"criticalSeverityCount"`

	// HasExploit Indicates if a resource has an exploit
	HasExploit bool `json:"hasExploit"`

	// HighSeverityCount Number of high severity vulnerabilities
	HighSeverityCount int32 `json:"highSeverityCount"`

	// LowSeverityCount Number of low severity vulnerabilities
	LowSeverityCount int32 `json:"lowSeverityCount"`

	// MediumSeverityCount Number of medium severity vulnerabilities
	MediumSeverityCount int32 `json:"mediumSeverityCount"`

	// NegligibleSeverityCount Number of negligible severity vulnerabilities
	NegligibleSeverityCount int32 `json:"negligibleSeverityCount"`
}

// WastedWorkloadDataRequest defines model for WastedWorkloadDataRequest.
type WastedWorkloadDataRequest struct {
	DateRange struct {
		// EndDate The end of the date range.
		EndDate openapi_types.Date `json:"endDate"`

		// StartDate The beginning of the date range.
		StartDate openapi_types.Date `json:"startDate"`
	} `json:"dateRange"`

	// GroupBy Specifies Prometheus labels to group the report data by.
	// By default, the following labels will always be included:
	//   - kube_cluster_name
	//   - kube_namespace_name
	//   - kube_workload_name
	// A maximum of 7 additional custom labels can be specified.
	GroupBy *[]PrometheusLabel `json:"groupBy,omitempty"`

	// Scope A list of PromQL-style filters
	Scope *[]PromqlMatcher `json:"scope,omitempty"`
}

// WastedWorkloadSpendDataResponse Aggregated and grouped cost data representing Wasted Workload Spend over a specific date range.
type WastedWorkloadSpendDataResponse struct {
	// GroupByData Grouped cost data for each combination of Prometheus label values.
	GroupByData *[]struct {
		// Accrued Accrued cost for this group.
		Accrued *float64 `json:"accrued,omitempty"`

		// Estimated Estimated cost for this group.
		Estimated *float64 `json:"estimated,omitempty"`

		// Group Key-value pairs representing grouping labels.
		Group *map[string]string `json:"group,omitempty"`

		// Wasted Wasted cost for this group.
		Wasted *float64 `json:"wasted,omitempty"`
	} `json:"groupByData,omitempty"`

	// Total Aggregated cost values for the specified time range.
	Total *struct {
		// Accrued Total cost accrued during the reporting period.
		Accrued *float64 `json:"accrued,omitempty"`

		// Estimated Estimated efficient cost during the reporting period.
		Estimated *float64 `json:"estimated,omitempty"`

		// Wasted Difference between accrued and estimated cost.
		Wasted *float64 `json:"wasted,omitempty"`
	} `json:"total,omitempty"`
}

// WorkloadCostTrendsDataRequest defines model for WorkloadCostTrendsDataRequest.
type WorkloadCostTrendsDataRequest struct {
	// Date The reference date used to define the time window for cost trend calculation.
	// When combined with `trendRangeInDays`, this date represents the inclusive upper bound
	// of the time range  the trend is calculated from (`date - trendRangeInDays`).
	// For example, if `date` is 2025-02-12 and `trendRangeInDays` is 10, the time range
	// used for calculation is from 2025-02-03 to 2025-02-12 (inclusive).
	// Must be in YYYY-MM-DD format.
	Date    openapi_types.Date `json:"date"`
	GroupBy *[]PrometheusLabel `json:"groupBy,omitempty"`

	// Scope A list of PromQL-style filters
	Scope *[]PromqlMatcher `json:"scope,omitempty"`

	// TrendRangeInDays Specifies the number of days used to calculate and extract cost data.
	// Must be a positive integer.
	TrendRangeInDays float32 `json:"trendRangeInDays"`
}

// WorkloadCostTrendsDataResponse Cost trends observed between two consecutive time periods in the past.
type WorkloadCostTrendsDataResponse struct {
	CurrentRange *struct {
		// EndDate The end of the date range.
		EndDate openapi_types.Date `json:"endDate"`

		// StartDate The beginning of the date range.
		StartDate openapi_types.Date `json:"startDate"`
	} `json:"currentRange,omitempty"`

	// GroupByData Grouped cost data for each combination of label values.
	GroupByData *[]struct {
		// Change The difference in cost between current and previous ranges for this group.
		Change *float64 `json:"change,omitempty"`

		// Current The cost for the current range within this group.
		Current *float64 `json:"current,omitempty"`

		// Group Key-value pairs representing the grouping labels.
		Group *map[string]string `json:"group,omitempty"`

		// Previous The cost for the previous range within this group.
		Previous *float64 `json:"previous,omitempty"`
	} `json:"groupByData,omitempty"`
	PreviousRange *struct {
		// EndDate The end of the date range.
		EndDate openapi_types.Date `json:"endDate"`

		// StartDate The beginning of the date range.
		StartDate openapi_types.Date `json:"startDate"`
	} `json:"previousRange,omitempty"`

	// Total Aggregated cost values for the current and previous ranges.
	Total *struct {
		// Change The difference between the current and the previous cost periods expressed in percentages.
		Change *float64 `json:"change,omitempty"`

		// Current The total cost for the current range.
		Current *float64 `json:"current,omitempty"`

		// Previous The total cost for the previous range.
		Previous *float64 `json:"previous,omitempty"`
	} `json:"total,omitempty"`
}

// WorkloadMlRuntimeDetectionContent defines model for WorkloadMlRuntimeDetectionContent.
type WorkloadMlRuntimeDetectionContent struct {
	// Command The command name
	Command string `json:"command"`

	// DetectedClassProbability The detected class probability (confidence score)
	DetectedClassProbability float32 `json:"detectedClassProbability"`

	// Exe The command path
	Exe string `json:"exe"`

	// PolicyId ID of the policy that generated the event
	PolicyId PolicyId `json:"policyId"`

	// Type The type of the event content.
	Type EventContentType `json:"type"`
}

// WorkloadRightsizingDataRequest defines model for WorkloadRightsizingDataRequest.
type WorkloadRightsizingDataRequest struct {
	// Algorithm Aggregation algorithm used for rightsizing analysis. Currently supported values are:
	// - AVG
	// - P95
	// - MAX
	// This field is case-sensitive and may support more values in the future.
	Algorithm string `json:"algorithm"`
	DateRange struct {
		// EndDate The end of the date range.
		EndDate openapi_types.Date `json:"endDate"`

		// StartDate The beginning of the date range.
		StartDate openapi_types.Date `json:"startDate"`
	} `json:"dateRange"`

	// Scope A list of PromQL-style filters
	Scope *[]PromqlMatcher `json:"scope,omitempty"`
}

// WorkloadRightsizingDataResponse Cost data representing Workload Rightsizing over a specific date range.
type WorkloadRightsizingDataResponse struct {
	// GroupByData Grouped workload rightsizing data by cluster, namespace, workload, and container.
	GroupByData *[]struct {
		// Group Key-value pairs representing the logical grouping keys.
		//
		// The data is grouped by the following dimensions:
		// - cluster
		// - namespace
		// - workload
		// - container
		Group *map[string]string `json:"group,omitempty"`

		// MonthlyCost Estimated current monthly cost in USD.
		MonthlyCost *float64 `json:"monthlyCost,omitempty"`

		// MonthlyPotentialSavings Estimated potential monthly savings in USD.
		MonthlyPotentialSavings *float64 `json:"monthlyPotentialSavings,omitempty"`

		// NumberOfPods Number of pods currently running in the workload.
		NumberOfPods *int32 `json:"numberOfPods,omitempty"`

		// RequestedCpu CPU requested by the container (in milicores).
		RequestedCpu *float64 `json:"requestedCpu,omitempty"`

		// RequestedMemory Memory requested by the container (in MiB).
		RequestedMemory *float64 `json:"requestedMemory,omitempty"`

		// SuggestedCpu Suggested CPU allocation (in milicores).
		SuggestedCpu *float64 `json:"suggestedCpu,omitempty"`

		// SuggestedMemory Suggested memory allocation (in MiB).
		SuggestedMemory *float64 `json:"suggestedMemory,omitempty"`

		// WorkloadType Type of Kubernetes workload.
		// Possible values include:
		// - Deployment
		// - StatefulSet
		// - DaemonSet
		// - Job
		// - CronJob
		// - ReplicaSet
		// - ReplicationController
		WorkloadType *string `json:"workloadType,omitempty"`
	} `json:"groupByData,omitempty"`
}

// WorkloadRuntimeDetectionContent defines model for WorkloadRuntimeDetectionContent.
type WorkloadRuntimeDetectionContent struct {
	Fields map[string]string `json:"fields"`

	// Origin The policy author:
	// - `Sysdig` - default and managed policies
	// - `Sysdig UI` - users interacting with Sysdig
	// - `Tuner` - the automated tuner
	Origin *PolicyOrigin `json:"origin,omitempty"`

	// Output Event output, generated after the configured rule
	Output string `json:"output"`

	// PolicyId ID of the policy that generated the event
	PolicyId PolicyId `json:"policyId"`

	// RuleName Name of the rule the event is generated after
	RuleName RuleName `json:"ruleName"`

	// RuleSubType Rule subtype:
	// - 1 - List matching - network - inbound
	// - 2 - List matching - network - outbound
	// - 3 - List matching - network - listening
	// - 4 - List matching - file - readwrite
	// - 5 - List matching - file - read only
	RuleSubType RuleSubType `json:"ruleSubType"`

	// RuleTags The tags attached to the rule
	RuleTags RuleTags `json:"ruleTags"`

	// RuleType Rule type:
	// - 1 - List matching - process
	// - 2 - List matching - container
	// - 3 - List matching - file
	// - 4 - List matching - network
	// - 5 - List matching - syscall
	// - 6 - Falco
	// - 7 - Drift detection
	// - 8 - Malware detection
	// - 11 - ML - Cryptominer detection
	// - 13 - ML - AWS anomalous login
	// - 14 - ML - Okta anomalous login
	RuleType RuleType `json:"ruleType"`

	// RunBook The runbook URL as configured in the policy.
	RunBook *string `json:"runBook,omitempty"`

	// Type The type of the event content.
	Type EventContentType `json:"type"`
}

// Zone A collection of scopes representing business areas.
type Zone struct {
	// ZoneId Zone ID
	ZoneId *ZoneId `json:"zoneId,omitempty"`

	// ZoneName Zone name
	ZoneName string `json:"zoneName"`
}

// ZoneId Zone ID
type ZoneId = int64

// ZoneResponseV1 defines model for ZoneResponseV1.
type ZoneResponseV1 struct {
	// Author Email of the user who created this Zone
	Author *string `json:"author,omitempty"`

	// Description The description of the Zone
	Description *string `json:"description,omitempty"`

	Id *UnlimitedLong `json:"id,omitempty"`

	// IsSystem Boolean value indicating if the Zone is a *System* one
	IsSystem *bool `json:"isSystem,omitempty"`

	// LastModifiedBy Email of the user who last modified the Zone
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// LastUpdated Timestamp indicating the moment the Zone has been last updated.\
	// It is expressed in milliseconds elapsed since January 1, 1970 UTC.
	LastUpdated *UnlimitedLong `json:"lastUpdated,omitempty"`

	// Name The name of the Zone
	Name *string `json:"name,omitempty"`

	// Scopes Attached Zone Scopes
	Scopes *[]ZoneScope `json:"scopes,omitempty"`
}

// ZoneScope defines model for ZoneScope.
type ZoneScope struct {
	Id *UnlimitedLong `json:"id,omitempty"`

	// Rules Scoping rules to be applied
	Rules *string `json:"rules,omitempty"`

	// TargetType The target type of the Scope
	TargetType string `json:"targetType"`
}

type AccessKeyIdPath = UnlimitedLong

// ActionExecutionId defines model for ActionExecutionId.
type ActionExecutionId = string

// Enabled defines model for Enabled.
type Enabled = bool

// EventId defines model for EventId.
type EventId = string

// Filter defines model for Filter.
type Filter = string

type GroupMappingIdPath = UnlimitedLong

type InhibitionRulePath = UnlimitedLong

// IntegrationId defines model for IntegrationId.
type IntegrationId = int64

type IpFilterIdPath = UnlimitedLong

type IssueTypeID = UnlimitedLong

type IntegrationID = UnlimitedLong

// JobNamePath defines model for JobNamePath.
type JobNamePath = string

// Limit defines model for Limit.
type Limit = int32

// MultiFilter defines model for MultiFilter.
type MultiFilter = []string

// MultiOrderBy defines model for MultiOrderBy.
type MultiOrderBy = []string

type NotificationChannelID = UnlimitedLong

// Offset defines model for Offset.
type Offset = int32

// OrderBy defines model for OrderBy.
type OrderBy = string

// PathCertificateId defines model for PathCertificateId.
type PathCertificateId = string

// PermissionsFilter defines model for PermissionsFilter.
type PermissionsFilter = string

type PricingIdPath = UnlimitedLong

// RoleDisplayNamePath defines model for RoleDisplayNamePath.
type RoleDisplayNamePath string

type RoleIdPath = UnlimitedLong

type ServiceAccountIdPath = UnlimitedLong

// SsoProductIdPath defines model for SsoProductIdPath.
type SsoProductIdPath string

type SsoSettingsIdPath = UnlimitedLong

type TeamIdPath = UnlimitedLong

type UserIdPath = UnlimitedLong

// AcceptedRiskID defines model for acceptedRiskID.
type AcceptedRiskID = string

// Order defines model for order.
type Order string

// VulnerabilityCursor defines model for vulnerabilityCursor.
type VulnerabilityCursor = string

// VulnerabilityFilter defines model for vulnerabilityFilter.
type VulnerabilityFilter = string

// BadRequest defines model for BadRequest.
type BadRequest = Error

// Conflict defines model for Conflict.
type Conflict = Error

// Forbidden defines model for Forbidden.
type Forbidden = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// NotFound defines model for NotFound.
type NotFound = Error

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// UnprocessableEntity defines model for UnprocessableEntity.
type UnprocessableEntity = Error

// UnsupportedMediaType defines model for UnsupportedMediaType.
type UnsupportedMediaType = Error

// QuerySysqlGetParams defines parameters for QuerySysqlGet.
type QuerySysqlGetParams struct {
	// Q The SysQL statement.
	Q                  string `form:"q" json:"q"`
	Limit              *int32 `form:"limit,omitempty" json:"limit,omitempty"`
	Offset             *int32 `form:"offset,omitempty" json:"offset,omitempty"`
	DeterministicOrder *bool  `form:"deterministic_order,omitempty" json:"deterministic_order,omitempty"`
}

// QuerySysqlPostJSONBody defines parameters for QuerySysqlPost.
type QuerySysqlPostJSONBody struct {
	// DeterministicOrder The deterministic_order parameter controls whether consistent ordering is enforced in the result set.
	// Ordering is implicitly applied when pagination options, such as limit and offset, are specified in the
	// request. This is an optional parameter.
	DeterministicOrder *bool `json:"deterministic_order,omitempty"`

	// Limit The limit parameter defines the maximum number of items returned in the result set, specifically
	// within the items array in the response.
	//
	// This parameter is optional. The recommended approach is to define the limit directly in the SysQL
	// statement using the LIMIT clause. If specified in the request body, it will override the limit set
	// in the statement. If not specified, a default limit of 50 will be applied.
	Limit *int32 `json:"limit,omitempty"`

	// Offset The offset parameter specifies how many result set objects to skip in a MATCH statement. Use it when
	// you want to ignore the first few items in the result set.
	//
	// This parameter is optional. The recommended approach is to set the offset directly in the SysQL
	// statement using the OFFSET clause. If specified in the request body, it will override the offset
	// in the statement. If not specified, a default offset of 0 will be applied.
	//
	// Use limit and offset together in SysQL to paginate results, splitting them into pages with a defined
	// number of items for display.
	Offset *int32 `json:"offset,omitempty"`

	// Q The SysQL statement.
	Q string `json:"q"`
}

// GetInhibitionRulesParams defines parameters for GetInhibitionRules.
type GetInhibitionRulesParams struct {
	// Offset The offset number of items to start with
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPricingV1Params defines parameters for GetPricingV1.
type GetPricingV1Params struct {
	// Offset The offset number of items to start with
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// ClusterName The name of the Kubernetes cluster for which you want to retrive the pricing.
	ClusterName *string `form:"clusterName,omitempty" json:"clusterName,omitempty"`

	// Type The type of pricing to find.
	Type *PricingType `form:"type,omitempty" json:"type,omitempty"`
}

// GetPricingProjectedCostsV1Params defines parameters for GetPricingProjectedCostsV1.
type GetPricingProjectedCostsV1Params struct {
	// Offset The offset number of items to start with
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetMonitorEventsV1Params defines parameters for GetMonitorEventsV1.
type GetMonitorEventsV1Params struct {
	From   *MonitorEventsFrom   `form:"from,omitempty" json:"from,omitempty"`
	To     *MonitorEventsTo     `form:"to,omitempty" json:"to,omitempty"`
	Cursor *MonitorEventsCursor `form:"cursor,omitempty" json:"cursor,omitempty"`
	Filter *MonitorEventsFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit The number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetDisabledMetricsByJobV1Params defines parameters for GetDisabledMetricsByJobV1.
type GetDisabledMetricsByJobV1Params struct {
	// JobName The name of the Prometheus Job whose excluded metrics are to be listed.
	JobName *string `form:"jobName,omitempty" json:"jobName,omitempty"`

	// MetricName The exact name of the metric to be filtered.
	MetricName *string `form:"metricName,omitempty" json:"metricName,omitempty"`
}

// GetCustomPrometheusJobsV1Params defines parameters for GetCustomPrometheusJobsV1.
type GetCustomPrometheusJobsV1Params struct {
	// Offset The offset number of items to start with
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetJiraIntegrationsV1Params defines parameters for GetJiraIntegrationsV1.
type GetJiraIntegrationsV1Params struct {
	// Limit The number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The offset number of items to start with
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Enabled Enabled status of the integration
	Enabled *Enabled `form:"enabled,omitempty" json:"enabled,omitempty"`
}

// ListJobsV1Params defines parameters for ListJobsV1.
type ListJobsV1Params struct {
	// ScheduleId ID of the Schedule
	ScheduleId string `form:"scheduleId" json:"scheduleId"`

	// ReportId ID of the Report
	ReportId *int64 `form:"reportId,omitempty" json:"reportId,omitempty"`

	// IsReportTemplate Indicates whether the report is a template.
	IsReportTemplate *ListJobsV1ParamsIsReportTemplate `form:"isReportTemplate,omitempty" json:"isReportTemplate,omitempty"`

	// CompletedOn Date the job was completed in epoch milliseconds.
	CompletedOn *UnlimitedLong `form:"completedOn,omitempty" json:"completedOn,omitempty"`

	// JobType Type of the job.
	JobType *ListJobsV1ParamsJobType `form:"jobType,omitempty" json:"jobType,omitempty"`

	// Status Status of the job.
	Status *ListJobsV1ParamsStatus `form:"status,omitempty" json:"status,omitempty"`

	// Kind Kind of the report.
	Kind *ListJobsV1ParamsKind `form:"kind,omitempty" json:"kind,omitempty"`

	// Policies List of policy IDs in string format.
	Policies *string `form:"policies,omitempty" json:"policies,omitempty"`

	// Zones List of zone IDs in string format.
	Zones *string `form:"zones,omitempty" json:"zones,omitempty"`
}

// ListJobsV1ParamsIsReportTemplate defines parameters for ListJobsV1.
type ListJobsV1ParamsIsReportTemplate string

// ListJobsV1ParamsJobType defines parameters for ListJobsV1.
type ListJobsV1ParamsJobType string

// ListJobsV1ParamsStatus defines parameters for ListJobsV1.
type ListJobsV1ParamsStatus string

// ListJobsV1ParamsKind defines parameters for ListJobsV1.
type ListJobsV1ParamsKind string

// GetAccessKeysV1Params defines parameters for GetAccessKeysV1.
type GetAccessKeysV1Params struct {
	// Offset The offset number of items to start with
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Orderby The order by field separated by a colon for the direction
	Orderby *OrderBy `form:"orderby,omitempty" json:"orderby,omitempty"`

	// Filter Filters to apply in the form of `key:value`.\
	// Multiple filters can be applied by repeating the `filter` parameter:\
	// `&filter=key1:value1&filter=key2:value2`
	Filter *MultiFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetDefaultRoleByDisplayNameV1ParamsRoleDisplayName defines parameters for GetDefaultRoleByDisplayNameV1.
type GetDefaultRoleByDisplayNameV1ParamsRoleDisplayName string

// GetGlobaSsoSettingsV1ParamsSsoProductId defines parameters for GetGlobaSsoSettingsV1.
type GetGlobaSsoSettingsV1ParamsSsoProductId string

// UpdateGlobalSsoSettingsV1ParamsSsoProductId defines parameters for UpdateGlobalSsoSettingsV1.
type UpdateGlobalSsoSettingsV1ParamsSsoProductId string

// GetGroupMappingsV1Params defines parameters for GetGroupMappingsV1.
type GetGroupMappingsV1Params struct {
	// Offset The offset number of items to start with
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Orderby The order by field separated by a colon for the direction
	Orderby *OrderBy `form:"orderby,omitempty" json:"orderby,omitempty"`

	// Filter The filter by field separated by a colon for the filter value
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetIpFiltersV1Params defines parameters for GetIpFiltersV1.
type GetIpFiltersV1Params struct {
	// Offset The offset number of items to start with
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Filter The filter by field separated by a colon for the filter value
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetNotificationChannelsParams defines parameters for GetNotificationChannels.
type GetNotificationChannelsParams struct {
	// Offset The offset number of items to start with
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPermissionsV1Params defines parameters for GetPermissionsV1.
type GetPermissionsV1Params struct {
	// Filter Filter by products when getting permissions for custom roles.\
	// Avaliable products are: SDS, SDC.\
	// You can specify a single product or a list of products separated by commas.\
	// Product names are case-sensitive.\
	// If not specified, all permissions are returned.
	Filter *PermissionsFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetPlatformAuditEventsV1Params defines parameters for GetPlatformAuditEventsV1.
type GetPlatformAuditEventsV1Params struct {
	From   *From                  `form:"from,omitempty" json:"from,omitempty"`
	To     *To                    `form:"to,omitempty" json:"to,omitempty"`
	Cursor *Cursor                `form:"cursor,omitempty" json:"cursor,omitempty"`
	Filter *AuditEventsFeedFilter `form:"filter,omitempty" json:"filter,omitempty"`
	Limit  *AuditEventsFeedLimit  `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetRolesV1Params defines parameters for GetRolesV1.
type GetRolesV1Params struct {
	// Offset The offset number of items to start with
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Orderby The order by field separated by a colon for the direction
	Orderby *OrderBy `form:"orderby,omitempty" json:"orderby,omitempty"`

	// Filter The filter by field separated by a colon for the filter value
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetGlobalServiceAccountsV1Params defines parameters for GetGlobalServiceAccountsV1.
type GetGlobalServiceAccountsV1Params struct {
	// Offset The offset number of items to start with
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Orderby The order by field separated by a colon for the direction
	Orderby *OrderBy `form:"orderby,omitempty" json:"orderby,omitempty"`

	// Filter Filters to apply in the form of `key:value`.\
	// Multiple filters can be applied by repeating the `filter` parameter:\
	// `&filter=key1:value1&filter=key2:value2`
	Filter *MultiFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetSsoSettingsV1Params defines parameters for GetSsoSettingsV1.
type GetSsoSettingsV1Params struct {
	// Filter The filter by field separated by a colon for the filter value
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetTeamsV1Params defines parameters for GetTeamsV1.
type GetTeamsV1Params struct {
	// Offset The offset number of items to start with
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Orderby The order by field separated by a colon for the direction
	Orderby *OrderBy `form:"orderby,omitempty" json:"orderby,omitempty"`

	// Filter The filter by field separated by a colon for the filter value
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetTeamServiceAccountsV1Params defines parameters for GetTeamServiceAccountsV1.
type GetTeamServiceAccountsV1Params struct {
	// Offset The offset number of items to start with
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Orderby The order by field separated by a colon for the direction
	Orderby *OrderBy `form:"orderby,omitempty" json:"orderby,omitempty"`

	// Filter Filters to apply in the form of `key:value`.\
	// Multiple filters can be applied by repeating the `filter` parameter:\
	// `&filter=key1:value1&filter=key2:value2`
	Filter *MultiFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetTeamUsersV1Params defines parameters for GetTeamUsersV1.
type GetTeamUsersV1Params struct {
	// Offset The offset number of items to start with
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// WithAdminUsers Include admin users in the response.
	WithAdminUsers *bool `form:"withAdminUsers,omitempty" json:"withAdminUsers,omitempty"`
}

// GetUsersV1Params defines parameters for GetUsersV1.
type GetUsersV1Params struct {
	// Offset The offset number of items to start with
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Orderby The order by field separated by a colon for the direction
	Orderby *OrderBy `form:"orderby,omitempty" json:"orderby,omitempty"`

	// Filter The filter by field separated by a colon for the filter value
	Filter *Filter `form:"filter,omitempty" json:"filter,omitempty"`
}

// CreateUserV1Params defines parameters for CreateUserV1.
type CreateUserV1Params struct {
	// ActivationFlow The activation flow is used to send an invitation email to the user that is being created.\
	// \
	// **NOTE: it is required to set at least one product in the payload in order to send the appropriate email.**
	ActivationFlow *bool `form:"activationFlow,omitempty" json:"activationFlow,omitempty"`
}

// ListZonesV1Params defines parameters for ListZonesV1.
type ListZonesV1Params struct {
	// Filter Filters to apply in the form of `key:value`.\
	// Multiple filters can be applied by repeating the `filter` parameter:\
	// `&filter=key1:value1&filter=key2:value2`
	Filter *MultiFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit The number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The offset number of items to start with
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// Orderby Ordering to apply in the form of `field:direction` where `direction` can either be `asc` or `desc`.\
	// Multiple orderings can be applied by repeating the `orderby` parameter:\
	// `&orderby=key1:direction1&orderby=key2:direction2`
	Orderby *MultiOrderBy `form:"orderby,omitempty" json:"orderby,omitempty"`
}

// GetActivityAuditEntriesV1Params defines parameters for GetActivityAuditEntriesV1.
type GetActivityAuditEntriesV1Params struct {
	From   *From                      `form:"from,omitempty" json:"from,omitempty"`
	To     *To                        `form:"to,omitempty" json:"to,omitempty"`
	Cursor *Cursor                    `form:"cursor,omitempty" json:"cursor,omitempty"`
	Zones  *[]ZoneId                  `form:"zones,omitempty" json:"zones,omitempty"`
	Filter *SysdigQueryLanguageFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit The number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
	Types *Types `form:"types,omitempty" json:"types,omitempty"`
}

// ListEFOChannelsByIntegrationV1Params defines parameters for ListEFOChannelsByIntegrationV1.
type ListEFOChannelsByIntegrationV1Params struct {
	// Type the Events Forwarder Integration Type
	Type IntegrationType `form:"type" json:"type"`
}

// ListEFOChannelsByIntegrationV2Params defines parameters for ListEFOChannelsByIntegrationV2.
type ListEFOChannelsByIntegrationV2Params struct {
	// Type the Events Forwarder Integration Type
	Type IntegrationType `form:"type" json:"type"`
}

// GetEventsV1Params defines parameters for GetEventsV1.
type GetEventsV1Params struct {
	From   *From             `form:"from,omitempty" json:"from,omitempty"`
	To     *To               `form:"to,omitempty" json:"to,omitempty"`
	Cursor *Cursor           `form:"cursor,omitempty" json:"cursor,omitempty"`
	Zones  *[]ZoneId         `form:"zones,omitempty" json:"zones,omitempty"`
	Filter *EventsFeedFilter `form:"filter,omitempty" json:"filter,omitempty"`
	Limit  *EventsFeedLimit  `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetResourcesParams defines parameters for GetResources.
type GetResourcesParams struct {
	// Filter Query language expression for filtering results.
	// Operators:
	// - `and` and `not` logical operators
	// - `=`, `!=`
	// - `in`
	// - `contains` and `startsWith` to check partial values of attributes
	// - `exists` to check if a field exists and not empty
	//
	// List of supported fields:
	// - `account`
	//   - Type: string
	//   - Example: `account in ("285211435247")`
	//   - Description: DEPRECATED. The account that will be included in the results.
	// - `accountName`
	//   - Type: string
	//   - Example: `accountName in ("some-account-name")`
	//   - Description: The account name that will be included in the results.
	// - `accountId`
	//   - Type: string
	//   - Example: `accountId in ("345224567")`
	//   - Description: The account id that will be included in the results.
	// - `cluster`
	//   - Type: string
	//   - Example: `cluster in ("cluster1")`
	//   - Description: The kubernetes cluster that will be included in the results.
	// - `externalDNS`
	//   - Type: string
	//   - Example: `externalDNS in ("ec2-102-34-15-23.compute-1.amazonaws.com")`
	//   - Description: The external DNS that will be included in the results.
	// - `distribution`
	//   - Type: string
	//   - Example: `distribution in ("gke", "vanilla")`
	//   - Description: The kubernetes distribution that will be included in the results.
	// - `integrationName`
	//   - Type: string
	//   - Example: `integrationName = "github-integration"`
	//   - Description: The name of the integration an IaC resource belongs to.
	// - `labels`
	//   - Type: string
	//   - Example: `not labels exists`
	//   - Description: The resource labels that will be included in the results.
	// - `location`
	//   - Type: string
	//   - Example: `location starts with "https://bitbucket.org/organizations-workspace/teams-repository/src"`
	//   - Description: The web address of an IaC Manifest.
	// - `name`
	//   - Type: string
	//   - Example: `name starts with "acl"`
	//   - Description: The names that will be included in the results.
	// - `namespace`
	//   - Type: string
	//   - Example: `namespace contains "production"`
	//   - Description: The namespace that will be included in the results.
	// - `nodeType`
	//   - Type: string
	//   - Example: `nodeType="Worker"`
	//   - Description: The nodeType that will be included in the results.
	// - `osName`
	//   - Type: string
	//   - Example: `osName != "linux"`
	//   - Description: The operating system that will be included in the results.
	// - `osImage`
	//   - Type: string
	//   - Example: `osImage = "Ubuntu 18.04.6 LTS"`
	//   - Description: The operating system image that will be included in the results.
	// - `organization`
	//   - Type: string
	//   - Example: `organization = "s-xqe92dwe61"`
	//   - Description: The organization that will be included in the results.
	// - `platform`
	//   - Type: string
	//   - Example: `platform = "AWS"`
	//   - Description: The platform that will be included in the results.
	// - `control.accepted`
	//   - Type: boolean
	//   - Example: `control.accepted exists`
	//   - Description: Include (or Exclude) only resources with accepted results. Supported operators: exists and not exists.
	// - `policy`
	//   - Type: string
	//   - Example: `policy in ("CIS Docker Benchmark")`
	//   - Description: Include resources that applied the selected policies. Supported operators: in, not in, exists, not exists.
	// - `control.severity`
	//   - Type: string
	//   - Example: `control.severity in ("High")`
	//   - Description: Include resources that have violated risks in the selected severities. Supported operators: in, not in.
	// - `control.failed`
	//   - Type: string
	//   - Example: `control.failed in ("/etc/default/docker owned by root:root")`
	//   - Description: Include resources that have violated the selected risks. Supported operators: in, not in, exists, not exists.
	// - `policy.failed`
	//   - Type: string
	//   - Example: `policy.failed in ("PCI DSS (Payment Card Industry Data Security Standard) v3.2.1")`
	//   - Description: Include resources that failed the selected policies. Supported operators: in, not in, exists, not exists.
	// - `policy.passed` in ("CIS Kubernetes V1.20 Benchmark")
	//   - Type: string
	//   - Example: `policy.passed in ("CIS Kubernetes V1.20 Benchmark")`
	//   - Description: Include resources that passed the selected policies. Supported operators: in, not in, exists, not exists.
	// - `project`
	//   - Type: string
	//   - Example: `project = "project1"`
	//   - Description: DEPRECATED. The project that will be included in the results.
	// - `projectName`
	//   - Type: string
	//   - Example: `projectName = "project123"`
	//   - Description: The project name that will be included in the results.
	// - `projectId`
	//   - Type: string
	//   - Example: `projectId = "1235495521"`
	//   - Description: The project id that will be included in the results.
	// - `region`
	//   - Type: string
	//   - Example: `region in ("europe-west1")`
	//   - Description: The regions that will be included in the results.
	// - `repository`
	//   - Type: string
	//   - Example: `repository in ("e2e-repo")`
	//   - Description: The Repository an IaC resource belongs to.
	// - `resourceOrigin`
	//   - Type: string
	//   - Example: `resourceOrigin = "Code"`
	//   - Description: Origin of the resource. Supported values: Code, Deployed.
	// - `type`
	//   - Type: string
	//   - Example: `type = "Account"`
	//   - Description: The resource types that will be included in the results.
	// - `subscription`
	//   - Type: string
	//   - Example: `subscription = "Azure subscription 1"`
	//   - Description: DEPRECATED. The Azure subscription that will be included in the results.
	// - `subscriptionName`
	//   - Type: string
	//   - Example: `subscriptionName = "subscription abc"`
	//   - Description: The Azure subscription name that will be included in the results.
	// - `subscriptionId`
	//   - Type: string
	//   - Example: `subscriptionId = "568634664353"`
	//   - Description: The Azure subscription id that will be included in the results.
	// - `sourceType`
	//   - Type: string
	//   - Example: `sourceType = "YAML"`
	//   - Description: The source type of an IaC resource. Supported values: YAML, Kustomize, Terraform, Helm.
	// - `version`
	//   - Type: string
	//   - Example: `version = "1.1"`
	//   - Description: OCP Cluster versions that will be included in the results.
	// - `zone`
	//   - Type: string
	//   - Example: `zone in ("zone1")`
	//   - Description: The zones that will be included in the results.
	// - `category`
	//   - Type: string
	//   - Example: `category in ("Compute", "IAM")`
	//   - Description: The category that will be included in the results. Supported operators: in, not in.
	// - `isExposed`
	//   - Type: boolean
	//   - Example: `isExposed exists`
	//   - Description - Specifies whether the resource to return is exposed to the internet. Supported operators: exists and not exists.
	// - `validatedExposure`
	//   - Type: boolean
	//   - Example: `validatedExposure exists`
	//   - Description - Specifies whether the resource to return is exposed to the internet and could be reach by our network exposure validator. Supported operators: exists and not exists.
	// - `arn`
	//   - Type: string
	//   - Example: `arn in ("arn:aws:ec2:eu-central-1:843232641625:instance/i-0c1dedd325e71138d")`
	//   - Description - The AWS ARN of the resource.
	// - `resourceId`
	//   - Type: string
	//   - Example: `resourceId = "//compute.googleapis.com/projects/project1/global/routes/default-route-192ae83214caddd"`
	//   - Description - The Azure or GCP Resource Identifier of the resource.
	// - `container.name`
	//   - Type: string
	//   - Example: `container.name in ("sysdig-container")`
	//   - Description - Filters the resource by a container.
	// - `architecture`
	//   - Type: string
	//   - Example: `architecture = "arm64"`
	//   - Description - Image architecture.
	// - `baseOS`
	//   - Type: string
	//   - Example: `baseOS = "debian 11.6"`
	//   - Description - Image Base OS.
	// - `digest`
	//   - Type: string
	//   - Example: `digest = "sha256:21829f4f033ac2805aa43a412bcdf60e98eee4124d565a06dee184c97efff6091"`
	//   - Description - Image Digest.
	// - `imageId`
	//   - Type: string
	//   - Example: `imageId in ("sha256:3768ff6176e29a35ce1354622977a1e5c013045cbc4f30754ef3459218be8ac")`
	//   - Description - Image Id.
	// - `os`
	//   - Type: string
	//   - Example: `os = "linux"`
	//   - Description - Image OS.
	// - `container.imageName`
	//   - Type: string
	//   - Example: `container.imageName in ("registry.k8s.io/kube-image:v1.2.4")`
	//   - Description - Image Pullstring.
	// - `image.registry`
	//   - Type: string
	//   - Example: `image.registry = "quay.io"`
	//   - Description - Image Registry.
	// - `image.tag`
	//   - Type: string
	//   - Example: `image.tag in ("tag1")`
	//   - Description - Image tag.
	// - `package.inUse`
	//   - Type: boolean
	//   - Example: `package.inUse exists`
	//   - Description - Package in use filter. Supported operators: exists and not exists.
	// - `package.info`
	//   - Type: string
	//   - Example: `package.info in ("github.com/golang/protobuf - v1.5.2")`
	//   - Description - Filters by a package using the format [packge name] - [version].
	// - `package.path`
	//   - Type: string
	//   - Example: `package.path in ("/app")`
	//   - Description - Filters by package path.
	// - `package.type`
	//   - Type: string
	//   - Example: `package.type in ("Golang")`
	//   - Description - Package type.
	// - `vuln.cvssScore`
	//   - Type: string
	//   - Example: `vuln.cvssScore >= "3"`
	//   - Description - Filter by vulnerability CVSS. Supported operators: `=` and `>=`.
	// - `vuln.hasExploit`
	//   - Type: boolean
	//   - Example: `vuln.hasExploit exists`
	//   - Description - Filters resources by the existence of vulnerabilities with exploits. Supported operators: exists and not exists.
	// - `vuln.hasFix`
	//   - Type: boolean
	//   - Example: `vuln.hasFix exists`
	//   - Description - Filters resources by the existence of vulnerabilities with fixes. Supported operators: exists and not exists.
	// - `vuln.name`
	//   - Type: string
	//   - Example: `vuln.name in ("CVE-2023-0049")`
	//   - Description - Filter by vulnerability name.
	// - `vuln.severity`
	//   - Type: string
	//   - Example: `vuln.severity in ("Critical")`
	//   - Description - Filter by vulnerability severity. Supported operators: in, not in, exists and not exists.
	// - `machineImage`
	//   - Type: string
	//   - Example: `machineImage = "ami-0b22b359fdfabe1b5"`
	//   - Description - Filter by host machine image.
	//
	// **Note**: Whenever you filter for values with special characters, ensure that you encode the values.
	// If the special characters are " or \, use the escape character \ and then encode the values.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// PageNumber Page number. Defaults to 1.
	PageNumber *int32 `form:"pageNumber,omitempty" json:"pageNumber,omitempty"`

	// PageSize Page size. Defaults to 20.
	PageSize *int32 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// WithEnrichedContainers If true then for kubernetes workload resources additional container information will be included.
	WithEnrichedContainers *bool `form:"withEnrichedContainers,omitempty" json:"withEnrichedContainers,omitempty"`
}

// GetActionExecutionsv1Params defines parameters for GetActionExecutionsv1.
type GetActionExecutionsv1Params struct {
	CallerId *CallerId                  `form:"callerId,omitempty" json:"callerId,omitempty"`
	Filter   *SysdigQueryLanguageFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// Limit The number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset The offset number of items to start with
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
	From   *From   `form:"from,omitempty" json:"from,omitempty"`
	To     *To     `form:"to,omitempty" json:"to,omitempty"`
}

// UndoActionExecutionV1Params defines parameters for UndoActionExecutionV1.
type UndoActionExecutionV1Params struct {
	CallerId *CallerId `form:"callerId,omitempty" json:"callerId,omitempty"`
}

// GetActionsV1Params defines parameters for GetActionsV1.
type GetActionsV1Params struct {
	Context *ExecutionContext `form:"context,omitempty" json:"context,omitempty"`
}

// GetSecureVulnerabilityV1BundlesParams defines parameters for GetSecureVulnerabilityV1Bundles.
type GetSecureVulnerabilityV1BundlesParams struct {
	// Cursor Cursor is a string used to retrieve a particular page of data. It is an opaque structure, and should not be mangled. It could be retrieved in the body of each request. If a response does not contain a cursor, it means that it's the last page.
	Cursor *VulnerabilityCursor `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Limit for pagination
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetSecureVulnerabilityV1PipelineResultsParams defines parameters for GetSecureVulnerabilityV1PipelineResults.
type GetSecureVulnerabilityV1PipelineResultsParams struct {
	// Cursor Cursor is a string used to retrieve a particular page of data. It is an opaque structure, and should not be mangled. It could be retrieved in the body of each request. If a response does not contain a cursor, it means that it's the last page.
	Cursor *VulnerabilityCursor `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Limit for pagination
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Filter Query language expression for filtering results. It is a subset of
	// the full metrics query language used in monitoring.
	//
	// Only the freeText parameter is supported:
	// - `freeText` as string value (note that it will search on the full image name)
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetSecureVulnerabilityV1PoliciesParams defines parameters for GetSecureVulnerabilityV1Policies.
type GetSecureVulnerabilityV1PoliciesParams struct {
	// Cursor Cursor is a string used to retrieve a particular page of data. It is an opaque structure, and should not be mangled. It could be retrieved in the body of each request. If a response does not contain a cursor, it means that it's the last page.
	Cursor *VulnerabilityCursor `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Limit for pagination
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Name Filter policies by name
	Name *string `form:"name,omitempty" json:"name,omitempty"`

	// Stages Filter policies by applied stages
	Stages *[]GetSecureVulnerabilityV1PoliciesParamsStages `form:"stages,omitempty" json:"stages,omitempty"`
}

// GetSecureVulnerabilityV1PoliciesParamsStages defines parameters for GetSecureVulnerabilityV1Policies.
type GetSecureVulnerabilityV1PoliciesParamsStages string

// ScannerAPIServiceListRegistryResultsParams defines parameters for ScannerAPIServiceListRegistryResults.
type ScannerAPIServiceListRegistryResultsParams struct {
	// Cursor Cursor is a string used to retrieve a particular page of data. It is an opaque structure, and should not be mangled. It could be retrieved in the body of each request. If a response does not contain a cursor, it means that it's the last page.
	Cursor *VulnerabilityCursor `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Limit for pagination
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Filter Query language expression for filtering results. It is a subset of
	// the full metrics query language used in monitoring.
	//
	// Operators:
	// - `and`, `or` logical operators (i.e.
	// `freeText = "alpine:latest" and vendor = "docker"`)
	//
	// - `=` and `!=` comparison operators (i.e.
	// `vendor = "ecr"`)
	//
	// This query language does not support the full set of metrics
	// supported in the monitor query language, but instead supports a set of fields
	// proper to each Scan Result type.
	//
	// The supported fields are: `freeText`, `vendor`.
	// - `vendor` as string value
	// - `freeText` as string value (note that it will search on the full image name)
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`
}

// ScannerAPIServiceListRuntimeResultsParams defines parameters for ScannerAPIServiceListRuntimeResults.
type ScannerAPIServiceListRuntimeResultsParams struct {
	// Cursor Cursor is a string used to retrieve a particular page of data. It is an opaque structure, and should not be mangled. It could be retrieved in the body of each request. If a response does not contain a cursor, it means that it's the last page.
	Cursor *VulnerabilityCursor `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit Limit for pagination
	Limit *int64 `form:"limit,omitempty" json:"limit,omitempty"`

	// Filter Query language expression for filtering results. It is a subset of
	// the full metrics query language used in monitoring.
	//
	// Operators:
	// - `and`, `or` logical operators (i.e.
	// `kubernetes.cluster.name="production" and kubernetes.pod.container.name = "docker.internal.sysdig.tools"`)
	//
	// - `=` and `!=` comparison operators (i.e.
	// `kubernetes.cluster.name="staging"`)
	//
	// This query language does not support the full set of metrics
	// supported in the monitor query language, but instead supports a set of fields
	// proper to each Scan Result type.
	//
	// The supported fields are the all the fields of the `Scope`, plus: `freeText`, `hasRunningVulns` and `hasRunningVulns`.
	Filter *string `form:"filter,omitempty" json:"filter,omitempty"`

	// Sort Field used to sort the results
	// vulnTotalBySeverity: sort by total number of running vulnerabilities weighted by severity
	// runningVulnTotalBySeverity: sort by total number of running vulnerabilities weighted by severity for running assets
	Sort *ScannerAPIServiceListRuntimeResultsParamsSort `form:"sort,omitempty" json:"sort,omitempty"`

	// Order Ordering of the results for the sort field
	Order *ScannerAPIServiceListRuntimeResultsParamsOrder `form:"order,omitempty" json:"order,omitempty"`
}

// ScannerAPIServiceListRuntimeResultsParamsSort defines parameters for ScannerAPIServiceListRuntimeResults.
type ScannerAPIServiceListRuntimeResultsParamsSort string

// ScannerAPIServiceListRuntimeResultsParamsOrder defines parameters for ScannerAPIServiceListRuntimeResults.
type ScannerAPIServiceListRuntimeResultsParamsOrder string

// GetAcceptedRisksV1Params defines parameters for GetAcceptedRisksV1.
type GetAcceptedRisksV1Params struct {
	// Filter The filtering string in secure-querylang syntax.
	Filter *VulnerabilityFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// Order The sorting order
	Order *GetAcceptedRisksV1ParamsOrder `form:"order,omitempty" json:"order,omitempty"`

	// Cursor Cursor is a string used to retrieve a particular page of data. It is an opaque structure, and should not be mangled. It could be retrieved in the body of each request. If a response does not contain a cursor, it means that it's the last page.
	Cursor *VulnerabilityCursor `form:"cursor,omitempty" json:"cursor,omitempty"`

	// Limit The number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Sort The sorting string
	Sort *GetAcceptedRisksV1ParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// GetAcceptedRisksV1ParamsOrder defines parameters for GetAcceptedRisksV1.
type GetAcceptedRisksV1ParamsOrder string

// GetAcceptedRisksV1ParamsSort defines parameters for GetAcceptedRisksV1.
type GetAcceptedRisksV1ParamsSort string

// GetSBOMV1beta1Params defines parameters for GetSBOMV1beta1.
type GetSBOMV1beta1Params struct {
	// AssetId The ID of the asset for which we want to retrieve the SBOM. It's the imageId for container-image and the hostId for hosts
	// Provide this with assetType if not providing bomIdentifier
	AssetId *string `form:"assetId,omitempty" json:"assetId,omitempty"`

	// AssetType The type of the asset for which we want to retrieve the SBOM. Provide this with assetId if not providing bomIdentifier
	AssetType *GetSBOMV1beta1ParamsAssetType `form:"assetType,omitempty" json:"assetType,omitempty"`

	// BomIdentifier The ID of a single SBOM. Either provide this or both assetId and assetType
	BomIdentifier *string `form:"bomIdentifier,omitempty" json:"bomIdentifier,omitempty"`
}

// GetSBOMV1beta1ParamsAssetType defines parameters for GetSBOMV1beta1.
type GetSBOMV1beta1ParamsAssetType string

// QuerySysqlPostJSONRequestBody defines body for QuerySysqlPost for application/json ContentType.
type QuerySysqlPostJSONRequestBody QuerySysqlPostJSONBody

// CreateInhibitionRuleJSONRequestBody defines body for CreateInhibitionRule for application/json ContentType.
type CreateInhibitionRuleJSONRequestBody = CreateInhibitionRuleRequestV1

// UpdateInhibitionRuleJSONRequestBody defines body for UpdateInhibitionRule for application/json ContentType.
type UpdateInhibitionRuleJSONRequestBody = UpdateInhibitionRuleRequestV1

// CreatePricingV1JSONRequestBody defines body for CreatePricingV1 for application/json ContentType.
type CreatePricingV1JSONRequestBody = CreatePricingRequestV1

// UpdatePricingByIdV1JSONRequestBody defines body for UpdatePricingByIdV1 for application/json ContentType.
type UpdatePricingByIdV1JSONRequestBody = UpdatePricingRequestV1

// GetWastedWorkloadDataJSONRequestBody defines body for GetWastedWorkloadData for application/json ContentType.
type GetWastedWorkloadDataJSONRequestBody = WastedWorkloadDataRequest

// GetWorkloadCostDataV1JSONRequestBody defines body for GetWorkloadCostDataV1 for application/json ContentType.
type GetWorkloadCostDataV1JSONRequestBody = WorkloadCostTrendsDataRequest

// GetWorkloadRightsizingDataJSONRequestBody defines body for GetWorkloadRightsizingData for application/json ContentType.
type GetWorkloadRightsizingDataJSONRequestBody = WorkloadRightsizingDataRequest

// PostDisabledMetricsV1JSONRequestBody defines body for PostDisabledMetricsV1 for application/json ContentType.
type PostDisabledMetricsV1JSONRequestBody = RequestBodyDisabledMetricsV1

// UpdateCustomPrometheusJobEnablementV1JSONRequestBody defines body for UpdateCustomPrometheusJobEnablementV1 for application/json ContentType.
type UpdateCustomPrometheusJobEnablementV1JSONRequestBody = CustomJobsEnablementV1

// CreateJiraIntegrationV1JSONRequestBody defines body for CreateJiraIntegrationV1 for application/json ContentType.
type CreateJiraIntegrationV1JSONRequestBody = CreateIntegrationRequestV1

// UpdateJiraIntegrationV1JSONRequestBody defines body for UpdateJiraIntegrationV1 for application/json ContentType.
type UpdateJiraIntegrationV1JSONRequestBody = UpdateIntegrationRequestV1

// CreateJiraIssueTypeV1JSONRequestBody defines body for CreateJiraIssueTypeV1 for application/json ContentType.
type CreateJiraIssueTypeV1JSONRequestBody = CreateIssueTypeRequestV1

// UpdateJiraIssueTypeV1JSONRequestBody defines body for UpdateJiraIssueTypeV1 for application/json ContentType.
type UpdateJiraIssueTypeV1JSONRequestBody = UpdateIssueTypeRequestV1

// CreateAccessKeyV1JSONRequestBody defines body for CreateAccessKeyV1 for application/json ContentType.
type CreateAccessKeyV1JSONRequestBody = CreateAccessKeyRequestV1

// UpdateAccessKeyByIdV1JSONRequestBody defines body for UpdateAccessKeyByIdV1 for application/json ContentType.
type UpdateAccessKeyByIdV1JSONRequestBody = UpdateAccessKeyRequestV1

// UpdateCaptureStorageConfigurationV1JSONRequestBody defines body for UpdateCaptureStorageConfigurationV1 for application/json ContentType.
type UpdateCaptureStorageConfigurationV1JSONRequestBody = SaveCaptureStorageConfigurationRequestV1

// UpdateUserDeactivationConfigurationByIdV1JSONRequestBody defines body for UpdateUserDeactivationConfigurationByIdV1 for application/json ContentType.
type UpdateUserDeactivationConfigurationByIdV1JSONRequestBody = UpdateUserDeactivationConfigurationRequestV1

// UpdateGlobalSsoSettingsV1JSONRequestBody defines body for UpdateGlobalSsoSettingsV1 for application/json ContentType.
type UpdateGlobalSsoSettingsV1JSONRequestBody = GlobalSsoSettingsRequestV1

// CreateGroupMappingV1JSONRequestBody defines body for CreateGroupMappingV1 for application/json ContentType.
type CreateGroupMappingV1JSONRequestBody = CreateGroupMappingRequestV1

// SaveGroupMappingSettingsV1JSONRequestBody defines body for SaveGroupMappingSettingsV1 for application/json ContentType.
type SaveGroupMappingSettingsV1JSONRequestBody = GroupMappingSettingsV1

// UpdateGroupMappingByIdV1JSONRequestBody defines body for UpdateGroupMappingByIdV1 for application/json ContentType.
type UpdateGroupMappingByIdV1JSONRequestBody = UpdateGroupMappingRequestV1

// CreateIpFilterV1JSONRequestBody defines body for CreateIpFilterV1 for application/json ContentType.
type CreateIpFilterV1JSONRequestBody = CreateIpFilterV1

// SaveIpFiltersSettingsV1JSONRequestBody defines body for SaveIpFiltersSettingsV1 for application/json ContentType.
type SaveIpFiltersSettingsV1JSONRequestBody = IpFiltersSettingsV1

// UpdateIpFilterV1JSONRequestBody defines body for UpdateIpFilterV1 for application/json ContentType.
type UpdateIpFilterV1JSONRequestBody = UpdateIpFilterV1

// CreateNotificationChannelJSONRequestBody defines body for CreateNotificationChannel for application/json ContentType.
type CreateNotificationChannelJSONRequestBody = CreateNotificationChannelRequestV1

// UpdateNotificationChannelByIdJSONRequestBody defines body for UpdateNotificationChannelById for application/json ContentType.
type UpdateNotificationChannelByIdJSONRequestBody = UpdateNotificationChannelRequestV1

// CreateRoleV1JSONRequestBody defines body for CreateRoleV1 for application/json ContentType.
type CreateRoleV1JSONRequestBody = RoleRequestV1

// UpdateRoleByIdV1JSONRequestBody defines body for UpdateRoleByIdV1 for application/json ContentType.
type UpdateRoleByIdV1JSONRequestBody = RoleRequestV1

// CreateGlobalServiceAccountV1JSONRequestBody defines body for CreateGlobalServiceAccountV1 for application/json ContentType.
type CreateGlobalServiceAccountV1JSONRequestBody = CreateGlobalServiceAccountRequestV1

// CreateGlobalServiceAccountsNotificationSettingsV1JSONRequestBody defines body for CreateGlobalServiceAccountsNotificationSettingsV1 for application/json ContentType.
type CreateGlobalServiceAccountsNotificationSettingsV1JSONRequestBody = CreateServiceAccountsNotificationSettingsRequestV1

// UpdateGlobalServiceAccountsNotificationSettingsV1JSONRequestBody defines body for UpdateGlobalServiceAccountsNotificationSettingsV1 for application/json ContentType.
type UpdateGlobalServiceAccountsNotificationSettingsV1JSONRequestBody = UpdateServiceAccountsNotificationSettingsRequestV1

// CreateSsoSettingsV1JSONRequestBody defines body for CreateSsoSettingsV1 for application/json ContentType.
type CreateSsoSettingsV1JSONRequestBody = CreateSsoSettingsRequestV1

// UpdateSsoSettingsByIdV1JSONRequestBody defines body for UpdateSsoSettingsByIdV1 for application/json ContentType.
type UpdateSsoSettingsByIdV1JSONRequestBody = UpdateSsoSettingsRequestV1

// CreateTeamV1JSONRequestBody defines body for CreateTeamV1 for application/json ContentType.
type CreateTeamV1JSONRequestBody = CreateTeamRequestV1

// UpdateTeamByIdV1JSONRequestBody defines body for UpdateTeamByIdV1 for application/json ContentType.
type UpdateTeamByIdV1JSONRequestBody = UpdateTeamRequestV1

// CreateTeamServiceAccountV1JSONRequestBody defines body for CreateTeamServiceAccountV1 for application/json ContentType.
type CreateTeamServiceAccountV1JSONRequestBody = CreateTeamServiceAccountRequestV1

// CreateServiceAccountsNotificationSettingsV1JSONRequestBody defines body for CreateServiceAccountsNotificationSettingsV1 for application/json ContentType.
type CreateServiceAccountsNotificationSettingsV1JSONRequestBody = CreateServiceAccountsNotificationSettingsRequestV1

// UpdateServiceAccountsNotificationSettingsV1JSONRequestBody defines body for UpdateServiceAccountsNotificationSettingsV1 for application/json ContentType.
type UpdateServiceAccountsNotificationSettingsV1JSONRequestBody = UpdateServiceAccountsNotificationSettingsRequestV1

// SaveTeamUserV1JSONRequestBody defines body for SaveTeamUserV1 for application/json ContentType.
type SaveTeamUserV1JSONRequestBody = SaveTeamUserRequestV1

// CreateUserV1JSONRequestBody defines body for CreateUserV1 for application/json ContentType.
type CreateUserV1JSONRequestBody = CreateUserRequestV1

// UpdateUserV1JSONRequestBody defines body for UpdateUserV1 for application/json ContentType.
type UpdateUserV1JSONRequestBody = UpdateUserRequestV1

// CreateZoneV1JSONRequestBody defines body for CreateZoneV1 for application/json ContentType.
type CreateZoneV1JSONRequestBody = CreateZoneRequestV1

// EditZoneV1JSONRequestBody defines body for EditZoneV1 for application/json ContentType.
type EditZoneV1JSONRequestBody = CreateZoneRequestV1

// UploadCertificateV1MultipartRequestBody defines body for UploadCertificateV1 for multipart/form-data ContentType.
type UploadCertificateV1MultipartRequestBody = UploadCertificateRequest

// CreateEFOIntegrationV1JSONRequestBody defines body for CreateEFOIntegrationV1 for application/json ContentType.
type CreateEFOIntegrationV1JSONRequestBody = CreateEfoIntegrationRequestV1

// UpdateEFOIntegrationByIdV1JSONRequestBody defines body for UpdateEFOIntegrationByIdV1 for application/json ContentType.
type UpdateEFOIntegrationByIdV1JSONRequestBody = UpdateEfoIntegrationRequestV1

// CreateEFOIntegrationV2JSONRequestBody defines body for CreateEFOIntegrationV2 for application/json ContentType.
type CreateEFOIntegrationV2JSONRequestBody = CreateIntegrationRequest

// UpdateEFOIntegrationByIdV2JSONRequestBody defines body for UpdateEFOIntegrationByIdV2 for application/json ContentType.
type UpdateEFOIntegrationByIdV2JSONRequestBody = UpdateIntegrationRequest

// SubmitActionExecutionv1JSONRequestBody defines body for SubmitActionExecutionv1 for application/json ContentType.
type SubmitActionExecutionv1JSONRequestBody = SubmitActionExecutionRequest

// PostSecureVulnerabilityV1BundlesJSONRequestBody defines body for PostSecureVulnerabilityV1Bundles for application/json ContentType.
type PostSecureVulnerabilityV1BundlesJSONRequestBody = CreateBundleRequest

// PutSecureVulnerabilityV1BundlesBundleIdJSONRequestBody defines body for PutSecureVulnerabilityV1BundlesBundleId for application/json ContentType.
type PutSecureVulnerabilityV1BundlesBundleIdJSONRequestBody = CreateBundleRequest

// PostSecureVulnerabilityV1PoliciesJSONRequestBody defines body for PostSecureVulnerabilityV1Policies for application/json ContentType.
type PostSecureVulnerabilityV1PoliciesJSONRequestBody = CreatePolicyRequest

// PutSecureVulnerabilityV1PoliciesPolicyIdJSONRequestBody defines body for PutSecureVulnerabilityV1PoliciesPolicyId for application/json ContentType.
type PutSecureVulnerabilityV1PoliciesPolicyIdJSONRequestBody = CreatePolicyRequest

// PostAcceptedRiskV1JSONRequestBody defines body for PostAcceptedRiskV1 for application/json ContentType.
type PostAcceptedRiskV1JSONRequestBody = CreateRiskAcceptedRequest

// UpdateAcceptedRiskV1JSONRequestBody defines body for UpdateAcceptedRiskV1 for application/json ContentType.
type UpdateAcceptedRiskV1JSONRequestBody = UpdateRiskAccepted

// Getter for additional properties for QueryResponse_Entities. Returns the specified
// element and whether it was found
func (a QueryResponse_Entities) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for QueryResponse_Entities
func (a *QueryResponse_Entities) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for QueryResponse_Entities to handle AdditionalProperties
func (a *QueryResponse_Entities) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["fields"]; found {
		err = json.Unmarshal(raw, &a.Fields)
		if err != nil {
			return fmt.Errorf("error reading 'fields': %w", err)
		}
		delete(object, "fields")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for QueryResponse_Entities to handle AdditionalProperties
func (a QueryResponse_Entities) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Fields != nil {
		object["fields"], err = json.Marshal(a.Fields)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fields': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsCaptureAction returns the union data inside the Action as a CaptureAction
func (t Action) AsCaptureAction() (CaptureAction, error) {
	var body CaptureAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCaptureAction overwrites any union data inside the Action as the provided CaptureAction
func (t *Action) FromCaptureAction(v CaptureAction) error {
	v.Type = "capture"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCaptureAction performs a merge with any union data inside the Action, using the provided CaptureAction
func (t *Action) MergeCaptureAction(v CaptureAction) error {
	v.Type = "capture"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerPausedAction returns the union data inside the Action as a ContainerPausedAction
func (t Action) AsContainerPausedAction() (ContainerPausedAction, error) {
	var body ContainerPausedAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerPausedAction overwrites any union data inside the Action as the provided ContainerPausedAction
func (t *Action) FromContainerPausedAction(v ContainerPausedAction) error {
	v.Type = "container_paused"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerPausedAction performs a merge with any union data inside the Action, using the provided ContainerPausedAction
func (t *Action) MergeContainerPausedAction(v ContainerPausedAction) error {
	v.Type = "container_paused"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerStoppedAction returns the union data inside the Action as a ContainerStoppedAction
func (t Action) AsContainerStoppedAction() (ContainerStoppedAction, error) {
	var body ContainerStoppedAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerStoppedAction overwrites any union data inside the Action as the provided ContainerStoppedAction
func (t *Action) FromContainerStoppedAction(v ContainerStoppedAction) error {
	v.Type = "container_stopped"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerStoppedAction performs a merge with any union data inside the Action, using the provided ContainerStoppedAction
func (t *Action) MergeContainerStoppedAction(v ContainerStoppedAction) error {
	v.Type = "container_stopped"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContainerKilledAction returns the union data inside the Action as a ContainerKilledAction
func (t Action) AsContainerKilledAction() (ContainerKilledAction, error) {
	var body ContainerKilledAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContainerKilledAction overwrites any union data inside the Action as the provided ContainerKilledAction
func (t *Action) FromContainerKilledAction(v ContainerKilledAction) error {
	v.Type = "container_killed"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContainerKilledAction performs a merge with any union data inside the Action, using the provided ContainerKilledAction
func (t *Action) MergeContainerKilledAction(v ContainerKilledAction) error {
	v.Type = "container_killed"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDriftPreventedAction returns the union data inside the Action as a DriftPreventedAction
func (t Action) AsDriftPreventedAction() (DriftPreventedAction, error) {
	var body DriftPreventedAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDriftPreventedAction overwrites any union data inside the Action as the provided DriftPreventedAction
func (t *Action) FromDriftPreventedAction(v DriftPreventedAction) error {
	v.Type = "drift_prevented"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDriftPreventedAction performs a merge with any union data inside the Action, using the provided DriftPreventedAction
func (t *Action) MergeDriftPreventedAction(v DriftPreventedAction) error {
	v.Type = "drift_prevented"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMalwarePreventedAction returns the union data inside the Action as a MalwarePreventedAction
func (t Action) AsMalwarePreventedAction() (MalwarePreventedAction, error) {
	var body MalwarePreventedAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMalwarePreventedAction overwrites any union data inside the Action as the provided MalwarePreventedAction
func (t *Action) FromMalwarePreventedAction(v MalwarePreventedAction) error {
	v.Type = "malware_prevented"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMalwarePreventedAction performs a merge with any union data inside the Action, using the provided MalwarePreventedAction
func (t *Action) MergeMalwarePreventedAction(v MalwarePreventedAction) error {
	v.Type = "malware_prevented"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsProcessKilledAction returns the union data inside the Action as a ProcessKilledAction
func (t Action) AsProcessKilledAction() (ProcessKilledAction, error) {
	var body ProcessKilledAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromProcessKilledAction overwrites any union data inside the Action as the provided ProcessKilledAction
func (t *Action) FromProcessKilledAction(v ProcessKilledAction) error {
	v.Type = "process_killed"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeProcessKilledAction performs a merge with any union data inside the Action, using the provided ProcessKilledAction
func (t *Action) MergeProcessKilledAction(v ProcessKilledAction) error {
	v.Type = "process_killed"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Action) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t Action) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "capture":
		return t.AsCaptureAction()
	case "container_killed":
		return t.AsContainerKilledAction()
	case "container_paused":
		return t.AsContainerPausedAction()
	case "container_stopped":
		return t.AsContainerStoppedAction()
	case "drift_prevented":
		return t.AsDriftPreventedAction()
	case "malware_prevented":
		return t.AsMalwarePreventedAction()
	case "process_killed":
		return t.AsProcessKilledAction()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t Action) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Action) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsActionExecutionStringParameterValue returns the union data inside the ActionExecutionParameterValue as a ActionExecutionStringParameterValue
func (t ActionExecutionParameterValue) AsActionExecutionStringParameterValue() (ActionExecutionStringParameterValue, error) {
	var body ActionExecutionStringParameterValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromActionExecutionStringParameterValue overwrites any union data inside the ActionExecutionParameterValue as the provided ActionExecutionStringParameterValue
func (t *ActionExecutionParameterValue) FromActionExecutionStringParameterValue(v ActionExecutionStringParameterValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeActionExecutionStringParameterValue performs a merge with any union data inside the ActionExecutionParameterValue, using the provided ActionExecutionStringParameterValue
func (t *ActionExecutionParameterValue) MergeActionExecutionStringParameterValue(v ActionExecutionStringParameterValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsActionExecutionIntParameterValue returns the union data inside the ActionExecutionParameterValue as a ActionExecutionIntParameterValue
func (t ActionExecutionParameterValue) AsActionExecutionIntParameterValue() (ActionExecutionIntParameterValue, error) {
	var body ActionExecutionIntParameterValue
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromActionExecutionIntParameterValue overwrites any union data inside the ActionExecutionParameterValue as the provided ActionExecutionIntParameterValue
func (t *ActionExecutionParameterValue) FromActionExecutionIntParameterValue(v ActionExecutionIntParameterValue) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeActionExecutionIntParameterValue performs a merge with any union data inside the ActionExecutionParameterValue, using the provided ActionExecutionIntParameterValue
func (t *ActionExecutionParameterValue) MergeActionExecutionIntParameterValue(v ActionExecutionIntParameterValue) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsActionExecutionParameterValue2 returns the union data inside the ActionExecutionParameterValue as a ActionExecutionParameterValue2
func (t ActionExecutionParameterValue) AsActionExecutionParameterValue2() (ActionExecutionParameterValue2, error) {
	var body ActionExecutionParameterValue2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromActionExecutionParameterValue2 overwrites any union data inside the ActionExecutionParameterValue as the provided ActionExecutionParameterValue2
func (t *ActionExecutionParameterValue) FromActionExecutionParameterValue2(v ActionExecutionParameterValue2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeActionExecutionParameterValue2 performs a merge with any union data inside the ActionExecutionParameterValue, using the provided ActionExecutionParameterValue2
func (t *ActionExecutionParameterValue) MergeActionExecutionParameterValue2(v ActionExecutionParameterValue2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ActionExecutionParameterValue) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ActionExecutionParameterValue) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsKafkaPlaintextV1 returns the union data inside the AuthenticatedConnectionInfoKafkaV1 as a KafkaPlaintextV1
func (t AuthenticatedConnectionInfoKafkaV1) AsKafkaPlaintextV1() (KafkaPlaintextV1, error) {
	var body KafkaPlaintextV1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaPlaintextV1 overwrites any union data inside the AuthenticatedConnectionInfoKafkaV1 as the provided KafkaPlaintextV1
func (t *AuthenticatedConnectionInfoKafkaV1) FromKafkaPlaintextV1(v KafkaPlaintextV1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaPlaintextV1 performs a merge with any union data inside the AuthenticatedConnectionInfoKafkaV1, using the provided KafkaPlaintextV1
func (t *AuthenticatedConnectionInfoKafkaV1) MergeKafkaPlaintextV1(v KafkaPlaintextV1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKafkaTlsEncryptedV1 returns the union data inside the AuthenticatedConnectionInfoKafkaV1 as a KafkaTlsEncryptedV1
func (t AuthenticatedConnectionInfoKafkaV1) AsKafkaTlsEncryptedV1() (KafkaTlsEncryptedV1, error) {
	var body KafkaTlsEncryptedV1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaTlsEncryptedV1 overwrites any union data inside the AuthenticatedConnectionInfoKafkaV1 as the provided KafkaTlsEncryptedV1
func (t *AuthenticatedConnectionInfoKafkaV1) FromKafkaTlsEncryptedV1(v KafkaTlsEncryptedV1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaTlsEncryptedV1 performs a merge with any union data inside the AuthenticatedConnectionInfoKafkaV1, using the provided KafkaTlsEncryptedV1
func (t *AuthenticatedConnectionInfoKafkaV1) MergeKafkaTlsEncryptedV1(v KafkaTlsEncryptedV1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AuthenticatedConnectionInfoKafkaV1) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["auth"], err = json.Marshal(t.Auth)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'auth': %w", err)
	}

	if t.Balancer != nil {
		object["balancer"], err = json.Marshal(t.Balancer)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'balancer': %w", err)
		}
	}

	object["brokers"], err = json.Marshal(t.Brokers)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'brokers': %w", err)
	}

	if t.Compression != nil {
		object["compression"], err = json.Marshal(t.Compression)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'compression': %w", err)
		}
	}

	if t.Keytab != nil {
		object["keytab"], err = json.Marshal(t.Keytab)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'keytab': %w", err)
		}
	}

	object["krb5"], err = json.Marshal(t.Krb5)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'krb5': %w", err)
	}

	object["principal"], err = json.Marshal(t.Principal)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'principal': %w", err)
	}

	object["realm"], err = json.Marshal(t.Realm)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'realm': %w", err)
	}

	object["service"], err = json.Marshal(t.Service)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'service': %w", err)
	}

	object["topic"], err = json.Marshal(t.Topic)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'topic': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *AuthenticatedConnectionInfoKafkaV1) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["auth"]; found {
		err = json.Unmarshal(raw, &t.Auth)
		if err != nil {
			return fmt.Errorf("error reading 'auth': %w", err)
		}
	}

	if raw, found := object["balancer"]; found {
		err = json.Unmarshal(raw, &t.Balancer)
		if err != nil {
			return fmt.Errorf("error reading 'balancer': %w", err)
		}
	}

	if raw, found := object["brokers"]; found {
		err = json.Unmarshal(raw, &t.Brokers)
		if err != nil {
			return fmt.Errorf("error reading 'brokers': %w", err)
		}
	}

	if raw, found := object["compression"]; found {
		err = json.Unmarshal(raw, &t.Compression)
		if err != nil {
			return fmt.Errorf("error reading 'compression': %w", err)
		}
	}

	if raw, found := object["keytab"]; found {
		err = json.Unmarshal(raw, &t.Keytab)
		if err != nil {
			return fmt.Errorf("error reading 'keytab': %w", err)
		}
	}

	if raw, found := object["krb5"]; found {
		err = json.Unmarshal(raw, &t.Krb5)
		if err != nil {
			return fmt.Errorf("error reading 'krb5': %w", err)
		}
	}

	if raw, found := object["principal"]; found {
		err = json.Unmarshal(raw, &t.Principal)
		if err != nil {
			return fmt.Errorf("error reading 'principal': %w", err)
		}
	}

	if raw, found := object["realm"]; found {
		err = json.Unmarshal(raw, &t.Realm)
		if err != nil {
			return fmt.Errorf("error reading 'realm': %w", err)
		}
	}

	if raw, found := object["service"]; found {
		err = json.Unmarshal(raw, &t.Service)
		if err != nil {
			return fmt.Errorf("error reading 'service': %w", err)
		}
	}

	if raw, found := object["topic"]; found {
		err = json.Unmarshal(raw, &t.Topic)
		if err != nil {
			return fmt.Errorf("error reading 'topic': %w", err)
		}
	}

	return err
}

// AsKafkaPlaintext returns the union data inside the BaseConnectionInfoKafka as a KafkaPlaintext
func (t BaseConnectionInfoKafka) AsKafkaPlaintext() (KafkaPlaintext, error) {
	var body KafkaPlaintext
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaPlaintext overwrites any union data inside the BaseConnectionInfoKafka as the provided KafkaPlaintext
func (t *BaseConnectionInfoKafka) FromKafkaPlaintext(v KafkaPlaintext) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaPlaintext performs a merge with any union data inside the BaseConnectionInfoKafka, using the provided KafkaPlaintext
func (t *BaseConnectionInfoKafka) MergeKafkaPlaintext(v KafkaPlaintext) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKafkaTlsEncrypted returns the union data inside the BaseConnectionInfoKafka as a KafkaTlsEncrypted
func (t BaseConnectionInfoKafka) AsKafkaTlsEncrypted() (KafkaTlsEncrypted, error) {
	var body KafkaTlsEncrypted
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaTlsEncrypted overwrites any union data inside the BaseConnectionInfoKafka as the provided KafkaTlsEncrypted
func (t *BaseConnectionInfoKafka) FromKafkaTlsEncrypted(v KafkaTlsEncrypted) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaTlsEncrypted performs a merge with any union data inside the BaseConnectionInfoKafka, using the provided KafkaTlsEncrypted
func (t *BaseConnectionInfoKafka) MergeKafkaTlsEncrypted(v KafkaTlsEncrypted) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BaseConnectionInfoKafka) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Balancer != nil {
		object["balancer"], err = json.Marshal(t.Balancer)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'balancer': %w", err)
		}
	}

	object["brokers"], err = json.Marshal(t.Brokers)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'brokers': %w", err)
	}

	if t.Compression != nil {
		object["compression"], err = json.Marshal(t.Compression)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'compression': %w", err)
		}
	}

	object["topic"], err = json.Marshal(t.Topic)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'topic': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *BaseConnectionInfoKafka) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["balancer"]; found {
		err = json.Unmarshal(raw, &t.Balancer)
		if err != nil {
			return fmt.Errorf("error reading 'balancer': %w", err)
		}
	}

	if raw, found := object["brokers"]; found {
		err = json.Unmarshal(raw, &t.Brokers)
		if err != nil {
			return fmt.Errorf("error reading 'brokers': %w", err)
		}
	}

	if raw, found := object["compression"]; found {
		err = json.Unmarshal(raw, &t.Compression)
		if err != nil {
			return fmt.Errorf("error reading 'compression': %w", err)
		}
	}

	if raw, found := object["topic"]; found {
		err = json.Unmarshal(raw, &t.Topic)
		if err != nil {
			return fmt.Errorf("error reading 'topic': %w", err)
		}
	}

	return err
}

// AsKafkaPlaintextV1 returns the union data inside the BaseConnectionInfoKafkaV1 as a KafkaPlaintextV1
func (t BaseConnectionInfoKafkaV1) AsKafkaPlaintextV1() (KafkaPlaintextV1, error) {
	var body KafkaPlaintextV1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaPlaintextV1 overwrites any union data inside the BaseConnectionInfoKafkaV1 as the provided KafkaPlaintextV1
func (t *BaseConnectionInfoKafkaV1) FromKafkaPlaintextV1(v KafkaPlaintextV1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaPlaintextV1 performs a merge with any union data inside the BaseConnectionInfoKafkaV1, using the provided KafkaPlaintextV1
func (t *BaseConnectionInfoKafkaV1) MergeKafkaPlaintextV1(v KafkaPlaintextV1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKafkaTlsEncryptedV1 returns the union data inside the BaseConnectionInfoKafkaV1 as a KafkaTlsEncryptedV1
func (t BaseConnectionInfoKafkaV1) AsKafkaTlsEncryptedV1() (KafkaTlsEncryptedV1, error) {
	var body KafkaTlsEncryptedV1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaTlsEncryptedV1 overwrites any union data inside the BaseConnectionInfoKafkaV1 as the provided KafkaTlsEncryptedV1
func (t *BaseConnectionInfoKafkaV1) FromKafkaTlsEncryptedV1(v KafkaTlsEncryptedV1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaTlsEncryptedV1 performs a merge with any union data inside the BaseConnectionInfoKafkaV1, using the provided KafkaTlsEncryptedV1
func (t *BaseConnectionInfoKafkaV1) MergeKafkaTlsEncryptedV1(v KafkaTlsEncryptedV1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t BaseConnectionInfoKafkaV1) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	if t.Balancer != nil {
		object["balancer"], err = json.Marshal(t.Balancer)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'balancer': %w", err)
		}
	}

	object["brokers"], err = json.Marshal(t.Brokers)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'brokers': %w", err)
	}

	if t.Compression != nil {
		object["compression"], err = json.Marshal(t.Compression)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'compression': %w", err)
		}
	}

	object["topic"], err = json.Marshal(t.Topic)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'topic': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *BaseConnectionInfoKafkaV1) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["balancer"]; found {
		err = json.Unmarshal(raw, &t.Balancer)
		if err != nil {
			return fmt.Errorf("error reading 'balancer': %w", err)
		}
	}

	if raw, found := object["brokers"]; found {
		err = json.Unmarshal(raw, &t.Brokers)
		if err != nil {
			return fmt.Errorf("error reading 'brokers': %w", err)
		}
	}

	if raw, found := object["compression"]; found {
		err = json.Unmarshal(raw, &t.Compression)
		if err != nil {
			return fmt.Errorf("error reading 'compression': %w", err)
		}
	}

	if raw, found := object["topic"]; found {
		err = json.Unmarshal(raw, &t.Topic)
		if err != nil {
			return fmt.Errorf("error reading 'topic': %w", err)
		}
	}

	return err
}

// AsCreateChronicleIntegrationConnInfoV2 returns the union data inside the CreateChronicleIntegrationRequest_ConnectionInfo as a CreateChronicleIntegrationConnInfoV2
func (t CreateChronicleIntegrationRequest_ConnectionInfo) AsCreateChronicleIntegrationConnInfoV2() (CreateChronicleIntegrationConnInfoV2, error) {
	var body CreateChronicleIntegrationConnInfoV2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateChronicleIntegrationConnInfoV2 overwrites any union data inside the CreateChronicleIntegrationRequest_ConnectionInfo as the provided CreateChronicleIntegrationConnInfoV2
func (t *CreateChronicleIntegrationRequest_ConnectionInfo) FromCreateChronicleIntegrationConnInfoV2(v CreateChronicleIntegrationConnInfoV2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateChronicleIntegrationConnInfoV2 performs a merge with any union data inside the CreateChronicleIntegrationRequest_ConnectionInfo, using the provided CreateChronicleIntegrationConnInfoV2
func (t *CreateChronicleIntegrationRequest_ConnectionInfo) MergeCreateChronicleIntegrationConnInfoV2(v CreateChronicleIntegrationConnInfoV2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateChronicleIntegrationConnInfo returns the union data inside the CreateChronicleIntegrationRequest_ConnectionInfo as a CreateChronicleIntegrationConnInfo
func (t CreateChronicleIntegrationRequest_ConnectionInfo) AsCreateChronicleIntegrationConnInfo() (CreateChronicleIntegrationConnInfo, error) {
	var body CreateChronicleIntegrationConnInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateChronicleIntegrationConnInfo overwrites any union data inside the CreateChronicleIntegrationRequest_ConnectionInfo as the provided CreateChronicleIntegrationConnInfo
func (t *CreateChronicleIntegrationRequest_ConnectionInfo) FromCreateChronicleIntegrationConnInfo(v CreateChronicleIntegrationConnInfo) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateChronicleIntegrationConnInfo performs a merge with any union data inside the CreateChronicleIntegrationRequest_ConnectionInfo, using the provided CreateChronicleIntegrationConnInfo
func (t *CreateChronicleIntegrationRequest_ConnectionInfo) MergeCreateChronicleIntegrationConnInfo(v CreateChronicleIntegrationConnInfo) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateChronicleIntegrationRequest_ConnectionInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateChronicleIntegrationRequest_ConnectionInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateChronicleIntegrationRequest returns the union data inside the CreateEfoIntegrationRequestV1 as a CreateChronicleIntegrationRequest
func (t CreateEfoIntegrationRequestV1) AsCreateChronicleIntegrationRequest() (CreateChronicleIntegrationRequest, error) {
	var body CreateChronicleIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateChronicleIntegrationRequest overwrites any union data inside the CreateEfoIntegrationRequestV1 as the provided CreateChronicleIntegrationRequest
func (t *CreateEfoIntegrationRequestV1) FromCreateChronicleIntegrationRequest(v CreateChronicleIntegrationRequest) error {
	v.Type = "CHRONICLE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateChronicleIntegrationRequest performs a merge with any union data inside the CreateEfoIntegrationRequestV1, using the provided CreateChronicleIntegrationRequest
func (t *CreateEfoIntegrationRequestV1) MergeCreateChronicleIntegrationRequest(v CreateChronicleIntegrationRequest) error {
	v.Type = "CHRONICLE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateElasticsearchIntegrationRequest returns the union data inside the CreateEfoIntegrationRequestV1 as a CreateElasticsearchIntegrationRequest
func (t CreateEfoIntegrationRequestV1) AsCreateElasticsearchIntegrationRequest() (CreateElasticsearchIntegrationRequest, error) {
	var body CreateElasticsearchIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateElasticsearchIntegrationRequest overwrites any union data inside the CreateEfoIntegrationRequestV1 as the provided CreateElasticsearchIntegrationRequest
func (t *CreateEfoIntegrationRequestV1) FromCreateElasticsearchIntegrationRequest(v CreateElasticsearchIntegrationRequest) error {
	v.Type = "ELASTIC"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateElasticsearchIntegrationRequest performs a merge with any union data inside the CreateEfoIntegrationRequestV1, using the provided CreateElasticsearchIntegrationRequest
func (t *CreateEfoIntegrationRequestV1) MergeCreateElasticsearchIntegrationRequest(v CreateElasticsearchIntegrationRequest) error {
	v.Type = "ELASTIC"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateGooglePubSubIntegrationRequest returns the union data inside the CreateEfoIntegrationRequestV1 as a CreateGooglePubSubIntegrationRequest
func (t CreateEfoIntegrationRequestV1) AsCreateGooglePubSubIntegrationRequest() (CreateGooglePubSubIntegrationRequest, error) {
	var body CreateGooglePubSubIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateGooglePubSubIntegrationRequest overwrites any union data inside the CreateEfoIntegrationRequestV1 as the provided CreateGooglePubSubIntegrationRequest
func (t *CreateEfoIntegrationRequestV1) FromCreateGooglePubSubIntegrationRequest(v CreateGooglePubSubIntegrationRequest) error {
	v.Type = "PUBSUB"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateGooglePubSubIntegrationRequest performs a merge with any union data inside the CreateEfoIntegrationRequestV1, using the provided CreateGooglePubSubIntegrationRequest
func (t *CreateEfoIntegrationRequestV1) MergeCreateGooglePubSubIntegrationRequest(v CreateGooglePubSubIntegrationRequest) error {
	v.Type = "PUBSUB"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateKafkaIntegrationRequestV1 returns the union data inside the CreateEfoIntegrationRequestV1 as a CreateKafkaIntegrationRequestV1
func (t CreateEfoIntegrationRequestV1) AsCreateKafkaIntegrationRequestV1() (CreateKafkaIntegrationRequestV1, error) {
	var body CreateKafkaIntegrationRequestV1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateKafkaIntegrationRequestV1 overwrites any union data inside the CreateEfoIntegrationRequestV1 as the provided CreateKafkaIntegrationRequestV1
func (t *CreateEfoIntegrationRequestV1) FromCreateKafkaIntegrationRequestV1(v CreateKafkaIntegrationRequestV1) error {
	v.Type = "KAFKA"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateKafkaIntegrationRequestV1 performs a merge with any union data inside the CreateEfoIntegrationRequestV1, using the provided CreateKafkaIntegrationRequestV1
func (t *CreateEfoIntegrationRequestV1) MergeCreateKafkaIntegrationRequestV1(v CreateKafkaIntegrationRequestV1) error {
	v.Type = "KAFKA"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateMcmIntegrationRequest returns the union data inside the CreateEfoIntegrationRequestV1 as a CreateMcmIntegrationRequest
func (t CreateEfoIntegrationRequestV1) AsCreateMcmIntegrationRequest() (CreateMcmIntegrationRequest, error) {
	var body CreateMcmIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateMcmIntegrationRequest overwrites any union data inside the CreateEfoIntegrationRequestV1 as the provided CreateMcmIntegrationRequest
func (t *CreateEfoIntegrationRequestV1) FromCreateMcmIntegrationRequest(v CreateMcmIntegrationRequest) error {
	v.Type = "MCM"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateMcmIntegrationRequest performs a merge with any union data inside the CreateEfoIntegrationRequestV1, using the provided CreateMcmIntegrationRequest
func (t *CreateEfoIntegrationRequestV1) MergeCreateMcmIntegrationRequest(v CreateMcmIntegrationRequest) error {
	v.Type = "MCM"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateQradarIntegrationRequest returns the union data inside the CreateEfoIntegrationRequestV1 as a CreateQradarIntegrationRequest
func (t CreateEfoIntegrationRequestV1) AsCreateQradarIntegrationRequest() (CreateQradarIntegrationRequest, error) {
	var body CreateQradarIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateQradarIntegrationRequest overwrites any union data inside the CreateEfoIntegrationRequestV1 as the provided CreateQradarIntegrationRequest
func (t *CreateEfoIntegrationRequestV1) FromCreateQradarIntegrationRequest(v CreateQradarIntegrationRequest) error {
	v.Type = "QRADAR"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateQradarIntegrationRequest performs a merge with any union data inside the CreateEfoIntegrationRequestV1, using the provided CreateQradarIntegrationRequest
func (t *CreateEfoIntegrationRequestV1) MergeCreateQradarIntegrationRequest(v CreateQradarIntegrationRequest) error {
	v.Type = "QRADAR"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateGoogleSccIntegrationRequest returns the union data inside the CreateEfoIntegrationRequestV1 as a CreateGoogleSccIntegrationRequest
func (t CreateEfoIntegrationRequestV1) AsCreateGoogleSccIntegrationRequest() (CreateGoogleSccIntegrationRequest, error) {
	var body CreateGoogleSccIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateGoogleSccIntegrationRequest overwrites any union data inside the CreateEfoIntegrationRequestV1 as the provided CreateGoogleSccIntegrationRequest
func (t *CreateEfoIntegrationRequestV1) FromCreateGoogleSccIntegrationRequest(v CreateGoogleSccIntegrationRequest) error {
	v.Type = "SCC"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateGoogleSccIntegrationRequest performs a merge with any union data inside the CreateEfoIntegrationRequestV1, using the provided CreateGoogleSccIntegrationRequest
func (t *CreateEfoIntegrationRequestV1) MergeCreateGoogleSccIntegrationRequest(v CreateGoogleSccIntegrationRequest) error {
	v.Type = "SCC"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateMicrosoftSentinelIntegrationRequest returns the union data inside the CreateEfoIntegrationRequestV1 as a CreateMicrosoftSentinelIntegrationRequest
func (t CreateEfoIntegrationRequestV1) AsCreateMicrosoftSentinelIntegrationRequest() (CreateMicrosoftSentinelIntegrationRequest, error) {
	var body CreateMicrosoftSentinelIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateMicrosoftSentinelIntegrationRequest overwrites any union data inside the CreateEfoIntegrationRequestV1 as the provided CreateMicrosoftSentinelIntegrationRequest
func (t *CreateEfoIntegrationRequestV1) FromCreateMicrosoftSentinelIntegrationRequest(v CreateMicrosoftSentinelIntegrationRequest) error {
	v.Type = "SENTINEL"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateMicrosoftSentinelIntegrationRequest performs a merge with any union data inside the CreateEfoIntegrationRequestV1, using the provided CreateMicrosoftSentinelIntegrationRequest
func (t *CreateEfoIntegrationRequestV1) MergeCreateMicrosoftSentinelIntegrationRequest(v CreateMicrosoftSentinelIntegrationRequest) error {
	v.Type = "SENTINEL"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateSplunkIntegrationRequest returns the union data inside the CreateEfoIntegrationRequestV1 as a CreateSplunkIntegrationRequest
func (t CreateEfoIntegrationRequestV1) AsCreateSplunkIntegrationRequest() (CreateSplunkIntegrationRequest, error) {
	var body CreateSplunkIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSplunkIntegrationRequest overwrites any union data inside the CreateEfoIntegrationRequestV1 as the provided CreateSplunkIntegrationRequest
func (t *CreateEfoIntegrationRequestV1) FromCreateSplunkIntegrationRequest(v CreateSplunkIntegrationRequest) error {
	v.Type = "SPLUNK"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSplunkIntegrationRequest performs a merge with any union data inside the CreateEfoIntegrationRequestV1, using the provided CreateSplunkIntegrationRequest
func (t *CreateEfoIntegrationRequestV1) MergeCreateSplunkIntegrationRequest(v CreateSplunkIntegrationRequest) error {
	v.Type = "SPLUNK"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateSyslogIntegrationRequest returns the union data inside the CreateEfoIntegrationRequestV1 as a CreateSyslogIntegrationRequest
func (t CreateEfoIntegrationRequestV1) AsCreateSyslogIntegrationRequest() (CreateSyslogIntegrationRequest, error) {
	var body CreateSyslogIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSyslogIntegrationRequest overwrites any union data inside the CreateEfoIntegrationRequestV1 as the provided CreateSyslogIntegrationRequest
func (t *CreateEfoIntegrationRequestV1) FromCreateSyslogIntegrationRequest(v CreateSyslogIntegrationRequest) error {
	v.Type = "SYSLOG"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSyslogIntegrationRequest performs a merge with any union data inside the CreateEfoIntegrationRequestV1, using the provided CreateSyslogIntegrationRequest
func (t *CreateEfoIntegrationRequestV1) MergeCreateSyslogIntegrationRequest(v CreateSyslogIntegrationRequest) error {
	v.Type = "SYSLOG"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateAmazonSqsIntegrationRequest returns the union data inside the CreateEfoIntegrationRequestV1 as a CreateAmazonSqsIntegrationRequest
func (t CreateEfoIntegrationRequestV1) AsCreateAmazonSqsIntegrationRequest() (CreateAmazonSqsIntegrationRequest, error) {
	var body CreateAmazonSqsIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateAmazonSqsIntegrationRequest overwrites any union data inside the CreateEfoIntegrationRequestV1 as the provided CreateAmazonSqsIntegrationRequest
func (t *CreateEfoIntegrationRequestV1) FromCreateAmazonSqsIntegrationRequest(v CreateAmazonSqsIntegrationRequest) error {
	v.Type = "SQS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateAmazonSqsIntegrationRequest performs a merge with any union data inside the CreateEfoIntegrationRequestV1, using the provided CreateAmazonSqsIntegrationRequest
func (t *CreateEfoIntegrationRequestV1) MergeCreateAmazonSqsIntegrationRequest(v CreateAmazonSqsIntegrationRequest) error {
	v.Type = "SQS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateWebhookIntegrationRequest returns the union data inside the CreateEfoIntegrationRequestV1 as a CreateWebhookIntegrationRequest
func (t CreateEfoIntegrationRequestV1) AsCreateWebhookIntegrationRequest() (CreateWebhookIntegrationRequest, error) {
	var body CreateWebhookIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateWebhookIntegrationRequest overwrites any union data inside the CreateEfoIntegrationRequestV1 as the provided CreateWebhookIntegrationRequest
func (t *CreateEfoIntegrationRequestV1) FromCreateWebhookIntegrationRequest(v CreateWebhookIntegrationRequest) error {
	v.Type = "WEBHOOK"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateWebhookIntegrationRequest performs a merge with any union data inside the CreateEfoIntegrationRequestV1, using the provided CreateWebhookIntegrationRequest
func (t *CreateEfoIntegrationRequestV1) MergeCreateWebhookIntegrationRequest(v CreateWebhookIntegrationRequest) error {
	v.Type = "WEBHOOK"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateEfoIntegrationRequestV1) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CreateEfoIntegrationRequestV1) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "CHRONICLE":
		return t.AsCreateChronicleIntegrationRequest()
	case "ELASTIC":
		return t.AsCreateElasticsearchIntegrationRequest()
	case "KAFKA":
		return t.AsCreateKafkaIntegrationRequestV1()
	case "MCM":
		return t.AsCreateMcmIntegrationRequest()
	case "PUBSUB":
		return t.AsCreateGooglePubSubIntegrationRequest()
	case "QRADAR":
		return t.AsCreateQradarIntegrationRequest()
	case "SCC":
		return t.AsCreateGoogleSccIntegrationRequest()
	case "SENTINEL":
		return t.AsCreateMicrosoftSentinelIntegrationRequest()
	case "SPLUNK":
		return t.AsCreateSplunkIntegrationRequest()
	case "SQS":
		return t.AsCreateAmazonSqsIntegrationRequest()
	case "SYSLOG":
		return t.AsCreateSyslogIntegrationRequest()
	case "WEBHOOK":
		return t.AsCreateWebhookIntegrationRequest()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CreateEfoIntegrationRequestV1) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateEfoIntegrationRequestV1) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBaseConnectionInfoElasticsearch returns the union data inside the CreateElasticsearchIntegrationRequest_ConnectionInfo as a BaseConnectionInfoElasticsearch
func (t CreateElasticsearchIntegrationRequest_ConnectionInfo) AsBaseConnectionInfoElasticsearch() (BaseConnectionInfoElasticsearch, error) {
	var body BaseConnectionInfoElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBaseConnectionInfoElasticsearch overwrites any union data inside the CreateElasticsearchIntegrationRequest_ConnectionInfo as the provided BaseConnectionInfoElasticsearch
func (t *CreateElasticsearchIntegrationRequest_ConnectionInfo) FromBaseConnectionInfoElasticsearch(v BaseConnectionInfoElasticsearch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBaseConnectionInfoElasticsearch performs a merge with any union data inside the CreateElasticsearchIntegrationRequest_ConnectionInfo, using the provided BaseConnectionInfoElasticsearch
func (t *CreateElasticsearchIntegrationRequest_ConnectionInfo) MergeBaseConnectionInfoElasticsearch(v BaseConnectionInfoElasticsearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAuthenticatedConnectionInfoElasticsearch returns the union data inside the CreateElasticsearchIntegrationRequest_ConnectionInfo as a AuthenticatedConnectionInfoElasticsearch
func (t CreateElasticsearchIntegrationRequest_ConnectionInfo) AsAuthenticatedConnectionInfoElasticsearch() (AuthenticatedConnectionInfoElasticsearch, error) {
	var body AuthenticatedConnectionInfoElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthenticatedConnectionInfoElasticsearch overwrites any union data inside the CreateElasticsearchIntegrationRequest_ConnectionInfo as the provided AuthenticatedConnectionInfoElasticsearch
func (t *CreateElasticsearchIntegrationRequest_ConnectionInfo) FromAuthenticatedConnectionInfoElasticsearch(v AuthenticatedConnectionInfoElasticsearch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthenticatedConnectionInfoElasticsearch performs a merge with any union data inside the CreateElasticsearchIntegrationRequest_ConnectionInfo, using the provided AuthenticatedConnectionInfoElasticsearch
func (t *CreateElasticsearchIntegrationRequest_ConnectionInfo) MergeAuthenticatedConnectionInfoElasticsearch(v AuthenticatedConnectionInfoElasticsearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateElasticsearchIntegrationRequest_ConnectionInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateElasticsearchIntegrationRequest_ConnectionInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCreateChronicleIntegrationRequest returns the union data inside the CreateIntegrationRequest as a CreateChronicleIntegrationRequest
func (t CreateIntegrationRequest) AsCreateChronicleIntegrationRequest() (CreateChronicleIntegrationRequest, error) {
	var body CreateChronicleIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateChronicleIntegrationRequest overwrites any union data inside the CreateIntegrationRequest as the provided CreateChronicleIntegrationRequest
func (t *CreateIntegrationRequest) FromCreateChronicleIntegrationRequest(v CreateChronicleIntegrationRequest) error {
	v.Type = "CHRONICLE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateChronicleIntegrationRequest performs a merge with any union data inside the CreateIntegrationRequest, using the provided CreateChronicleIntegrationRequest
func (t *CreateIntegrationRequest) MergeCreateChronicleIntegrationRequest(v CreateChronicleIntegrationRequest) error {
	v.Type = "CHRONICLE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateElasticsearchIntegrationRequest returns the union data inside the CreateIntegrationRequest as a CreateElasticsearchIntegrationRequest
func (t CreateIntegrationRequest) AsCreateElasticsearchIntegrationRequest() (CreateElasticsearchIntegrationRequest, error) {
	var body CreateElasticsearchIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateElasticsearchIntegrationRequest overwrites any union data inside the CreateIntegrationRequest as the provided CreateElasticsearchIntegrationRequest
func (t *CreateIntegrationRequest) FromCreateElasticsearchIntegrationRequest(v CreateElasticsearchIntegrationRequest) error {
	v.Type = "ELASTIC"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateElasticsearchIntegrationRequest performs a merge with any union data inside the CreateIntegrationRequest, using the provided CreateElasticsearchIntegrationRequest
func (t *CreateIntegrationRequest) MergeCreateElasticsearchIntegrationRequest(v CreateElasticsearchIntegrationRequest) error {
	v.Type = "ELASTIC"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateGooglePubSubIntegrationRequest returns the union data inside the CreateIntegrationRequest as a CreateGooglePubSubIntegrationRequest
func (t CreateIntegrationRequest) AsCreateGooglePubSubIntegrationRequest() (CreateGooglePubSubIntegrationRequest, error) {
	var body CreateGooglePubSubIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateGooglePubSubIntegrationRequest overwrites any union data inside the CreateIntegrationRequest as the provided CreateGooglePubSubIntegrationRequest
func (t *CreateIntegrationRequest) FromCreateGooglePubSubIntegrationRequest(v CreateGooglePubSubIntegrationRequest) error {
	v.Type = "PUBSUB"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateGooglePubSubIntegrationRequest performs a merge with any union data inside the CreateIntegrationRequest, using the provided CreateGooglePubSubIntegrationRequest
func (t *CreateIntegrationRequest) MergeCreateGooglePubSubIntegrationRequest(v CreateGooglePubSubIntegrationRequest) error {
	v.Type = "PUBSUB"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateKafkaIntegrationRequest returns the union data inside the CreateIntegrationRequest as a CreateKafkaIntegrationRequest
func (t CreateIntegrationRequest) AsCreateKafkaIntegrationRequest() (CreateKafkaIntegrationRequest, error) {
	var body CreateKafkaIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateKafkaIntegrationRequest overwrites any union data inside the CreateIntegrationRequest as the provided CreateKafkaIntegrationRequest
func (t *CreateIntegrationRequest) FromCreateKafkaIntegrationRequest(v CreateKafkaIntegrationRequest) error {
	v.Type = "KAFKA"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateKafkaIntegrationRequest performs a merge with any union data inside the CreateIntegrationRequest, using the provided CreateKafkaIntegrationRequest
func (t *CreateIntegrationRequest) MergeCreateKafkaIntegrationRequest(v CreateKafkaIntegrationRequest) error {
	v.Type = "KAFKA"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateMcmIntegrationRequest returns the union data inside the CreateIntegrationRequest as a CreateMcmIntegrationRequest
func (t CreateIntegrationRequest) AsCreateMcmIntegrationRequest() (CreateMcmIntegrationRequest, error) {
	var body CreateMcmIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateMcmIntegrationRequest overwrites any union data inside the CreateIntegrationRequest as the provided CreateMcmIntegrationRequest
func (t *CreateIntegrationRequest) FromCreateMcmIntegrationRequest(v CreateMcmIntegrationRequest) error {
	v.Type = "MCM"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateMcmIntegrationRequest performs a merge with any union data inside the CreateIntegrationRequest, using the provided CreateMcmIntegrationRequest
func (t *CreateIntegrationRequest) MergeCreateMcmIntegrationRequest(v CreateMcmIntegrationRequest) error {
	v.Type = "MCM"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateQradarIntegrationRequest returns the union data inside the CreateIntegrationRequest as a CreateQradarIntegrationRequest
func (t CreateIntegrationRequest) AsCreateQradarIntegrationRequest() (CreateQradarIntegrationRequest, error) {
	var body CreateQradarIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateQradarIntegrationRequest overwrites any union data inside the CreateIntegrationRequest as the provided CreateQradarIntegrationRequest
func (t *CreateIntegrationRequest) FromCreateQradarIntegrationRequest(v CreateQradarIntegrationRequest) error {
	v.Type = "QRADAR"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateQradarIntegrationRequest performs a merge with any union data inside the CreateIntegrationRequest, using the provided CreateQradarIntegrationRequest
func (t *CreateIntegrationRequest) MergeCreateQradarIntegrationRequest(v CreateQradarIntegrationRequest) error {
	v.Type = "QRADAR"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateGoogleSccIntegrationRequest returns the union data inside the CreateIntegrationRequest as a CreateGoogleSccIntegrationRequest
func (t CreateIntegrationRequest) AsCreateGoogleSccIntegrationRequest() (CreateGoogleSccIntegrationRequest, error) {
	var body CreateGoogleSccIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateGoogleSccIntegrationRequest overwrites any union data inside the CreateIntegrationRequest as the provided CreateGoogleSccIntegrationRequest
func (t *CreateIntegrationRequest) FromCreateGoogleSccIntegrationRequest(v CreateGoogleSccIntegrationRequest) error {
	v.Type = "SCC"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateGoogleSccIntegrationRequest performs a merge with any union data inside the CreateIntegrationRequest, using the provided CreateGoogleSccIntegrationRequest
func (t *CreateIntegrationRequest) MergeCreateGoogleSccIntegrationRequest(v CreateGoogleSccIntegrationRequest) error {
	v.Type = "SCC"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateMicrosoftSentinelIntegrationRequest returns the union data inside the CreateIntegrationRequest as a CreateMicrosoftSentinelIntegrationRequest
func (t CreateIntegrationRequest) AsCreateMicrosoftSentinelIntegrationRequest() (CreateMicrosoftSentinelIntegrationRequest, error) {
	var body CreateMicrosoftSentinelIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateMicrosoftSentinelIntegrationRequest overwrites any union data inside the CreateIntegrationRequest as the provided CreateMicrosoftSentinelIntegrationRequest
func (t *CreateIntegrationRequest) FromCreateMicrosoftSentinelIntegrationRequest(v CreateMicrosoftSentinelIntegrationRequest) error {
	v.Type = "SENTINEL"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateMicrosoftSentinelIntegrationRequest performs a merge with any union data inside the CreateIntegrationRequest, using the provided CreateMicrosoftSentinelIntegrationRequest
func (t *CreateIntegrationRequest) MergeCreateMicrosoftSentinelIntegrationRequest(v CreateMicrosoftSentinelIntegrationRequest) error {
	v.Type = "SENTINEL"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateSplunkIntegrationRequest returns the union data inside the CreateIntegrationRequest as a CreateSplunkIntegrationRequest
func (t CreateIntegrationRequest) AsCreateSplunkIntegrationRequest() (CreateSplunkIntegrationRequest, error) {
	var body CreateSplunkIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSplunkIntegrationRequest overwrites any union data inside the CreateIntegrationRequest as the provided CreateSplunkIntegrationRequest
func (t *CreateIntegrationRequest) FromCreateSplunkIntegrationRequest(v CreateSplunkIntegrationRequest) error {
	v.Type = "SPLUNK"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSplunkIntegrationRequest performs a merge with any union data inside the CreateIntegrationRequest, using the provided CreateSplunkIntegrationRequest
func (t *CreateIntegrationRequest) MergeCreateSplunkIntegrationRequest(v CreateSplunkIntegrationRequest) error {
	v.Type = "SPLUNK"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateSyslogIntegrationRequest returns the union data inside the CreateIntegrationRequest as a CreateSyslogIntegrationRequest
func (t CreateIntegrationRequest) AsCreateSyslogIntegrationRequest() (CreateSyslogIntegrationRequest, error) {
	var body CreateSyslogIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateSyslogIntegrationRequest overwrites any union data inside the CreateIntegrationRequest as the provided CreateSyslogIntegrationRequest
func (t *CreateIntegrationRequest) FromCreateSyslogIntegrationRequest(v CreateSyslogIntegrationRequest) error {
	v.Type = "SYSLOG"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateSyslogIntegrationRequest performs a merge with any union data inside the CreateIntegrationRequest, using the provided CreateSyslogIntegrationRequest
func (t *CreateIntegrationRequest) MergeCreateSyslogIntegrationRequest(v CreateSyslogIntegrationRequest) error {
	v.Type = "SYSLOG"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateAmazonSqsIntegrationRequest returns the union data inside the CreateIntegrationRequest as a CreateAmazonSqsIntegrationRequest
func (t CreateIntegrationRequest) AsCreateAmazonSqsIntegrationRequest() (CreateAmazonSqsIntegrationRequest, error) {
	var body CreateAmazonSqsIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateAmazonSqsIntegrationRequest overwrites any union data inside the CreateIntegrationRequest as the provided CreateAmazonSqsIntegrationRequest
func (t *CreateIntegrationRequest) FromCreateAmazonSqsIntegrationRequest(v CreateAmazonSqsIntegrationRequest) error {
	v.Type = "SQS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateAmazonSqsIntegrationRequest performs a merge with any union data inside the CreateIntegrationRequest, using the provided CreateAmazonSqsIntegrationRequest
func (t *CreateIntegrationRequest) MergeCreateAmazonSqsIntegrationRequest(v CreateAmazonSqsIntegrationRequest) error {
	v.Type = "SQS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateWebhookIntegrationRequest returns the union data inside the CreateIntegrationRequest as a CreateWebhookIntegrationRequest
func (t CreateIntegrationRequest) AsCreateWebhookIntegrationRequest() (CreateWebhookIntegrationRequest, error) {
	var body CreateWebhookIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateWebhookIntegrationRequest overwrites any union data inside the CreateIntegrationRequest as the provided CreateWebhookIntegrationRequest
func (t *CreateIntegrationRequest) FromCreateWebhookIntegrationRequest(v CreateWebhookIntegrationRequest) error {
	v.Type = "WEBHOOK"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateWebhookIntegrationRequest performs a merge with any union data inside the CreateIntegrationRequest, using the provided CreateWebhookIntegrationRequest
func (t *CreateIntegrationRequest) MergeCreateWebhookIntegrationRequest(v CreateWebhookIntegrationRequest) error {
	v.Type = "WEBHOOK"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateIntegrationRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t CreateIntegrationRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "CHRONICLE":
		return t.AsCreateChronicleIntegrationRequest()
	case "ELASTIC":
		return t.AsCreateElasticsearchIntegrationRequest()
	case "KAFKA":
		return t.AsCreateKafkaIntegrationRequest()
	case "MCM":
		return t.AsCreateMcmIntegrationRequest()
	case "PUBSUB":
		return t.AsCreateGooglePubSubIntegrationRequest()
	case "QRADAR":
		return t.AsCreateQradarIntegrationRequest()
	case "SCC":
		return t.AsCreateGoogleSccIntegrationRequest()
	case "SENTINEL":
		return t.AsCreateMicrosoftSentinelIntegrationRequest()
	case "SPLUNK":
		return t.AsCreateSplunkIntegrationRequest()
	case "SQS":
		return t.AsCreateAmazonSqsIntegrationRequest()
	case "SYSLOG":
		return t.AsCreateSyslogIntegrationRequest()
	case "WEBHOOK":
		return t.AsCreateWebhookIntegrationRequest()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t CreateIntegrationRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateIntegrationRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBaseConnectionInfoKafka returns the union data inside the CreateKafkaIntegrationRequest_ConnectionInfo as a BaseConnectionInfoKafka
func (t CreateKafkaIntegrationRequest_ConnectionInfo) AsBaseConnectionInfoKafka() (BaseConnectionInfoKafka, error) {
	var body BaseConnectionInfoKafka
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBaseConnectionInfoKafka overwrites any union data inside the CreateKafkaIntegrationRequest_ConnectionInfo as the provided BaseConnectionInfoKafka
func (t *CreateKafkaIntegrationRequest_ConnectionInfo) FromBaseConnectionInfoKafka(v BaseConnectionInfoKafka) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBaseConnectionInfoKafka performs a merge with any union data inside the CreateKafkaIntegrationRequest_ConnectionInfo, using the provided BaseConnectionInfoKafka
func (t *CreateKafkaIntegrationRequest_ConnectionInfo) MergeBaseConnectionInfoKafka(v BaseConnectionInfoKafka) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKafkaAuthenticatedPrivateConnectionInfo returns the union data inside the CreateKafkaIntegrationRequest_ConnectionInfo as a KafkaAuthenticatedPrivateConnectionInfo
func (t CreateKafkaIntegrationRequest_ConnectionInfo) AsKafkaAuthenticatedPrivateConnectionInfo() (KafkaAuthenticatedPrivateConnectionInfo, error) {
	var body KafkaAuthenticatedPrivateConnectionInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaAuthenticatedPrivateConnectionInfo overwrites any union data inside the CreateKafkaIntegrationRequest_ConnectionInfo as the provided KafkaAuthenticatedPrivateConnectionInfo
func (t *CreateKafkaIntegrationRequest_ConnectionInfo) FromKafkaAuthenticatedPrivateConnectionInfo(v KafkaAuthenticatedPrivateConnectionInfo) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaAuthenticatedPrivateConnectionInfo performs a merge with any union data inside the CreateKafkaIntegrationRequest_ConnectionInfo, using the provided KafkaAuthenticatedPrivateConnectionInfo
func (t *CreateKafkaIntegrationRequest_ConnectionInfo) MergeKafkaAuthenticatedPrivateConnectionInfo(v KafkaAuthenticatedPrivateConnectionInfo) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateKafkaIntegrationRequest_ConnectionInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateKafkaIntegrationRequest_ConnectionInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBaseConnectionInfoKafkaV1 returns the union data inside the CreateKafkaIntegrationRequestV1_ConnectionInfo as a BaseConnectionInfoKafkaV1
func (t CreateKafkaIntegrationRequestV1_ConnectionInfo) AsBaseConnectionInfoKafkaV1() (BaseConnectionInfoKafkaV1, error) {
	var body BaseConnectionInfoKafkaV1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBaseConnectionInfoKafkaV1 overwrites any union data inside the CreateKafkaIntegrationRequestV1_ConnectionInfo as the provided BaseConnectionInfoKafkaV1
func (t *CreateKafkaIntegrationRequestV1_ConnectionInfo) FromBaseConnectionInfoKafkaV1(v BaseConnectionInfoKafkaV1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBaseConnectionInfoKafkaV1 performs a merge with any union data inside the CreateKafkaIntegrationRequestV1_ConnectionInfo, using the provided BaseConnectionInfoKafkaV1
func (t *CreateKafkaIntegrationRequestV1_ConnectionInfo) MergeBaseConnectionInfoKafkaV1(v BaseConnectionInfoKafkaV1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAuthenticatedConnectionInfoKafkaV1 returns the union data inside the CreateKafkaIntegrationRequestV1_ConnectionInfo as a AuthenticatedConnectionInfoKafkaV1
func (t CreateKafkaIntegrationRequestV1_ConnectionInfo) AsAuthenticatedConnectionInfoKafkaV1() (AuthenticatedConnectionInfoKafkaV1, error) {
	var body AuthenticatedConnectionInfoKafkaV1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthenticatedConnectionInfoKafkaV1 overwrites any union data inside the CreateKafkaIntegrationRequestV1_ConnectionInfo as the provided AuthenticatedConnectionInfoKafkaV1
func (t *CreateKafkaIntegrationRequestV1_ConnectionInfo) FromAuthenticatedConnectionInfoKafkaV1(v AuthenticatedConnectionInfoKafkaV1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthenticatedConnectionInfoKafkaV1 performs a merge with any union data inside the CreateKafkaIntegrationRequestV1_ConnectionInfo, using the provided AuthenticatedConnectionInfoKafkaV1
func (t *CreateKafkaIntegrationRequestV1_ConnectionInfo) MergeAuthenticatedConnectionInfoKafkaV1(v AuthenticatedConnectionInfoKafkaV1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateKafkaIntegrationRequestV1_ConnectionInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateKafkaIntegrationRequestV1_ConnectionInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsContextEmpty returns the union data inside the CreateRiskAcceptedRequest_Context as a ContextEmpty
func (t CreateRiskAcceptedRequest_Context) AsContextEmpty() (ContextEmpty, error) {
	var body ContextEmpty
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextEmpty overwrites any union data inside the CreateRiskAcceptedRequest_Context as the provided ContextEmpty
func (t *CreateRiskAcceptedRequest_Context) FromContextEmpty(v ContextEmpty) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextEmpty performs a merge with any union data inside the CreateRiskAcceptedRequest_Context, using the provided ContextEmpty
func (t *CreateRiskAcceptedRequest_Context) MergeContextEmpty(v ContextEmpty) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContextImageName returns the union data inside the CreateRiskAcceptedRequest_Context as a ContextImageName
func (t CreateRiskAcceptedRequest_Context) AsContextImageName() (ContextImageName, error) {
	var body ContextImageName
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextImageName overwrites any union data inside the CreateRiskAcceptedRequest_Context as the provided ContextImageName
func (t *CreateRiskAcceptedRequest_Context) FromContextImageName(v ContextImageName) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextImageName performs a merge with any union data inside the CreateRiskAcceptedRequest_Context, using the provided ContextImageName
func (t *CreateRiskAcceptedRequest_Context) MergeContextImageName(v ContextImageName) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContextImageSuffix returns the union data inside the CreateRiskAcceptedRequest_Context as a ContextImageSuffix
func (t CreateRiskAcceptedRequest_Context) AsContextImageSuffix() (ContextImageSuffix, error) {
	var body ContextImageSuffix
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextImageSuffix overwrites any union data inside the CreateRiskAcceptedRequest_Context as the provided ContextImageSuffix
func (t *CreateRiskAcceptedRequest_Context) FromContextImageSuffix(v ContextImageSuffix) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextImageSuffix performs a merge with any union data inside the CreateRiskAcceptedRequest_Context, using the provided ContextImageSuffix
func (t *CreateRiskAcceptedRequest_Context) MergeContextImageSuffix(v ContextImageSuffix) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContextImagePrefix returns the union data inside the CreateRiskAcceptedRequest_Context as a ContextImagePrefix
func (t CreateRiskAcceptedRequest_Context) AsContextImagePrefix() (ContextImagePrefix, error) {
	var body ContextImagePrefix
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextImagePrefix overwrites any union data inside the CreateRiskAcceptedRequest_Context as the provided ContextImagePrefix
func (t *CreateRiskAcceptedRequest_Context) FromContextImagePrefix(v ContextImagePrefix) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextImagePrefix performs a merge with any union data inside the CreateRiskAcceptedRequest_Context, using the provided ContextImagePrefix
func (t *CreateRiskAcceptedRequest_Context) MergeContextImagePrefix(v ContextImagePrefix) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContextImageContains returns the union data inside the CreateRiskAcceptedRequest_Context as a ContextImageContains
func (t CreateRiskAcceptedRequest_Context) AsContextImageContains() (ContextImageContains, error) {
	var body ContextImageContains
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextImageContains overwrites any union data inside the CreateRiskAcceptedRequest_Context as the provided ContextImageContains
func (t *CreateRiskAcceptedRequest_Context) FromContextImageContains(v ContextImageContains) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextImageContains performs a merge with any union data inside the CreateRiskAcceptedRequest_Context, using the provided ContextImageContains
func (t *CreateRiskAcceptedRequest_Context) MergeContextImageContains(v ContextImageContains) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContextPackageName returns the union data inside the CreateRiskAcceptedRequest_Context as a ContextPackageName
func (t CreateRiskAcceptedRequest_Context) AsContextPackageName() (ContextPackageName, error) {
	var body ContextPackageName
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextPackageName overwrites any union data inside the CreateRiskAcceptedRequest_Context as the provided ContextPackageName
func (t *CreateRiskAcceptedRequest_Context) FromContextPackageName(v ContextPackageName) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextPackageName performs a merge with any union data inside the CreateRiskAcceptedRequest_Context, using the provided ContextPackageName
func (t *CreateRiskAcceptedRequest_Context) MergeContextPackageName(v ContextPackageName) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContextPackageNameVersion returns the union data inside the CreateRiskAcceptedRequest_Context as a ContextPackageNameVersion
func (t CreateRiskAcceptedRequest_Context) AsContextPackageNameVersion() (ContextPackageNameVersion, error) {
	var body ContextPackageNameVersion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextPackageNameVersion overwrites any union data inside the CreateRiskAcceptedRequest_Context as the provided ContextPackageNameVersion
func (t *CreateRiskAcceptedRequest_Context) FromContextPackageNameVersion(v ContextPackageNameVersion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextPackageNameVersion performs a merge with any union data inside the CreateRiskAcceptedRequest_Context, using the provided ContextPackageNameVersion
func (t *CreateRiskAcceptedRequest_Context) MergeContextPackageNameVersion(v ContextPackageNameVersion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContextHostName returns the union data inside the CreateRiskAcceptedRequest_Context as a ContextHostName
func (t CreateRiskAcceptedRequest_Context) AsContextHostName() (ContextHostName, error) {
	var body ContextHostName
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextHostName overwrites any union data inside the CreateRiskAcceptedRequest_Context as the provided ContextHostName
func (t *CreateRiskAcceptedRequest_Context) FromContextHostName(v ContextHostName) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextHostName performs a merge with any union data inside the CreateRiskAcceptedRequest_Context, using the provided ContextHostName
func (t *CreateRiskAcceptedRequest_Context) MergeContextHostName(v ContextHostName) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContextHostContains returns the union data inside the CreateRiskAcceptedRequest_Context as a ContextHostContains
func (t CreateRiskAcceptedRequest_Context) AsContextHostContains() (ContextHostContains, error) {
	var body ContextHostContains
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextHostContains overwrites any union data inside the CreateRiskAcceptedRequest_Context as the provided ContextHostContains
func (t *CreateRiskAcceptedRequest_Context) FromContextHostContains(v ContextHostContains) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextHostContains performs a merge with any union data inside the CreateRiskAcceptedRequest_Context, using the provided ContextHostContains
func (t *CreateRiskAcceptedRequest_Context) MergeContextHostContains(v ContextHostContains) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContextPackagePath returns the union data inside the CreateRiskAcceptedRequest_Context as a ContextPackagePath
func (t CreateRiskAcceptedRequest_Context) AsContextPackagePath() (ContextPackagePath, error) {
	var body ContextPackagePath
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextPackagePath overwrites any union data inside the CreateRiskAcceptedRequest_Context as the provided ContextPackagePath
func (t *CreateRiskAcceptedRequest_Context) FromContextPackagePath(v ContextPackagePath) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextPackagePath performs a merge with any union data inside the CreateRiskAcceptedRequest_Context, using the provided ContextPackagePath
func (t *CreateRiskAcceptedRequest_Context) MergeContextPackagePath(v ContextPackagePath) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContextPackageVersion returns the union data inside the CreateRiskAcceptedRequest_Context as a ContextPackageVersion
func (t CreateRiskAcceptedRequest_Context) AsContextPackageVersion() (ContextPackageVersion, error) {
	var body ContextPackageVersion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextPackageVersion overwrites any union data inside the CreateRiskAcceptedRequest_Context as the provided ContextPackageVersion
func (t *CreateRiskAcceptedRequest_Context) FromContextPackageVersion(v ContextPackageVersion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextPackageVersion performs a merge with any union data inside the CreateRiskAcceptedRequest_Context, using the provided ContextPackageVersion
func (t *CreateRiskAcceptedRequest_Context) MergeContextPackageVersion(v ContextPackageVersion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContextPackagePathVersion returns the union data inside the CreateRiskAcceptedRequest_Context as a ContextPackagePathVersion
func (t CreateRiskAcceptedRequest_Context) AsContextPackagePathVersion() (ContextPackagePathVersion, error) {
	var body ContextPackagePathVersion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextPackagePathVersion overwrites any union data inside the CreateRiskAcceptedRequest_Context as the provided ContextPackagePathVersion
func (t *CreateRiskAcceptedRequest_Context) FromContextPackagePathVersion(v ContextPackagePathVersion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextPackagePathVersion performs a merge with any union data inside the CreateRiskAcceptedRequest_Context, using the provided ContextPackagePathVersion
func (t *CreateRiskAcceptedRequest_Context) MergeContextPackagePathVersion(v ContextPackagePathVersion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateRiskAcceptedRequest_Context) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateRiskAcceptedRequest_Context) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBaseConnectionInfoWebhook returns the union data inside the CreateWebhookIntegrationRequest_ConnectionInfo as a BaseConnectionInfoWebhook
func (t CreateWebhookIntegrationRequest_ConnectionInfo) AsBaseConnectionInfoWebhook() (BaseConnectionInfoWebhook, error) {
	var body BaseConnectionInfoWebhook
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBaseConnectionInfoWebhook overwrites any union data inside the CreateWebhookIntegrationRequest_ConnectionInfo as the provided BaseConnectionInfoWebhook
func (t *CreateWebhookIntegrationRequest_ConnectionInfo) FromBaseConnectionInfoWebhook(v BaseConnectionInfoWebhook) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBaseConnectionInfoWebhook performs a merge with any union data inside the CreateWebhookIntegrationRequest_ConnectionInfo, using the provided BaseConnectionInfoWebhook
func (t *CreateWebhookIntegrationRequest_ConnectionInfo) MergeBaseConnectionInfoWebhook(v BaseConnectionInfoWebhook) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAuthenticatedConnectionInfoWebhook returns the union data inside the CreateWebhookIntegrationRequest_ConnectionInfo as a AuthenticatedConnectionInfoWebhook
func (t CreateWebhookIntegrationRequest_ConnectionInfo) AsAuthenticatedConnectionInfoWebhook() (AuthenticatedConnectionInfoWebhook, error) {
	var body AuthenticatedConnectionInfoWebhook
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAuthenticatedConnectionInfoWebhook overwrites any union data inside the CreateWebhookIntegrationRequest_ConnectionInfo as the provided AuthenticatedConnectionInfoWebhook
func (t *CreateWebhookIntegrationRequest_ConnectionInfo) FromAuthenticatedConnectionInfoWebhook(v AuthenticatedConnectionInfoWebhook) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAuthenticatedConnectionInfoWebhook performs a merge with any union data inside the CreateWebhookIntegrationRequest_ConnectionInfo, using the provided AuthenticatedConnectionInfoWebhook
func (t *CreateWebhookIntegrationRequest_ConnectionInfo) MergeAuthenticatedConnectionInfoWebhook(v AuthenticatedConnectionInfoWebhook) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateWebhookIntegrationRequest_ConnectionInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateWebhookIntegrationRequest_ConnectionInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsGetAmazonSqsIntegrationResponse returns the union data inside the EfoIntegrationResponseV1 as a GetAmazonSqsIntegrationResponse
func (t EfoIntegrationResponseV1) AsGetAmazonSqsIntegrationResponse() (GetAmazonSqsIntegrationResponse, error) {
	var body GetAmazonSqsIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetAmazonSqsIntegrationResponse overwrites any union data inside the EfoIntegrationResponseV1 as the provided GetAmazonSqsIntegrationResponse
func (t *EfoIntegrationResponseV1) FromGetAmazonSqsIntegrationResponse(v GetAmazonSqsIntegrationResponse) error {
	v.Type = "SQS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetAmazonSqsIntegrationResponse performs a merge with any union data inside the EfoIntegrationResponseV1, using the provided GetAmazonSqsIntegrationResponse
func (t *EfoIntegrationResponseV1) MergeGetAmazonSqsIntegrationResponse(v GetAmazonSqsIntegrationResponse) error {
	v.Type = "SQS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetChronicleIntegrationResponse returns the union data inside the EfoIntegrationResponseV1 as a GetChronicleIntegrationResponse
func (t EfoIntegrationResponseV1) AsGetChronicleIntegrationResponse() (GetChronicleIntegrationResponse, error) {
	var body GetChronicleIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetChronicleIntegrationResponse overwrites any union data inside the EfoIntegrationResponseV1 as the provided GetChronicleIntegrationResponse
func (t *EfoIntegrationResponseV1) FromGetChronicleIntegrationResponse(v GetChronicleIntegrationResponse) error {
	v.Type = "CHRONICLE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetChronicleIntegrationResponse performs a merge with any union data inside the EfoIntegrationResponseV1, using the provided GetChronicleIntegrationResponse
func (t *EfoIntegrationResponseV1) MergeGetChronicleIntegrationResponse(v GetChronicleIntegrationResponse) error {
	v.Type = "CHRONICLE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetElasticsearchIntegrationResponse returns the union data inside the EfoIntegrationResponseV1 as a GetElasticsearchIntegrationResponse
func (t EfoIntegrationResponseV1) AsGetElasticsearchIntegrationResponse() (GetElasticsearchIntegrationResponse, error) {
	var body GetElasticsearchIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetElasticsearchIntegrationResponse overwrites any union data inside the EfoIntegrationResponseV1 as the provided GetElasticsearchIntegrationResponse
func (t *EfoIntegrationResponseV1) FromGetElasticsearchIntegrationResponse(v GetElasticsearchIntegrationResponse) error {
	v.Type = "ELASTIC"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetElasticsearchIntegrationResponse performs a merge with any union data inside the EfoIntegrationResponseV1, using the provided GetElasticsearchIntegrationResponse
func (t *EfoIntegrationResponseV1) MergeGetElasticsearchIntegrationResponse(v GetElasticsearchIntegrationResponse) error {
	v.Type = "ELASTIC"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetGooglePubSubIntegrationResponse returns the union data inside the EfoIntegrationResponseV1 as a GetGooglePubSubIntegrationResponse
func (t EfoIntegrationResponseV1) AsGetGooglePubSubIntegrationResponse() (GetGooglePubSubIntegrationResponse, error) {
	var body GetGooglePubSubIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetGooglePubSubIntegrationResponse overwrites any union data inside the EfoIntegrationResponseV1 as the provided GetGooglePubSubIntegrationResponse
func (t *EfoIntegrationResponseV1) FromGetGooglePubSubIntegrationResponse(v GetGooglePubSubIntegrationResponse) error {
	v.Type = "PUBSUB"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetGooglePubSubIntegrationResponse performs a merge with any union data inside the EfoIntegrationResponseV1, using the provided GetGooglePubSubIntegrationResponse
func (t *EfoIntegrationResponseV1) MergeGetGooglePubSubIntegrationResponse(v GetGooglePubSubIntegrationResponse) error {
	v.Type = "PUBSUB"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetGoogleSccIntegrationResponse returns the union data inside the EfoIntegrationResponseV1 as a GetGoogleSccIntegrationResponse
func (t EfoIntegrationResponseV1) AsGetGoogleSccIntegrationResponse() (GetGoogleSccIntegrationResponse, error) {
	var body GetGoogleSccIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetGoogleSccIntegrationResponse overwrites any union data inside the EfoIntegrationResponseV1 as the provided GetGoogleSccIntegrationResponse
func (t *EfoIntegrationResponseV1) FromGetGoogleSccIntegrationResponse(v GetGoogleSccIntegrationResponse) error {
	v.Type = "SCC"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetGoogleSccIntegrationResponse performs a merge with any union data inside the EfoIntegrationResponseV1, using the provided GetGoogleSccIntegrationResponse
func (t *EfoIntegrationResponseV1) MergeGetGoogleSccIntegrationResponse(v GetGoogleSccIntegrationResponse) error {
	v.Type = "SCC"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetKafkaIntegrationResponseV1 returns the union data inside the EfoIntegrationResponseV1 as a GetKafkaIntegrationResponseV1
func (t EfoIntegrationResponseV1) AsGetKafkaIntegrationResponseV1() (GetKafkaIntegrationResponseV1, error) {
	var body GetKafkaIntegrationResponseV1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetKafkaIntegrationResponseV1 overwrites any union data inside the EfoIntegrationResponseV1 as the provided GetKafkaIntegrationResponseV1
func (t *EfoIntegrationResponseV1) FromGetKafkaIntegrationResponseV1(v GetKafkaIntegrationResponseV1) error {
	v.Type = "KAFKA"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetKafkaIntegrationResponseV1 performs a merge with any union data inside the EfoIntegrationResponseV1, using the provided GetKafkaIntegrationResponseV1
func (t *EfoIntegrationResponseV1) MergeGetKafkaIntegrationResponseV1(v GetKafkaIntegrationResponseV1) error {
	v.Type = "KAFKA"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetMcmIntegrationResponse returns the union data inside the EfoIntegrationResponseV1 as a GetMcmIntegrationResponse
func (t EfoIntegrationResponseV1) AsGetMcmIntegrationResponse() (GetMcmIntegrationResponse, error) {
	var body GetMcmIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetMcmIntegrationResponse overwrites any union data inside the EfoIntegrationResponseV1 as the provided GetMcmIntegrationResponse
func (t *EfoIntegrationResponseV1) FromGetMcmIntegrationResponse(v GetMcmIntegrationResponse) error {
	v.Type = "MCM"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetMcmIntegrationResponse performs a merge with any union data inside the EfoIntegrationResponseV1, using the provided GetMcmIntegrationResponse
func (t *EfoIntegrationResponseV1) MergeGetMcmIntegrationResponse(v GetMcmIntegrationResponse) error {
	v.Type = "MCM"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetMicrosoftSentinelIntegrationResponse returns the union data inside the EfoIntegrationResponseV1 as a GetMicrosoftSentinelIntegrationResponse
func (t EfoIntegrationResponseV1) AsGetMicrosoftSentinelIntegrationResponse() (GetMicrosoftSentinelIntegrationResponse, error) {
	var body GetMicrosoftSentinelIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetMicrosoftSentinelIntegrationResponse overwrites any union data inside the EfoIntegrationResponseV1 as the provided GetMicrosoftSentinelIntegrationResponse
func (t *EfoIntegrationResponseV1) FromGetMicrosoftSentinelIntegrationResponse(v GetMicrosoftSentinelIntegrationResponse) error {
	v.Type = "SENTINEL"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetMicrosoftSentinelIntegrationResponse performs a merge with any union data inside the EfoIntegrationResponseV1, using the provided GetMicrosoftSentinelIntegrationResponse
func (t *EfoIntegrationResponseV1) MergeGetMicrosoftSentinelIntegrationResponse(v GetMicrosoftSentinelIntegrationResponse) error {
	v.Type = "SENTINEL"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetQradarIntegrationResponse returns the union data inside the EfoIntegrationResponseV1 as a GetQradarIntegrationResponse
func (t EfoIntegrationResponseV1) AsGetQradarIntegrationResponse() (GetQradarIntegrationResponse, error) {
	var body GetQradarIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetQradarIntegrationResponse overwrites any union data inside the EfoIntegrationResponseV1 as the provided GetQradarIntegrationResponse
func (t *EfoIntegrationResponseV1) FromGetQradarIntegrationResponse(v GetQradarIntegrationResponse) error {
	v.Type = "QRADAR"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetQradarIntegrationResponse performs a merge with any union data inside the EfoIntegrationResponseV1, using the provided GetQradarIntegrationResponse
func (t *EfoIntegrationResponseV1) MergeGetQradarIntegrationResponse(v GetQradarIntegrationResponse) error {
	v.Type = "QRADAR"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetSplunkIntegrationResponse returns the union data inside the EfoIntegrationResponseV1 as a GetSplunkIntegrationResponse
func (t EfoIntegrationResponseV1) AsGetSplunkIntegrationResponse() (GetSplunkIntegrationResponse, error) {
	var body GetSplunkIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetSplunkIntegrationResponse overwrites any union data inside the EfoIntegrationResponseV1 as the provided GetSplunkIntegrationResponse
func (t *EfoIntegrationResponseV1) FromGetSplunkIntegrationResponse(v GetSplunkIntegrationResponse) error {
	v.Type = "SPLUNK"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetSplunkIntegrationResponse performs a merge with any union data inside the EfoIntegrationResponseV1, using the provided GetSplunkIntegrationResponse
func (t *EfoIntegrationResponseV1) MergeGetSplunkIntegrationResponse(v GetSplunkIntegrationResponse) error {
	v.Type = "SPLUNK"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetSyslogIntegrationResponse returns the union data inside the EfoIntegrationResponseV1 as a GetSyslogIntegrationResponse
func (t EfoIntegrationResponseV1) AsGetSyslogIntegrationResponse() (GetSyslogIntegrationResponse, error) {
	var body GetSyslogIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetSyslogIntegrationResponse overwrites any union data inside the EfoIntegrationResponseV1 as the provided GetSyslogIntegrationResponse
func (t *EfoIntegrationResponseV1) FromGetSyslogIntegrationResponse(v GetSyslogIntegrationResponse) error {
	v.Type = "SYSLOG"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetSyslogIntegrationResponse performs a merge with any union data inside the EfoIntegrationResponseV1, using the provided GetSyslogIntegrationResponse
func (t *EfoIntegrationResponseV1) MergeGetSyslogIntegrationResponse(v GetSyslogIntegrationResponse) error {
	v.Type = "SYSLOG"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetWebhookIntegrationResponse returns the union data inside the EfoIntegrationResponseV1 as a GetWebhookIntegrationResponse
func (t EfoIntegrationResponseV1) AsGetWebhookIntegrationResponse() (GetWebhookIntegrationResponse, error) {
	var body GetWebhookIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetWebhookIntegrationResponse overwrites any union data inside the EfoIntegrationResponseV1 as the provided GetWebhookIntegrationResponse
func (t *EfoIntegrationResponseV1) FromGetWebhookIntegrationResponse(v GetWebhookIntegrationResponse) error {
	v.Type = "WEBHOOK"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetWebhookIntegrationResponse performs a merge with any union data inside the EfoIntegrationResponseV1, using the provided GetWebhookIntegrationResponse
func (t *EfoIntegrationResponseV1) MergeGetWebhookIntegrationResponse(v GetWebhookIntegrationResponse) error {
	v.Type = "WEBHOOK"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EfoIntegrationResponseV1) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t EfoIntegrationResponseV1) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "CHRONICLE":
		return t.AsGetChronicleIntegrationResponse()
	case "ELASTIC":
		return t.AsGetElasticsearchIntegrationResponse()
	case "KAFKA":
		return t.AsGetKafkaIntegrationResponseV1()
	case "MCM":
		return t.AsGetMcmIntegrationResponse()
	case "PUBSUB":
		return t.AsGetGooglePubSubIntegrationResponse()
	case "QRADAR":
		return t.AsGetQradarIntegrationResponse()
	case "SCC":
		return t.AsGetGoogleSccIntegrationResponse()
	case "SENTINEL":
		return t.AsGetMicrosoftSentinelIntegrationResponse()
	case "SPLUNK":
		return t.AsGetSplunkIntegrationResponse()
	case "SQS":
		return t.AsGetAmazonSqsIntegrationResponse()
	case "SYSLOG":
		return t.AsGetSyslogIntegrationResponse()
	case "WEBHOOK":
		return t.AsGetWebhookIntegrationResponse()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t EfoIntegrationResponseV1) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EfoIntegrationResponseV1) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCommand returns the union data inside the EntriesResponse_Data_Item as a Command
func (t EntriesResponse_Data_Item) AsCommand() (Command, error) {
	var body Command
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCommand overwrites any union data inside the EntriesResponse_Data_Item as the provided Command
func (t *EntriesResponse_Data_Item) FromCommand(v Command) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCommand performs a merge with any union data inside the EntriesResponse_Data_Item, using the provided Command
func (t *EntriesResponse_Data_Item) MergeCommand(v Command) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnection returns the union data inside the EntriesResponse_Data_Item as a Connection
func (t EntriesResponse_Data_Item) AsConnection() (Connection, error) {
	var body Connection
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnection overwrites any union data inside the EntriesResponse_Data_Item as the provided Connection
func (t *EntriesResponse_Data_Item) FromConnection(v Connection) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnection performs a merge with any union data inside the EntriesResponse_Data_Item, using the provided Connection
func (t *EntriesResponse_Data_Item) MergeConnection(v Connection) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFileaccess returns the union data inside the EntriesResponse_Data_Item as a Fileaccess
func (t EntriesResponse_Data_Item) AsFileaccess() (Fileaccess, error) {
	var body Fileaccess
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFileaccess overwrites any union data inside the EntriesResponse_Data_Item as the provided Fileaccess
func (t *EntriesResponse_Data_Item) FromFileaccess(v Fileaccess) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFileaccess performs a merge with any union data inside the EntriesResponse_Data_Item, using the provided Fileaccess
func (t *EntriesResponse_Data_Item) MergeFileaccess(v Fileaccess) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKubernetes returns the union data inside the EntriesResponse_Data_Item as a Kubernetes
func (t EntriesResponse_Data_Item) AsKubernetes() (Kubernetes, error) {
	var body Kubernetes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKubernetes overwrites any union data inside the EntriesResponse_Data_Item as the provided Kubernetes
func (t *EntriesResponse_Data_Item) FromKubernetes(v Kubernetes) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKubernetes performs a merge with any union data inside the EntriesResponse_Data_Item, using the provided Kubernetes
func (t *EntriesResponse_Data_Item) MergeKubernetes(v Kubernetes) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EntriesResponse_Data_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EntriesResponse_Data_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCommand returns the union data inside the EntryResponse as a Command
func (t EntryResponse) AsCommand() (Command, error) {
	var body Command
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCommand overwrites any union data inside the EntryResponse as the provided Command
func (t *EntryResponse) FromCommand(v Command) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCommand performs a merge with any union data inside the EntryResponse, using the provided Command
func (t *EntryResponse) MergeCommand(v Command) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnection returns the union data inside the EntryResponse as a Connection
func (t EntryResponse) AsConnection() (Connection, error) {
	var body Connection
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnection overwrites any union data inside the EntryResponse as the provided Connection
func (t *EntryResponse) FromConnection(v Connection) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnection performs a merge with any union data inside the EntryResponse, using the provided Connection
func (t *EntryResponse) MergeConnection(v Connection) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsFileaccess returns the union data inside the EntryResponse as a Fileaccess
func (t EntryResponse) AsFileaccess() (Fileaccess, error) {
	var body Fileaccess
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFileaccess overwrites any union data inside the EntryResponse as the provided Fileaccess
func (t *EntryResponse) FromFileaccess(v Fileaccess) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFileaccess performs a merge with any union data inside the EntryResponse, using the provided Fileaccess
func (t *EntryResponse) MergeFileaccess(v Fileaccess) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKubernetes returns the union data inside the EntryResponse as a Kubernetes
func (t EntryResponse) AsKubernetes() (Kubernetes, error) {
	var body Kubernetes
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKubernetes overwrites any union data inside the EntryResponse as the provided Kubernetes
func (t *EntryResponse) FromKubernetes(v Kubernetes) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKubernetes performs a merge with any union data inside the EntryResponse, using the provided Kubernetes
func (t *EntryResponse) MergeKubernetes(v Kubernetes) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EntryResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EntryResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsK8sAdmissionReviewContent returns the union data inside the EventContent as a K8sAdmissionReviewContent
func (t EventContent) AsK8sAdmissionReviewContent() (K8sAdmissionReviewContent, error) {
	var body K8sAdmissionReviewContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromK8sAdmissionReviewContent overwrites any union data inside the EventContent as the provided K8sAdmissionReviewContent
func (t *EventContent) FromK8sAdmissionReviewContent(v K8sAdmissionReviewContent) error {
	v.Type = "k8sAdmissionReview"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeK8sAdmissionReviewContent performs a merge with any union data inside the EventContent, using the provided K8sAdmissionReviewContent
func (t *EventContent) MergeK8sAdmissionReviewContent(v K8sAdmissionReviewContent) error {
	v.Type = "k8sAdmissionReview"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentlessRuntimeDetectionContent returns the union data inside the EventContent as a AgentlessRuntimeDetectionContent
func (t EventContent) AsAgentlessRuntimeDetectionContent() (AgentlessRuntimeDetectionContent, error) {
	var body AgentlessRuntimeDetectionContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentlessRuntimeDetectionContent overwrites any union data inside the EventContent as the provided AgentlessRuntimeDetectionContent
func (t *EventContent) FromAgentlessRuntimeDetectionContent(v AgentlessRuntimeDetectionContent) error {
	v.Type = "agentlessRuntimeDetection"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentlessRuntimeDetectionContent performs a merge with any union data inside the EventContent, using the provided AgentlessRuntimeDetectionContent
func (t *EventContent) MergeAgentlessRuntimeDetectionContent(v AgentlessRuntimeDetectionContent) error {
	v.Type = "agentlessRuntimeDetection"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorkloadRuntimeDetectionContent returns the union data inside the EventContent as a WorkloadRuntimeDetectionContent
func (t EventContent) AsWorkloadRuntimeDetectionContent() (WorkloadRuntimeDetectionContent, error) {
	var body WorkloadRuntimeDetectionContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorkloadRuntimeDetectionContent overwrites any union data inside the EventContent as the provided WorkloadRuntimeDetectionContent
func (t *EventContent) FromWorkloadRuntimeDetectionContent(v WorkloadRuntimeDetectionContent) error {
	v.Type = "workloadRuntimeDetection"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorkloadRuntimeDetectionContent performs a merge with any union data inside the EventContent, using the provided WorkloadRuntimeDetectionContent
func (t *EventContent) MergeWorkloadRuntimeDetectionContent(v WorkloadRuntimeDetectionContent) error {
	v.Type = "workloadRuntimeDetection"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWorkloadMlRuntimeDetectionContent returns the union data inside the EventContent as a WorkloadMlRuntimeDetectionContent
func (t EventContent) AsWorkloadMlRuntimeDetectionContent() (WorkloadMlRuntimeDetectionContent, error) {
	var body WorkloadMlRuntimeDetectionContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWorkloadMlRuntimeDetectionContent overwrites any union data inside the EventContent as the provided WorkloadMlRuntimeDetectionContent
func (t *EventContent) FromWorkloadMlRuntimeDetectionContent(v WorkloadMlRuntimeDetectionContent) error {
	v.Type = "workloadMLRuntimeDetection"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWorkloadMlRuntimeDetectionContent performs a merge with any union data inside the EventContent, using the provided WorkloadMlRuntimeDetectionContent
func (t *EventContent) MergeWorkloadMlRuntimeDetectionContent(v WorkloadMlRuntimeDetectionContent) error {
	v.Type = "workloadMLRuntimeDetection"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentlessMlRuntimeDetectionContent returns the union data inside the EventContent as a AgentlessMlRuntimeDetectionContent
func (t EventContent) AsAgentlessMlRuntimeDetectionContent() (AgentlessMlRuntimeDetectionContent, error) {
	var body AgentlessMlRuntimeDetectionContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentlessMlRuntimeDetectionContent overwrites any union data inside the EventContent as the provided AgentlessMlRuntimeDetectionContent
func (t *EventContent) FromAgentlessMlRuntimeDetectionContent(v AgentlessMlRuntimeDetectionContent) error {
	v.Type = "agentlessMLRuntimeDetection"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentlessMlRuntimeDetectionContent performs a merge with any union data inside the EventContent, using the provided AgentlessMlRuntimeDetectionContent
func (t *EventContent) MergeAgentlessMlRuntimeDetectionContent(v AgentlessMlRuntimeDetectionContent) error {
	v.Type = "agentlessMLRuntimeDetection"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatefulDetectionsContent returns the union data inside the EventContent as a StatefulDetectionsContent
func (t EventContent) AsStatefulDetectionsContent() (StatefulDetectionsContent, error) {
	var body StatefulDetectionsContent
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatefulDetectionsContent overwrites any union data inside the EventContent as the provided StatefulDetectionsContent
func (t *EventContent) FromStatefulDetectionsContent(v StatefulDetectionsContent) error {
	v.Type = "statefulDetections"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatefulDetectionsContent performs a merge with any union data inside the EventContent, using the provided StatefulDetectionsContent
func (t *EventContent) MergeStatefulDetectionsContent(v StatefulDetectionsContent) error {
	v.Type = "statefulDetections"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EventContent) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t EventContent) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "agentlessMLRuntimeDetection":
		return t.AsAgentlessMlRuntimeDetectionContent()
	case "agentlessRuntimeDetection":
		return t.AsAgentlessRuntimeDetectionContent()
	case "k8sAdmissionReview":
		return t.AsK8sAdmissionReviewContent()
	case "statefulDetections":
		return t.AsStatefulDetectionsContent()
	case "workloadMLRuntimeDetection":
		return t.AsWorkloadMlRuntimeDetectionContent()
	case "workloadRuntimeDetection":
		return t.AsWorkloadRuntimeDetectionContent()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t EventContent) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EventContent) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBaseConnectionInfoChronicle returns the union data inside the GetChronicleIntegrationResponse_ConnectionInfo as a BaseConnectionInfoChronicle
func (t GetChronicleIntegrationResponse_ConnectionInfo) AsBaseConnectionInfoChronicle() (BaseConnectionInfoChronicle, error) {
	var body BaseConnectionInfoChronicle
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBaseConnectionInfoChronicle overwrites any union data inside the GetChronicleIntegrationResponse_ConnectionInfo as the provided BaseConnectionInfoChronicle
func (t *GetChronicleIntegrationResponse_ConnectionInfo) FromBaseConnectionInfoChronicle(v BaseConnectionInfoChronicle) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBaseConnectionInfoChronicle performs a merge with any union data inside the GetChronicleIntegrationResponse_ConnectionInfo, using the provided BaseConnectionInfoChronicle
func (t *GetChronicleIntegrationResponse_ConnectionInfo) MergeBaseConnectionInfoChronicle(v BaseConnectionInfoChronicle) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBaseConnectionInfoChronicleV2 returns the union data inside the GetChronicleIntegrationResponse_ConnectionInfo as a BaseConnectionInfoChronicleV2
func (t GetChronicleIntegrationResponse_ConnectionInfo) AsBaseConnectionInfoChronicleV2() (BaseConnectionInfoChronicleV2, error) {
	var body BaseConnectionInfoChronicleV2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBaseConnectionInfoChronicleV2 overwrites any union data inside the GetChronicleIntegrationResponse_ConnectionInfo as the provided BaseConnectionInfoChronicleV2
func (t *GetChronicleIntegrationResponse_ConnectionInfo) FromBaseConnectionInfoChronicleV2(v BaseConnectionInfoChronicleV2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBaseConnectionInfoChronicleV2 performs a merge with any union data inside the GetChronicleIntegrationResponse_ConnectionInfo, using the provided BaseConnectionInfoChronicleV2
func (t *GetChronicleIntegrationResponse_ConnectionInfo) MergeBaseConnectionInfoChronicleV2(v BaseConnectionInfoChronicleV2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetChronicleIntegrationResponse_ConnectionInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetChronicleIntegrationResponse_ConnectionInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBaseConnectionInfoKafka returns the union data inside the GetKafkaIntegrationResponse_ConnectionInfo as a BaseConnectionInfoKafka
func (t GetKafkaIntegrationResponse_ConnectionInfo) AsBaseConnectionInfoKafka() (BaseConnectionInfoKafka, error) {
	var body BaseConnectionInfoKafka
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBaseConnectionInfoKafka overwrites any union data inside the GetKafkaIntegrationResponse_ConnectionInfo as the provided BaseConnectionInfoKafka
func (t *GetKafkaIntegrationResponse_ConnectionInfo) FromBaseConnectionInfoKafka(v BaseConnectionInfoKafka) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBaseConnectionInfoKafka performs a merge with any union data inside the GetKafkaIntegrationResponse_ConnectionInfo, using the provided BaseConnectionInfoKafka
func (t *GetKafkaIntegrationResponse_ConnectionInfo) MergeBaseConnectionInfoKafka(v BaseConnectionInfoKafka) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKafkaAuthenticatedConnectionInfo returns the union data inside the GetKafkaIntegrationResponse_ConnectionInfo as a KafkaAuthenticatedConnectionInfo
func (t GetKafkaIntegrationResponse_ConnectionInfo) AsKafkaAuthenticatedConnectionInfo() (KafkaAuthenticatedConnectionInfo, error) {
	var body KafkaAuthenticatedConnectionInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaAuthenticatedConnectionInfo overwrites any union data inside the GetKafkaIntegrationResponse_ConnectionInfo as the provided KafkaAuthenticatedConnectionInfo
func (t *GetKafkaIntegrationResponse_ConnectionInfo) FromKafkaAuthenticatedConnectionInfo(v KafkaAuthenticatedConnectionInfo) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaAuthenticatedConnectionInfo performs a merge with any union data inside the GetKafkaIntegrationResponse_ConnectionInfo, using the provided KafkaAuthenticatedConnectionInfo
func (t *GetKafkaIntegrationResponse_ConnectionInfo) MergeKafkaAuthenticatedConnectionInfo(v KafkaAuthenticatedConnectionInfo) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetKafkaIntegrationResponse_ConnectionInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *GetKafkaIntegrationResponse_ConnectionInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsKafkaPlaintextV1 returns the union data inside the GetKafkaIntegrationResponseV1_ConnectionInfo as a KafkaPlaintextV1
func (t GetKafkaIntegrationResponseV1_ConnectionInfo) AsKafkaPlaintextV1() (KafkaPlaintextV1, error) {
	var body KafkaPlaintextV1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaPlaintextV1 overwrites any union data inside the GetKafkaIntegrationResponseV1_ConnectionInfo as the provided KafkaPlaintextV1
func (t *GetKafkaIntegrationResponseV1_ConnectionInfo) FromKafkaPlaintextV1(v KafkaPlaintextV1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaPlaintextV1 performs a merge with any union data inside the GetKafkaIntegrationResponseV1_ConnectionInfo, using the provided KafkaPlaintextV1
func (t *GetKafkaIntegrationResponseV1_ConnectionInfo) MergeKafkaPlaintextV1(v KafkaPlaintextV1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKafkaTlsEncryptedV1 returns the union data inside the GetKafkaIntegrationResponseV1_ConnectionInfo as a KafkaTlsEncryptedV1
func (t GetKafkaIntegrationResponseV1_ConnectionInfo) AsKafkaTlsEncryptedV1() (KafkaTlsEncryptedV1, error) {
	var body KafkaTlsEncryptedV1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaTlsEncryptedV1 overwrites any union data inside the GetKafkaIntegrationResponseV1_ConnectionInfo as the provided KafkaTlsEncryptedV1
func (t *GetKafkaIntegrationResponseV1_ConnectionInfo) FromKafkaTlsEncryptedV1(v KafkaTlsEncryptedV1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaTlsEncryptedV1 performs a merge with any union data inside the GetKafkaIntegrationResponseV1_ConnectionInfo, using the provided KafkaTlsEncryptedV1
func (t *GetKafkaIntegrationResponseV1_ConnectionInfo) MergeKafkaTlsEncryptedV1(v KafkaTlsEncryptedV1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t GetKafkaIntegrationResponseV1_ConnectionInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["auth"], err = json.Marshal(t.Auth)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'auth': %w", err)
	}

	if t.Balancer != nil {
		object["balancer"], err = json.Marshal(t.Balancer)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'balancer': %w", err)
		}
	}

	object["brokers"], err = json.Marshal(t.Brokers)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'brokers': %w", err)
	}

	if t.Compression != nil {
		object["compression"], err = json.Marshal(t.Compression)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'compression': %w", err)
		}
	}

	object["krb5"], err = json.Marshal(t.Krb5)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'krb5': %w", err)
	}

	object["principal"], err = json.Marshal(t.Principal)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'principal': %w", err)
	}

	object["realm"], err = json.Marshal(t.Realm)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'realm': %w", err)
	}

	object["service"], err = json.Marshal(t.Service)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'service': %w", err)
	}

	object["topic"], err = json.Marshal(t.Topic)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'topic': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *GetKafkaIntegrationResponseV1_ConnectionInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["auth"]; found {
		err = json.Unmarshal(raw, &t.Auth)
		if err != nil {
			return fmt.Errorf("error reading 'auth': %w", err)
		}
	}

	if raw, found := object["balancer"]; found {
		err = json.Unmarshal(raw, &t.Balancer)
		if err != nil {
			return fmt.Errorf("error reading 'balancer': %w", err)
		}
	}

	if raw, found := object["brokers"]; found {
		err = json.Unmarshal(raw, &t.Brokers)
		if err != nil {
			return fmt.Errorf("error reading 'brokers': %w", err)
		}
	}

	if raw, found := object["compression"]; found {
		err = json.Unmarshal(raw, &t.Compression)
		if err != nil {
			return fmt.Errorf("error reading 'compression': %w", err)
		}
	}

	if raw, found := object["krb5"]; found {
		err = json.Unmarshal(raw, &t.Krb5)
		if err != nil {
			return fmt.Errorf("error reading 'krb5': %w", err)
		}
	}

	if raw, found := object["principal"]; found {
		err = json.Unmarshal(raw, &t.Principal)
		if err != nil {
			return fmt.Errorf("error reading 'principal': %w", err)
		}
	}

	if raw, found := object["realm"]; found {
		err = json.Unmarshal(raw, &t.Realm)
		if err != nil {
			return fmt.Errorf("error reading 'realm': %w", err)
		}
	}

	if raw, found := object["service"]; found {
		err = json.Unmarshal(raw, &t.Service)
		if err != nil {
			return fmt.Errorf("error reading 'service': %w", err)
		}
	}

	if raw, found := object["topic"]; found {
		err = json.Unmarshal(raw, &t.Topic)
		if err != nil {
			return fmt.Errorf("error reading 'topic': %w", err)
		}
	}

	return err
}

// AsGetAmazonSqsIntegrationResponse returns the union data inside the IntegrationResponse as a GetAmazonSqsIntegrationResponse
func (t IntegrationResponse) AsGetAmazonSqsIntegrationResponse() (GetAmazonSqsIntegrationResponse, error) {
	var body GetAmazonSqsIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetAmazonSqsIntegrationResponse overwrites any union data inside the IntegrationResponse as the provided GetAmazonSqsIntegrationResponse
func (t *IntegrationResponse) FromGetAmazonSqsIntegrationResponse(v GetAmazonSqsIntegrationResponse) error {
	v.Type = "SQS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetAmazonSqsIntegrationResponse performs a merge with any union data inside the IntegrationResponse, using the provided GetAmazonSqsIntegrationResponse
func (t *IntegrationResponse) MergeGetAmazonSqsIntegrationResponse(v GetAmazonSqsIntegrationResponse) error {
	v.Type = "SQS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetChronicleIntegrationResponse returns the union data inside the IntegrationResponse as a GetChronicleIntegrationResponse
func (t IntegrationResponse) AsGetChronicleIntegrationResponse() (GetChronicleIntegrationResponse, error) {
	var body GetChronicleIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetChronicleIntegrationResponse overwrites any union data inside the IntegrationResponse as the provided GetChronicleIntegrationResponse
func (t *IntegrationResponse) FromGetChronicleIntegrationResponse(v GetChronicleIntegrationResponse) error {
	v.Type = "CHRONICLE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetChronicleIntegrationResponse performs a merge with any union data inside the IntegrationResponse, using the provided GetChronicleIntegrationResponse
func (t *IntegrationResponse) MergeGetChronicleIntegrationResponse(v GetChronicleIntegrationResponse) error {
	v.Type = "CHRONICLE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetElasticsearchIntegrationResponse returns the union data inside the IntegrationResponse as a GetElasticsearchIntegrationResponse
func (t IntegrationResponse) AsGetElasticsearchIntegrationResponse() (GetElasticsearchIntegrationResponse, error) {
	var body GetElasticsearchIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetElasticsearchIntegrationResponse overwrites any union data inside the IntegrationResponse as the provided GetElasticsearchIntegrationResponse
func (t *IntegrationResponse) FromGetElasticsearchIntegrationResponse(v GetElasticsearchIntegrationResponse) error {
	v.Type = "ELASTIC"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetElasticsearchIntegrationResponse performs a merge with any union data inside the IntegrationResponse, using the provided GetElasticsearchIntegrationResponse
func (t *IntegrationResponse) MergeGetElasticsearchIntegrationResponse(v GetElasticsearchIntegrationResponse) error {
	v.Type = "ELASTIC"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetGooglePubSubIntegrationResponse returns the union data inside the IntegrationResponse as a GetGooglePubSubIntegrationResponse
func (t IntegrationResponse) AsGetGooglePubSubIntegrationResponse() (GetGooglePubSubIntegrationResponse, error) {
	var body GetGooglePubSubIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetGooglePubSubIntegrationResponse overwrites any union data inside the IntegrationResponse as the provided GetGooglePubSubIntegrationResponse
func (t *IntegrationResponse) FromGetGooglePubSubIntegrationResponse(v GetGooglePubSubIntegrationResponse) error {
	v.Type = "PUBSUB"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetGooglePubSubIntegrationResponse performs a merge with any union data inside the IntegrationResponse, using the provided GetGooglePubSubIntegrationResponse
func (t *IntegrationResponse) MergeGetGooglePubSubIntegrationResponse(v GetGooglePubSubIntegrationResponse) error {
	v.Type = "PUBSUB"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetGoogleSccIntegrationResponse returns the union data inside the IntegrationResponse as a GetGoogleSccIntegrationResponse
func (t IntegrationResponse) AsGetGoogleSccIntegrationResponse() (GetGoogleSccIntegrationResponse, error) {
	var body GetGoogleSccIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetGoogleSccIntegrationResponse overwrites any union data inside the IntegrationResponse as the provided GetGoogleSccIntegrationResponse
func (t *IntegrationResponse) FromGetGoogleSccIntegrationResponse(v GetGoogleSccIntegrationResponse) error {
	v.Type = "SCC"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetGoogleSccIntegrationResponse performs a merge with any union data inside the IntegrationResponse, using the provided GetGoogleSccIntegrationResponse
func (t *IntegrationResponse) MergeGetGoogleSccIntegrationResponse(v GetGoogleSccIntegrationResponse) error {
	v.Type = "SCC"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetKafkaIntegrationResponse returns the union data inside the IntegrationResponse as a GetKafkaIntegrationResponse
func (t IntegrationResponse) AsGetKafkaIntegrationResponse() (GetKafkaIntegrationResponse, error) {
	var body GetKafkaIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetKafkaIntegrationResponse overwrites any union data inside the IntegrationResponse as the provided GetKafkaIntegrationResponse
func (t *IntegrationResponse) FromGetKafkaIntegrationResponse(v GetKafkaIntegrationResponse) error {
	v.Type = "KAFKA"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetKafkaIntegrationResponse performs a merge with any union data inside the IntegrationResponse, using the provided GetKafkaIntegrationResponse
func (t *IntegrationResponse) MergeGetKafkaIntegrationResponse(v GetKafkaIntegrationResponse) error {
	v.Type = "KAFKA"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetMcmIntegrationResponse returns the union data inside the IntegrationResponse as a GetMcmIntegrationResponse
func (t IntegrationResponse) AsGetMcmIntegrationResponse() (GetMcmIntegrationResponse, error) {
	var body GetMcmIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetMcmIntegrationResponse overwrites any union data inside the IntegrationResponse as the provided GetMcmIntegrationResponse
func (t *IntegrationResponse) FromGetMcmIntegrationResponse(v GetMcmIntegrationResponse) error {
	v.Type = "MCM"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetMcmIntegrationResponse performs a merge with any union data inside the IntegrationResponse, using the provided GetMcmIntegrationResponse
func (t *IntegrationResponse) MergeGetMcmIntegrationResponse(v GetMcmIntegrationResponse) error {
	v.Type = "MCM"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetMicrosoftSentinelIntegrationResponse returns the union data inside the IntegrationResponse as a GetMicrosoftSentinelIntegrationResponse
func (t IntegrationResponse) AsGetMicrosoftSentinelIntegrationResponse() (GetMicrosoftSentinelIntegrationResponse, error) {
	var body GetMicrosoftSentinelIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetMicrosoftSentinelIntegrationResponse overwrites any union data inside the IntegrationResponse as the provided GetMicrosoftSentinelIntegrationResponse
func (t *IntegrationResponse) FromGetMicrosoftSentinelIntegrationResponse(v GetMicrosoftSentinelIntegrationResponse) error {
	v.Type = "SENTINEL"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetMicrosoftSentinelIntegrationResponse performs a merge with any union data inside the IntegrationResponse, using the provided GetMicrosoftSentinelIntegrationResponse
func (t *IntegrationResponse) MergeGetMicrosoftSentinelIntegrationResponse(v GetMicrosoftSentinelIntegrationResponse) error {
	v.Type = "SENTINEL"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetQradarIntegrationResponse returns the union data inside the IntegrationResponse as a GetQradarIntegrationResponse
func (t IntegrationResponse) AsGetQradarIntegrationResponse() (GetQradarIntegrationResponse, error) {
	var body GetQradarIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetQradarIntegrationResponse overwrites any union data inside the IntegrationResponse as the provided GetQradarIntegrationResponse
func (t *IntegrationResponse) FromGetQradarIntegrationResponse(v GetQradarIntegrationResponse) error {
	v.Type = "QRADAR"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetQradarIntegrationResponse performs a merge with any union data inside the IntegrationResponse, using the provided GetQradarIntegrationResponse
func (t *IntegrationResponse) MergeGetQradarIntegrationResponse(v GetQradarIntegrationResponse) error {
	v.Type = "QRADAR"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetSplunkIntegrationResponse returns the union data inside the IntegrationResponse as a GetSplunkIntegrationResponse
func (t IntegrationResponse) AsGetSplunkIntegrationResponse() (GetSplunkIntegrationResponse, error) {
	var body GetSplunkIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetSplunkIntegrationResponse overwrites any union data inside the IntegrationResponse as the provided GetSplunkIntegrationResponse
func (t *IntegrationResponse) FromGetSplunkIntegrationResponse(v GetSplunkIntegrationResponse) error {
	v.Type = "SPLUNK"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetSplunkIntegrationResponse performs a merge with any union data inside the IntegrationResponse, using the provided GetSplunkIntegrationResponse
func (t *IntegrationResponse) MergeGetSplunkIntegrationResponse(v GetSplunkIntegrationResponse) error {
	v.Type = "SPLUNK"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetSyslogIntegrationResponse returns the union data inside the IntegrationResponse as a GetSyslogIntegrationResponse
func (t IntegrationResponse) AsGetSyslogIntegrationResponse() (GetSyslogIntegrationResponse, error) {
	var body GetSyslogIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetSyslogIntegrationResponse overwrites any union data inside the IntegrationResponse as the provided GetSyslogIntegrationResponse
func (t *IntegrationResponse) FromGetSyslogIntegrationResponse(v GetSyslogIntegrationResponse) error {
	v.Type = "SYSLOG"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetSyslogIntegrationResponse performs a merge with any union data inside the IntegrationResponse, using the provided GetSyslogIntegrationResponse
func (t *IntegrationResponse) MergeGetSyslogIntegrationResponse(v GetSyslogIntegrationResponse) error {
	v.Type = "SYSLOG"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGetWebhookIntegrationResponse returns the union data inside the IntegrationResponse as a GetWebhookIntegrationResponse
func (t IntegrationResponse) AsGetWebhookIntegrationResponse() (GetWebhookIntegrationResponse, error) {
	var body GetWebhookIntegrationResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGetWebhookIntegrationResponse overwrites any union data inside the IntegrationResponse as the provided GetWebhookIntegrationResponse
func (t *IntegrationResponse) FromGetWebhookIntegrationResponse(v GetWebhookIntegrationResponse) error {
	v.Type = "WEBHOOK"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGetWebhookIntegrationResponse performs a merge with any union data inside the IntegrationResponse, using the provided GetWebhookIntegrationResponse
func (t *IntegrationResponse) MergeGetWebhookIntegrationResponse(v GetWebhookIntegrationResponse) error {
	v.Type = "WEBHOOK"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IntegrationResponse) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t IntegrationResponse) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "CHRONICLE":
		return t.AsGetChronicleIntegrationResponse()
	case "ELASTIC":
		return t.AsGetElasticsearchIntegrationResponse()
	case "KAFKA":
		return t.AsGetKafkaIntegrationResponse()
	case "MCM":
		return t.AsGetMcmIntegrationResponse()
	case "PUBSUB":
		return t.AsGetGooglePubSubIntegrationResponse()
	case "QRADAR":
		return t.AsGetQradarIntegrationResponse()
	case "SCC":
		return t.AsGetGoogleSccIntegrationResponse()
	case "SENTINEL":
		return t.AsGetMicrosoftSentinelIntegrationResponse()
	case "SPLUNK":
		return t.AsGetSplunkIntegrationResponse()
	case "SQS":
		return t.AsGetAmazonSqsIntegrationResponse()
	case "SYSLOG":
		return t.AsGetSyslogIntegrationResponse()
	case "WEBHOOK":
		return t.AsGetWebhookIntegrationResponse()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t IntegrationResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IntegrationResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsCheckboxFieldValueV1 returns the union data inside the IssueTypeFieldResponseV1_AllowedValues_Item as a CheckboxFieldValueV1
func (t IssueTypeFieldResponseV1_AllowedValues_Item) AsCheckboxFieldValueV1() (CheckboxFieldValueV1, error) {
	var body CheckboxFieldValueV1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCheckboxFieldValueV1 overwrites any union data inside the IssueTypeFieldResponseV1_AllowedValues_Item as the provided CheckboxFieldValueV1
func (t *IssueTypeFieldResponseV1_AllowedValues_Item) FromCheckboxFieldValueV1(v CheckboxFieldValueV1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCheckboxFieldValueV1 performs a merge with any union data inside the IssueTypeFieldResponseV1_AllowedValues_Item, using the provided CheckboxFieldValueV1
func (t *IssueTypeFieldResponseV1_AllowedValues_Item) MergeCheckboxFieldValueV1(v CheckboxFieldValueV1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t IssueTypeFieldResponseV1_AllowedValues_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *IssueTypeFieldResponseV1_AllowedValues_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsKafkaGssapiAuthenticatedConnectionInfo returns the union data inside the KafkaAuthenticatedConnectionInfo as a KafkaGssapiAuthenticatedConnectionInfo
func (t KafkaAuthenticatedConnectionInfo) AsKafkaGssapiAuthenticatedConnectionInfo() (KafkaGssapiAuthenticatedConnectionInfo, error) {
	var body KafkaGssapiAuthenticatedConnectionInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaGssapiAuthenticatedConnectionInfo overwrites any union data inside the KafkaAuthenticatedConnectionInfo as the provided KafkaGssapiAuthenticatedConnectionInfo
func (t *KafkaAuthenticatedConnectionInfo) FromKafkaGssapiAuthenticatedConnectionInfo(v KafkaGssapiAuthenticatedConnectionInfo) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaGssapiAuthenticatedConnectionInfo performs a merge with any union data inside the KafkaAuthenticatedConnectionInfo, using the provided KafkaGssapiAuthenticatedConnectionInfo
func (t *KafkaAuthenticatedConnectionInfo) MergeKafkaGssapiAuthenticatedConnectionInfo(v KafkaGssapiAuthenticatedConnectionInfo) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKafkaSaslPlainAuthenticatedConnectionInfo returns the union data inside the KafkaAuthenticatedConnectionInfo as a KafkaSaslPlainAuthenticatedConnectionInfo
func (t KafkaAuthenticatedConnectionInfo) AsKafkaSaslPlainAuthenticatedConnectionInfo() (KafkaSaslPlainAuthenticatedConnectionInfo, error) {
	var body KafkaSaslPlainAuthenticatedConnectionInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaSaslPlainAuthenticatedConnectionInfo overwrites any union data inside the KafkaAuthenticatedConnectionInfo as the provided KafkaSaslPlainAuthenticatedConnectionInfo
func (t *KafkaAuthenticatedConnectionInfo) FromKafkaSaslPlainAuthenticatedConnectionInfo(v KafkaSaslPlainAuthenticatedConnectionInfo) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaSaslPlainAuthenticatedConnectionInfo performs a merge with any union data inside the KafkaAuthenticatedConnectionInfo, using the provided KafkaSaslPlainAuthenticatedConnectionInfo
func (t *KafkaAuthenticatedConnectionInfo) MergeKafkaSaslPlainAuthenticatedConnectionInfo(v KafkaSaslPlainAuthenticatedConnectionInfo) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKafkaSaslScramAuthenticatedConnectionInfo returns the union data inside the KafkaAuthenticatedConnectionInfo as a KafkaSaslScramAuthenticatedConnectionInfo
func (t KafkaAuthenticatedConnectionInfo) AsKafkaSaslScramAuthenticatedConnectionInfo() (KafkaSaslScramAuthenticatedConnectionInfo, error) {
	var body KafkaSaslScramAuthenticatedConnectionInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaSaslScramAuthenticatedConnectionInfo overwrites any union data inside the KafkaAuthenticatedConnectionInfo as the provided KafkaSaslScramAuthenticatedConnectionInfo
func (t *KafkaAuthenticatedConnectionInfo) FromKafkaSaslScramAuthenticatedConnectionInfo(v KafkaSaslScramAuthenticatedConnectionInfo) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaSaslScramAuthenticatedConnectionInfo performs a merge with any union data inside the KafkaAuthenticatedConnectionInfo, using the provided KafkaSaslScramAuthenticatedConnectionInfo
func (t *KafkaAuthenticatedConnectionInfo) MergeKafkaSaslScramAuthenticatedConnectionInfo(v KafkaSaslScramAuthenticatedConnectionInfo) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t KafkaAuthenticatedConnectionInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["auth"], err = json.Marshal(t.Auth)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'auth': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *KafkaAuthenticatedConnectionInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["auth"]; found {
		err = json.Unmarshal(raw, &t.Auth)
		if err != nil {
			return fmt.Errorf("error reading 'auth': %w", err)
		}
	}

	return err
}

// AsKafkaGssapiAuthenticatedPrivateConnectionInfo returns the union data inside the KafkaAuthenticatedPrivateConnectionInfo as a KafkaGssapiAuthenticatedPrivateConnectionInfo
func (t KafkaAuthenticatedPrivateConnectionInfo) AsKafkaGssapiAuthenticatedPrivateConnectionInfo() (KafkaGssapiAuthenticatedPrivateConnectionInfo, error) {
	var body KafkaGssapiAuthenticatedPrivateConnectionInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaGssapiAuthenticatedPrivateConnectionInfo overwrites any union data inside the KafkaAuthenticatedPrivateConnectionInfo as the provided KafkaGssapiAuthenticatedPrivateConnectionInfo
func (t *KafkaAuthenticatedPrivateConnectionInfo) FromKafkaGssapiAuthenticatedPrivateConnectionInfo(v KafkaGssapiAuthenticatedPrivateConnectionInfo) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaGssapiAuthenticatedPrivateConnectionInfo performs a merge with any union data inside the KafkaAuthenticatedPrivateConnectionInfo, using the provided KafkaGssapiAuthenticatedPrivateConnectionInfo
func (t *KafkaAuthenticatedPrivateConnectionInfo) MergeKafkaGssapiAuthenticatedPrivateConnectionInfo(v KafkaGssapiAuthenticatedPrivateConnectionInfo) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKafkaSaslPlainAuthenticatedPrivateConnectionInfo returns the union data inside the KafkaAuthenticatedPrivateConnectionInfo as a KafkaSaslPlainAuthenticatedPrivateConnectionInfo
func (t KafkaAuthenticatedPrivateConnectionInfo) AsKafkaSaslPlainAuthenticatedPrivateConnectionInfo() (KafkaSaslPlainAuthenticatedPrivateConnectionInfo, error) {
	var body KafkaSaslPlainAuthenticatedPrivateConnectionInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaSaslPlainAuthenticatedPrivateConnectionInfo overwrites any union data inside the KafkaAuthenticatedPrivateConnectionInfo as the provided KafkaSaslPlainAuthenticatedPrivateConnectionInfo
func (t *KafkaAuthenticatedPrivateConnectionInfo) FromKafkaSaslPlainAuthenticatedPrivateConnectionInfo(v KafkaSaslPlainAuthenticatedPrivateConnectionInfo) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaSaslPlainAuthenticatedPrivateConnectionInfo performs a merge with any union data inside the KafkaAuthenticatedPrivateConnectionInfo, using the provided KafkaSaslPlainAuthenticatedPrivateConnectionInfo
func (t *KafkaAuthenticatedPrivateConnectionInfo) MergeKafkaSaslPlainAuthenticatedPrivateConnectionInfo(v KafkaSaslPlainAuthenticatedPrivateConnectionInfo) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKafkaSaslScramAuthenticatedPrivateConnectionInfo returns the union data inside the KafkaAuthenticatedPrivateConnectionInfo as a KafkaSaslScramAuthenticatedPrivateConnectionInfo
func (t KafkaAuthenticatedPrivateConnectionInfo) AsKafkaSaslScramAuthenticatedPrivateConnectionInfo() (KafkaSaslScramAuthenticatedPrivateConnectionInfo, error) {
	var body KafkaSaslScramAuthenticatedPrivateConnectionInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaSaslScramAuthenticatedPrivateConnectionInfo overwrites any union data inside the KafkaAuthenticatedPrivateConnectionInfo as the provided KafkaSaslScramAuthenticatedPrivateConnectionInfo
func (t *KafkaAuthenticatedPrivateConnectionInfo) FromKafkaSaslScramAuthenticatedPrivateConnectionInfo(v KafkaSaslScramAuthenticatedPrivateConnectionInfo) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaSaslScramAuthenticatedPrivateConnectionInfo performs a merge with any union data inside the KafkaAuthenticatedPrivateConnectionInfo, using the provided KafkaSaslScramAuthenticatedPrivateConnectionInfo
func (t *KafkaAuthenticatedPrivateConnectionInfo) MergeKafkaSaslScramAuthenticatedPrivateConnectionInfo(v KafkaSaslScramAuthenticatedPrivateConnectionInfo) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t KafkaAuthenticatedPrivateConnectionInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["auth"], err = json.Marshal(t.Auth)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'auth': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *KafkaAuthenticatedPrivateConnectionInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["auth"]; found {
		err = json.Unmarshal(raw, &t.Auth)
		if err != nil {
			return fmt.Errorf("error reading 'auth': %w", err)
		}
	}

	return err
}

// AsKafkaPlaintext returns the union data inside the KafkaGssapiAuthenticatedConnectionInfo as a KafkaPlaintext
func (t KafkaGssapiAuthenticatedConnectionInfo) AsKafkaPlaintext() (KafkaPlaintext, error) {
	var body KafkaPlaintext
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaPlaintext overwrites any union data inside the KafkaGssapiAuthenticatedConnectionInfo as the provided KafkaPlaintext
func (t *KafkaGssapiAuthenticatedConnectionInfo) FromKafkaPlaintext(v KafkaPlaintext) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaPlaintext performs a merge with any union data inside the KafkaGssapiAuthenticatedConnectionInfo, using the provided KafkaPlaintext
func (t *KafkaGssapiAuthenticatedConnectionInfo) MergeKafkaPlaintext(v KafkaPlaintext) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKafkaTlsEncrypted returns the union data inside the KafkaGssapiAuthenticatedConnectionInfo as a KafkaTlsEncrypted
func (t KafkaGssapiAuthenticatedConnectionInfo) AsKafkaTlsEncrypted() (KafkaTlsEncrypted, error) {
	var body KafkaTlsEncrypted
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaTlsEncrypted overwrites any union data inside the KafkaGssapiAuthenticatedConnectionInfo as the provided KafkaTlsEncrypted
func (t *KafkaGssapiAuthenticatedConnectionInfo) FromKafkaTlsEncrypted(v KafkaTlsEncrypted) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaTlsEncrypted performs a merge with any union data inside the KafkaGssapiAuthenticatedConnectionInfo, using the provided KafkaTlsEncrypted
func (t *KafkaGssapiAuthenticatedConnectionInfo) MergeKafkaTlsEncrypted(v KafkaTlsEncrypted) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t KafkaGssapiAuthenticatedConnectionInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["auth"], err = json.Marshal(t.Auth)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'auth': %w", err)
	}

	if t.Balancer != nil {
		object["balancer"], err = json.Marshal(t.Balancer)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'balancer': %w", err)
		}
	}

	object["brokers"], err = json.Marshal(t.Brokers)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'brokers': %w", err)
	}

	if t.Compression != nil {
		object["compression"], err = json.Marshal(t.Compression)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'compression': %w", err)
		}
	}

	object["krb5"], err = json.Marshal(t.Krb5)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'krb5': %w", err)
	}

	object["principal"], err = json.Marshal(t.Principal)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'principal': %w", err)
	}

	object["realm"], err = json.Marshal(t.Realm)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'realm': %w", err)
	}

	object["service"], err = json.Marshal(t.Service)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'service': %w", err)
	}

	object["topic"], err = json.Marshal(t.Topic)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'topic': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *KafkaGssapiAuthenticatedConnectionInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["auth"]; found {
		err = json.Unmarshal(raw, &t.Auth)
		if err != nil {
			return fmt.Errorf("error reading 'auth': %w", err)
		}
	}

	if raw, found := object["balancer"]; found {
		err = json.Unmarshal(raw, &t.Balancer)
		if err != nil {
			return fmt.Errorf("error reading 'balancer': %w", err)
		}
	}

	if raw, found := object["brokers"]; found {
		err = json.Unmarshal(raw, &t.Brokers)
		if err != nil {
			return fmt.Errorf("error reading 'brokers': %w", err)
		}
	}

	if raw, found := object["compression"]; found {
		err = json.Unmarshal(raw, &t.Compression)
		if err != nil {
			return fmt.Errorf("error reading 'compression': %w", err)
		}
	}

	if raw, found := object["krb5"]; found {
		err = json.Unmarshal(raw, &t.Krb5)
		if err != nil {
			return fmt.Errorf("error reading 'krb5': %w", err)
		}
	}

	if raw, found := object["principal"]; found {
		err = json.Unmarshal(raw, &t.Principal)
		if err != nil {
			return fmt.Errorf("error reading 'principal': %w", err)
		}
	}

	if raw, found := object["realm"]; found {
		err = json.Unmarshal(raw, &t.Realm)
		if err != nil {
			return fmt.Errorf("error reading 'realm': %w", err)
		}
	}

	if raw, found := object["service"]; found {
		err = json.Unmarshal(raw, &t.Service)
		if err != nil {
			return fmt.Errorf("error reading 'service': %w", err)
		}
	}

	if raw, found := object["topic"]; found {
		err = json.Unmarshal(raw, &t.Topic)
		if err != nil {
			return fmt.Errorf("error reading 'topic': %w", err)
		}
	}

	return err
}

// AsKafkaPlaintext returns the union data inside the KafkaGssapiAuthenticatedPrivateConnectionInfo as a KafkaPlaintext
func (t KafkaGssapiAuthenticatedPrivateConnectionInfo) AsKafkaPlaintext() (KafkaPlaintext, error) {
	var body KafkaPlaintext
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaPlaintext overwrites any union data inside the KafkaGssapiAuthenticatedPrivateConnectionInfo as the provided KafkaPlaintext
func (t *KafkaGssapiAuthenticatedPrivateConnectionInfo) FromKafkaPlaintext(v KafkaPlaintext) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaPlaintext performs a merge with any union data inside the KafkaGssapiAuthenticatedPrivateConnectionInfo, using the provided KafkaPlaintext
func (t *KafkaGssapiAuthenticatedPrivateConnectionInfo) MergeKafkaPlaintext(v KafkaPlaintext) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKafkaTlsEncrypted returns the union data inside the KafkaGssapiAuthenticatedPrivateConnectionInfo as a KafkaTlsEncrypted
func (t KafkaGssapiAuthenticatedPrivateConnectionInfo) AsKafkaTlsEncrypted() (KafkaTlsEncrypted, error) {
	var body KafkaTlsEncrypted
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaTlsEncrypted overwrites any union data inside the KafkaGssapiAuthenticatedPrivateConnectionInfo as the provided KafkaTlsEncrypted
func (t *KafkaGssapiAuthenticatedPrivateConnectionInfo) FromKafkaTlsEncrypted(v KafkaTlsEncrypted) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaTlsEncrypted performs a merge with any union data inside the KafkaGssapiAuthenticatedPrivateConnectionInfo, using the provided KafkaTlsEncrypted
func (t *KafkaGssapiAuthenticatedPrivateConnectionInfo) MergeKafkaTlsEncrypted(v KafkaTlsEncrypted) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t KafkaGssapiAuthenticatedPrivateConnectionInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["auth"], err = json.Marshal(t.Auth)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'auth': %w", err)
	}

	if t.Balancer != nil {
		object["balancer"], err = json.Marshal(t.Balancer)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'balancer': %w", err)
		}
	}

	object["brokers"], err = json.Marshal(t.Brokers)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'brokers': %w", err)
	}

	if t.Compression != nil {
		object["compression"], err = json.Marshal(t.Compression)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'compression': %w", err)
		}
	}

	object["keytab"], err = json.Marshal(t.Keytab)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'keytab': %w", err)
	}

	object["krb5"], err = json.Marshal(t.Krb5)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'krb5': %w", err)
	}

	object["principal"], err = json.Marshal(t.Principal)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'principal': %w", err)
	}

	object["realm"], err = json.Marshal(t.Realm)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'realm': %w", err)
	}

	object["service"], err = json.Marshal(t.Service)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'service': %w", err)
	}

	object["topic"], err = json.Marshal(t.Topic)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'topic': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *KafkaGssapiAuthenticatedPrivateConnectionInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["auth"]; found {
		err = json.Unmarshal(raw, &t.Auth)
		if err != nil {
			return fmt.Errorf("error reading 'auth': %w", err)
		}
	}

	if raw, found := object["balancer"]; found {
		err = json.Unmarshal(raw, &t.Balancer)
		if err != nil {
			return fmt.Errorf("error reading 'balancer': %w", err)
		}
	}

	if raw, found := object["brokers"]; found {
		err = json.Unmarshal(raw, &t.Brokers)
		if err != nil {
			return fmt.Errorf("error reading 'brokers': %w", err)
		}
	}

	if raw, found := object["compression"]; found {
		err = json.Unmarshal(raw, &t.Compression)
		if err != nil {
			return fmt.Errorf("error reading 'compression': %w", err)
		}
	}

	if raw, found := object["keytab"]; found {
		err = json.Unmarshal(raw, &t.Keytab)
		if err != nil {
			return fmt.Errorf("error reading 'keytab': %w", err)
		}
	}

	if raw, found := object["krb5"]; found {
		err = json.Unmarshal(raw, &t.Krb5)
		if err != nil {
			return fmt.Errorf("error reading 'krb5': %w", err)
		}
	}

	if raw, found := object["principal"]; found {
		err = json.Unmarshal(raw, &t.Principal)
		if err != nil {
			return fmt.Errorf("error reading 'principal': %w", err)
		}
	}

	if raw, found := object["realm"]; found {
		err = json.Unmarshal(raw, &t.Realm)
		if err != nil {
			return fmt.Errorf("error reading 'realm': %w", err)
		}
	}

	if raw, found := object["service"]; found {
		err = json.Unmarshal(raw, &t.Service)
		if err != nil {
			return fmt.Errorf("error reading 'service': %w", err)
		}
	}

	if raw, found := object["topic"]; found {
		err = json.Unmarshal(raw, &t.Topic)
		if err != nil {
			return fmt.Errorf("error reading 'topic': %w", err)
		}
	}

	return err
}

// AsKafkaPlaintext returns the union data inside the KafkaSaslPlainAuthenticatedConnectionInfo as a KafkaPlaintext
func (t KafkaSaslPlainAuthenticatedConnectionInfo) AsKafkaPlaintext() (KafkaPlaintext, error) {
	var body KafkaPlaintext
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaPlaintext overwrites any union data inside the KafkaSaslPlainAuthenticatedConnectionInfo as the provided KafkaPlaintext
func (t *KafkaSaslPlainAuthenticatedConnectionInfo) FromKafkaPlaintext(v KafkaPlaintext) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaPlaintext performs a merge with any union data inside the KafkaSaslPlainAuthenticatedConnectionInfo, using the provided KafkaPlaintext
func (t *KafkaSaslPlainAuthenticatedConnectionInfo) MergeKafkaPlaintext(v KafkaPlaintext) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKafkaTlsEncrypted returns the union data inside the KafkaSaslPlainAuthenticatedConnectionInfo as a KafkaTlsEncrypted
func (t KafkaSaslPlainAuthenticatedConnectionInfo) AsKafkaTlsEncrypted() (KafkaTlsEncrypted, error) {
	var body KafkaTlsEncrypted
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaTlsEncrypted overwrites any union data inside the KafkaSaslPlainAuthenticatedConnectionInfo as the provided KafkaTlsEncrypted
func (t *KafkaSaslPlainAuthenticatedConnectionInfo) FromKafkaTlsEncrypted(v KafkaTlsEncrypted) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaTlsEncrypted performs a merge with any union data inside the KafkaSaslPlainAuthenticatedConnectionInfo, using the provided KafkaTlsEncrypted
func (t *KafkaSaslPlainAuthenticatedConnectionInfo) MergeKafkaTlsEncrypted(v KafkaTlsEncrypted) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t KafkaSaslPlainAuthenticatedConnectionInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["auth"], err = json.Marshal(t.Auth)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'auth': %w", err)
	}

	if t.Balancer != nil {
		object["balancer"], err = json.Marshal(t.Balancer)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'balancer': %w", err)
		}
	}

	object["brokers"], err = json.Marshal(t.Brokers)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'brokers': %w", err)
	}

	if t.Compression != nil {
		object["compression"], err = json.Marshal(t.Compression)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'compression': %w", err)
		}
	}

	object["topic"], err = json.Marshal(t.Topic)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'topic': %w", err)
	}

	object["username"], err = json.Marshal(t.Username)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'username': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *KafkaSaslPlainAuthenticatedConnectionInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["auth"]; found {
		err = json.Unmarshal(raw, &t.Auth)
		if err != nil {
			return fmt.Errorf("error reading 'auth': %w", err)
		}
	}

	if raw, found := object["balancer"]; found {
		err = json.Unmarshal(raw, &t.Balancer)
		if err != nil {
			return fmt.Errorf("error reading 'balancer': %w", err)
		}
	}

	if raw, found := object["brokers"]; found {
		err = json.Unmarshal(raw, &t.Brokers)
		if err != nil {
			return fmt.Errorf("error reading 'brokers': %w", err)
		}
	}

	if raw, found := object["compression"]; found {
		err = json.Unmarshal(raw, &t.Compression)
		if err != nil {
			return fmt.Errorf("error reading 'compression': %w", err)
		}
	}

	if raw, found := object["topic"]; found {
		err = json.Unmarshal(raw, &t.Topic)
		if err != nil {
			return fmt.Errorf("error reading 'topic': %w", err)
		}
	}

	if raw, found := object["username"]; found {
		err = json.Unmarshal(raw, &t.Username)
		if err != nil {
			return fmt.Errorf("error reading 'username': %w", err)
		}
	}

	return err
}

// AsKafkaPlaintext returns the union data inside the KafkaSaslPlainAuthenticatedPrivateConnectionInfo as a KafkaPlaintext
func (t KafkaSaslPlainAuthenticatedPrivateConnectionInfo) AsKafkaPlaintext() (KafkaPlaintext, error) {
	var body KafkaPlaintext
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaPlaintext overwrites any union data inside the KafkaSaslPlainAuthenticatedPrivateConnectionInfo as the provided KafkaPlaintext
func (t *KafkaSaslPlainAuthenticatedPrivateConnectionInfo) FromKafkaPlaintext(v KafkaPlaintext) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaPlaintext performs a merge with any union data inside the KafkaSaslPlainAuthenticatedPrivateConnectionInfo, using the provided KafkaPlaintext
func (t *KafkaSaslPlainAuthenticatedPrivateConnectionInfo) MergeKafkaPlaintext(v KafkaPlaintext) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKafkaTlsEncrypted returns the union data inside the KafkaSaslPlainAuthenticatedPrivateConnectionInfo as a KafkaTlsEncrypted
func (t KafkaSaslPlainAuthenticatedPrivateConnectionInfo) AsKafkaTlsEncrypted() (KafkaTlsEncrypted, error) {
	var body KafkaTlsEncrypted
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaTlsEncrypted overwrites any union data inside the KafkaSaslPlainAuthenticatedPrivateConnectionInfo as the provided KafkaTlsEncrypted
func (t *KafkaSaslPlainAuthenticatedPrivateConnectionInfo) FromKafkaTlsEncrypted(v KafkaTlsEncrypted) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaTlsEncrypted performs a merge with any union data inside the KafkaSaslPlainAuthenticatedPrivateConnectionInfo, using the provided KafkaTlsEncrypted
func (t *KafkaSaslPlainAuthenticatedPrivateConnectionInfo) MergeKafkaTlsEncrypted(v KafkaTlsEncrypted) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t KafkaSaslPlainAuthenticatedPrivateConnectionInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["auth"], err = json.Marshal(t.Auth)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'auth': %w", err)
	}

	if t.Balancer != nil {
		object["balancer"], err = json.Marshal(t.Balancer)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'balancer': %w", err)
		}
	}

	object["brokers"], err = json.Marshal(t.Brokers)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'brokers': %w", err)
	}

	if t.Compression != nil {
		object["compression"], err = json.Marshal(t.Compression)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'compression': %w", err)
		}
	}

	object["password"], err = json.Marshal(t.Password)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'password': %w", err)
	}

	object["topic"], err = json.Marshal(t.Topic)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'topic': %w", err)
	}

	object["username"], err = json.Marshal(t.Username)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'username': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *KafkaSaslPlainAuthenticatedPrivateConnectionInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["auth"]; found {
		err = json.Unmarshal(raw, &t.Auth)
		if err != nil {
			return fmt.Errorf("error reading 'auth': %w", err)
		}
	}

	if raw, found := object["balancer"]; found {
		err = json.Unmarshal(raw, &t.Balancer)
		if err != nil {
			return fmt.Errorf("error reading 'balancer': %w", err)
		}
	}

	if raw, found := object["brokers"]; found {
		err = json.Unmarshal(raw, &t.Brokers)
		if err != nil {
			return fmt.Errorf("error reading 'brokers': %w", err)
		}
	}

	if raw, found := object["compression"]; found {
		err = json.Unmarshal(raw, &t.Compression)
		if err != nil {
			return fmt.Errorf("error reading 'compression': %w", err)
		}
	}

	if raw, found := object["password"]; found {
		err = json.Unmarshal(raw, &t.Password)
		if err != nil {
			return fmt.Errorf("error reading 'password': %w", err)
		}
	}

	if raw, found := object["topic"]; found {
		err = json.Unmarshal(raw, &t.Topic)
		if err != nil {
			return fmt.Errorf("error reading 'topic': %w", err)
		}
	}

	if raw, found := object["username"]; found {
		err = json.Unmarshal(raw, &t.Username)
		if err != nil {
			return fmt.Errorf("error reading 'username': %w", err)
		}
	}

	return err
}

// AsKafkaPlaintext returns the union data inside the KafkaSaslScramAuthenticatedConnectionInfo as a KafkaPlaintext
func (t KafkaSaslScramAuthenticatedConnectionInfo) AsKafkaPlaintext() (KafkaPlaintext, error) {
	var body KafkaPlaintext
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaPlaintext overwrites any union data inside the KafkaSaslScramAuthenticatedConnectionInfo as the provided KafkaPlaintext
func (t *KafkaSaslScramAuthenticatedConnectionInfo) FromKafkaPlaintext(v KafkaPlaintext) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaPlaintext performs a merge with any union data inside the KafkaSaslScramAuthenticatedConnectionInfo, using the provided KafkaPlaintext
func (t *KafkaSaslScramAuthenticatedConnectionInfo) MergeKafkaPlaintext(v KafkaPlaintext) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKafkaTlsEncrypted returns the union data inside the KafkaSaslScramAuthenticatedConnectionInfo as a KafkaTlsEncrypted
func (t KafkaSaslScramAuthenticatedConnectionInfo) AsKafkaTlsEncrypted() (KafkaTlsEncrypted, error) {
	var body KafkaTlsEncrypted
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaTlsEncrypted overwrites any union data inside the KafkaSaslScramAuthenticatedConnectionInfo as the provided KafkaTlsEncrypted
func (t *KafkaSaslScramAuthenticatedConnectionInfo) FromKafkaTlsEncrypted(v KafkaTlsEncrypted) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaTlsEncrypted performs a merge with any union data inside the KafkaSaslScramAuthenticatedConnectionInfo, using the provided KafkaTlsEncrypted
func (t *KafkaSaslScramAuthenticatedConnectionInfo) MergeKafkaTlsEncrypted(v KafkaTlsEncrypted) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t KafkaSaslScramAuthenticatedConnectionInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["algorithm"], err = json.Marshal(t.Algorithm)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'algorithm': %w", err)
	}

	object["auth"], err = json.Marshal(t.Auth)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'auth': %w", err)
	}

	if t.Balancer != nil {
		object["balancer"], err = json.Marshal(t.Balancer)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'balancer': %w", err)
		}
	}

	object["brokers"], err = json.Marshal(t.Brokers)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'brokers': %w", err)
	}

	if t.Compression != nil {
		object["compression"], err = json.Marshal(t.Compression)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'compression': %w", err)
		}
	}

	object["topic"], err = json.Marshal(t.Topic)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'topic': %w", err)
	}

	object["username"], err = json.Marshal(t.Username)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'username': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *KafkaSaslScramAuthenticatedConnectionInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["algorithm"]; found {
		err = json.Unmarshal(raw, &t.Algorithm)
		if err != nil {
			return fmt.Errorf("error reading 'algorithm': %w", err)
		}
	}

	if raw, found := object["auth"]; found {
		err = json.Unmarshal(raw, &t.Auth)
		if err != nil {
			return fmt.Errorf("error reading 'auth': %w", err)
		}
	}

	if raw, found := object["balancer"]; found {
		err = json.Unmarshal(raw, &t.Balancer)
		if err != nil {
			return fmt.Errorf("error reading 'balancer': %w", err)
		}
	}

	if raw, found := object["brokers"]; found {
		err = json.Unmarshal(raw, &t.Brokers)
		if err != nil {
			return fmt.Errorf("error reading 'brokers': %w", err)
		}
	}

	if raw, found := object["compression"]; found {
		err = json.Unmarshal(raw, &t.Compression)
		if err != nil {
			return fmt.Errorf("error reading 'compression': %w", err)
		}
	}

	if raw, found := object["topic"]; found {
		err = json.Unmarshal(raw, &t.Topic)
		if err != nil {
			return fmt.Errorf("error reading 'topic': %w", err)
		}
	}

	if raw, found := object["username"]; found {
		err = json.Unmarshal(raw, &t.Username)
		if err != nil {
			return fmt.Errorf("error reading 'username': %w", err)
		}
	}

	return err
}

// AsKafkaPlaintext returns the union data inside the KafkaSaslScramAuthenticatedPrivateConnectionInfo as a KafkaPlaintext
func (t KafkaSaslScramAuthenticatedPrivateConnectionInfo) AsKafkaPlaintext() (KafkaPlaintext, error) {
	var body KafkaPlaintext
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaPlaintext overwrites any union data inside the KafkaSaslScramAuthenticatedPrivateConnectionInfo as the provided KafkaPlaintext
func (t *KafkaSaslScramAuthenticatedPrivateConnectionInfo) FromKafkaPlaintext(v KafkaPlaintext) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaPlaintext performs a merge with any union data inside the KafkaSaslScramAuthenticatedPrivateConnectionInfo, using the provided KafkaPlaintext
func (t *KafkaSaslScramAuthenticatedPrivateConnectionInfo) MergeKafkaPlaintext(v KafkaPlaintext) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKafkaTlsEncrypted returns the union data inside the KafkaSaslScramAuthenticatedPrivateConnectionInfo as a KafkaTlsEncrypted
func (t KafkaSaslScramAuthenticatedPrivateConnectionInfo) AsKafkaTlsEncrypted() (KafkaTlsEncrypted, error) {
	var body KafkaTlsEncrypted
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaTlsEncrypted overwrites any union data inside the KafkaSaslScramAuthenticatedPrivateConnectionInfo as the provided KafkaTlsEncrypted
func (t *KafkaSaslScramAuthenticatedPrivateConnectionInfo) FromKafkaTlsEncrypted(v KafkaTlsEncrypted) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaTlsEncrypted performs a merge with any union data inside the KafkaSaslScramAuthenticatedPrivateConnectionInfo, using the provided KafkaTlsEncrypted
func (t *KafkaSaslScramAuthenticatedPrivateConnectionInfo) MergeKafkaTlsEncrypted(v KafkaTlsEncrypted) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t KafkaSaslScramAuthenticatedPrivateConnectionInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["algorithm"], err = json.Marshal(t.Algorithm)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'algorithm': %w", err)
	}

	object["auth"], err = json.Marshal(t.Auth)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'auth': %w", err)
	}

	if t.Balancer != nil {
		object["balancer"], err = json.Marshal(t.Balancer)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'balancer': %w", err)
		}
	}

	object["brokers"], err = json.Marshal(t.Brokers)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'brokers': %w", err)
	}

	if t.Compression != nil {
		object["compression"], err = json.Marshal(t.Compression)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'compression': %w", err)
		}
	}

	object["password"], err = json.Marshal(t.Password)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'password': %w", err)
	}

	object["topic"], err = json.Marshal(t.Topic)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'topic': %w", err)
	}

	object["username"], err = json.Marshal(t.Username)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'username': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *KafkaSaslScramAuthenticatedPrivateConnectionInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["algorithm"]; found {
		err = json.Unmarshal(raw, &t.Algorithm)
		if err != nil {
			return fmt.Errorf("error reading 'algorithm': %w", err)
		}
	}

	if raw, found := object["auth"]; found {
		err = json.Unmarshal(raw, &t.Auth)
		if err != nil {
			return fmt.Errorf("error reading 'auth': %w", err)
		}
	}

	if raw, found := object["balancer"]; found {
		err = json.Unmarshal(raw, &t.Balancer)
		if err != nil {
			return fmt.Errorf("error reading 'balancer': %w", err)
		}
	}

	if raw, found := object["brokers"]; found {
		err = json.Unmarshal(raw, &t.Brokers)
		if err != nil {
			return fmt.Errorf("error reading 'brokers': %w", err)
		}
	}

	if raw, found := object["compression"]; found {
		err = json.Unmarshal(raw, &t.Compression)
		if err != nil {
			return fmt.Errorf("error reading 'compression': %w", err)
		}
	}

	if raw, found := object["password"]; found {
		err = json.Unmarshal(raw, &t.Password)
		if err != nil {
			return fmt.Errorf("error reading 'password': %w", err)
		}
	}

	if raw, found := object["topic"]; found {
		err = json.Unmarshal(raw, &t.Topic)
		if err != nil {
			return fmt.Errorf("error reading 'topic': %w", err)
		}
	}

	if raw, found := object["username"]; found {
		err = json.Unmarshal(raw, &t.Username)
		if err != nil {
			return fmt.Errorf("error reading 'username': %w", err)
		}
	}

	return err
}

// AsVulnSeverity returns the union data inside the Predicates_Item as a VulnSeverity
func (t Predicates_Item) AsVulnSeverity() (VulnSeverity, error) {
	var body VulnSeverity
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVulnSeverity overwrites any union data inside the Predicates_Item as the provided VulnSeverity
func (t *Predicates_Item) FromVulnSeverity(v VulnSeverity) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVulnSeverity performs a merge with any union data inside the Predicates_Item, using the provided VulnSeverity
func (t *Predicates_Item) MergeVulnSeverity(v VulnSeverity) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVulnSeverityEquals returns the union data inside the Predicates_Item as a VulnSeverityEquals
func (t Predicates_Item) AsVulnSeverityEquals() (VulnSeverityEquals, error) {
	var body VulnSeverityEquals
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVulnSeverityEquals overwrites any union data inside the Predicates_Item as the provided VulnSeverityEquals
func (t *Predicates_Item) FromVulnSeverityEquals(v VulnSeverityEquals) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVulnSeverityEquals performs a merge with any union data inside the Predicates_Item, using the provided VulnSeverityEquals
func (t *Predicates_Item) MergeVulnSeverityEquals(v VulnSeverityEquals) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVulnIsFixable returns the union data inside the Predicates_Item as a VulnIsFixable
func (t Predicates_Item) AsVulnIsFixable() (VulnIsFixable, error) {
	var body VulnIsFixable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVulnIsFixable overwrites any union data inside the Predicates_Item as the provided VulnIsFixable
func (t *Predicates_Item) FromVulnIsFixable(v VulnIsFixable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVulnIsFixable performs a merge with any union data inside the Predicates_Item, using the provided VulnIsFixable
func (t *Predicates_Item) MergeVulnIsFixable(v VulnIsFixable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVulnIsFixableWithAge returns the union data inside the Predicates_Item as a VulnIsFixableWithAge
func (t Predicates_Item) AsVulnIsFixableWithAge() (VulnIsFixableWithAge, error) {
	var body VulnIsFixableWithAge
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVulnIsFixableWithAge overwrites any union data inside the Predicates_Item as the provided VulnIsFixableWithAge
func (t *Predicates_Item) FromVulnIsFixableWithAge(v VulnIsFixableWithAge) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVulnIsFixableWithAge performs a merge with any union data inside the Predicates_Item, using the provided VulnIsFixableWithAge
func (t *Predicates_Item) MergeVulnIsFixableWithAge(v VulnIsFixableWithAge) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVulnAge returns the union data inside the Predicates_Item as a VulnAge
func (t Predicates_Item) AsVulnAge() (VulnAge, error) {
	var body VulnAge
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVulnAge overwrites any union data inside the Predicates_Item as the provided VulnAge
func (t *Predicates_Item) FromVulnAge(v VulnAge) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVulnAge performs a merge with any union data inside the Predicates_Item, using the provided VulnAge
func (t *Predicates_Item) MergeVulnAge(v VulnAge) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVulnPkgType returns the union data inside the Predicates_Item as a VulnPkgType
func (t Predicates_Item) AsVulnPkgType() (VulnPkgType, error) {
	var body VulnPkgType
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVulnPkgType overwrites any union data inside the Predicates_Item as the provided VulnPkgType
func (t *Predicates_Item) FromVulnPkgType(v VulnPkgType) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVulnPkgType performs a merge with any union data inside the Predicates_Item, using the provided VulnPkgType
func (t *Predicates_Item) MergeVulnPkgType(v VulnPkgType) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVulnCvss returns the union data inside the Predicates_Item as a VulnCvss
func (t Predicates_Item) AsVulnCvss() (VulnCvss, error) {
	var body VulnCvss
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVulnCvss overwrites any union data inside the Predicates_Item as the provided VulnCvss
func (t *Predicates_Item) FromVulnCvss(v VulnCvss) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVulnCvss performs a merge with any union data inside the Predicates_Item, using the provided VulnCvss
func (t *Predicates_Item) MergeVulnCvss(v VulnCvss) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVulnCvssEquals returns the union data inside the Predicates_Item as a VulnCvssEquals
func (t Predicates_Item) AsVulnCvssEquals() (VulnCvssEquals, error) {
	var body VulnCvssEquals
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVulnCvssEquals overwrites any union data inside the Predicates_Item as the provided VulnCvssEquals
func (t *Predicates_Item) FromVulnCvssEquals(v VulnCvssEquals) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVulnCvssEquals performs a merge with any union data inside the Predicates_Item, using the provided VulnCvssEquals
func (t *Predicates_Item) MergeVulnCvssEquals(v VulnCvssEquals) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVulnExploitable returns the union data inside the Predicates_Item as a VulnExploitable
func (t Predicates_Item) AsVulnExploitable() (VulnExploitable, error) {
	var body VulnExploitable
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVulnExploitable overwrites any union data inside the Predicates_Item as the provided VulnExploitable
func (t *Predicates_Item) FromVulnExploitable(v VulnExploitable) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVulnExploitable performs a merge with any union data inside the Predicates_Item, using the provided VulnExploitable
func (t *Predicates_Item) MergeVulnExploitable(v VulnExploitable) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVulnExploitableWithAge returns the union data inside the Predicates_Item as a VulnExploitableWithAge
func (t Predicates_Item) AsVulnExploitableWithAge() (VulnExploitableWithAge, error) {
	var body VulnExploitableWithAge
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVulnExploitableWithAge overwrites any union data inside the Predicates_Item as the provided VulnExploitableWithAge
func (t *Predicates_Item) FromVulnExploitableWithAge(v VulnExploitableWithAge) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVulnExploitableWithAge performs a merge with any union data inside the Predicates_Item, using the provided VulnExploitableWithAge
func (t *Predicates_Item) MergeVulnExploitableWithAge(v VulnExploitableWithAge) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVulnExploitableNoAdmin returns the union data inside the Predicates_Item as a VulnExploitableNoAdmin
func (t Predicates_Item) AsVulnExploitableNoAdmin() (VulnExploitableNoAdmin, error) {
	var body VulnExploitableNoAdmin
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVulnExploitableNoAdmin overwrites any union data inside the Predicates_Item as the provided VulnExploitableNoAdmin
func (t *Predicates_Item) FromVulnExploitableNoAdmin(v VulnExploitableNoAdmin) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVulnExploitableNoAdmin performs a merge with any union data inside the Predicates_Item, using the provided VulnExploitableNoAdmin
func (t *Predicates_Item) MergeVulnExploitableNoAdmin(v VulnExploitableNoAdmin) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVulnExploitableNoUser returns the union data inside the Predicates_Item as a VulnExploitableNoUser
func (t Predicates_Item) AsVulnExploitableNoUser() (VulnExploitableNoUser, error) {
	var body VulnExploitableNoUser
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVulnExploitableNoUser overwrites any union data inside the Predicates_Item as the provided VulnExploitableNoUser
func (t *Predicates_Item) FromVulnExploitableNoUser(v VulnExploitableNoUser) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVulnExploitableNoUser performs a merge with any union data inside the Predicates_Item, using the provided VulnExploitableNoUser
func (t *Predicates_Item) MergeVulnExploitableNoUser(v VulnExploitableNoUser) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVulnExploitableViaNetwork returns the union data inside the Predicates_Item as a VulnExploitableViaNetwork
func (t Predicates_Item) AsVulnExploitableViaNetwork() (VulnExploitableViaNetwork, error) {
	var body VulnExploitableViaNetwork
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVulnExploitableViaNetwork overwrites any union data inside the Predicates_Item as the provided VulnExploitableViaNetwork
func (t *Predicates_Item) FromVulnExploitableViaNetwork(v VulnExploitableViaNetwork) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVulnExploitableViaNetwork performs a merge with any union data inside the Predicates_Item, using the provided VulnExploitableViaNetwork
func (t *Predicates_Item) MergeVulnExploitableViaNetwork(v VulnExploitableViaNetwork) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVulnDisclosureRange returns the union data inside the Predicates_Item as a VulnDisclosureRange
func (t Predicates_Item) AsVulnDisclosureRange() (VulnDisclosureRange, error) {
	var body VulnDisclosureRange
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVulnDisclosureRange overwrites any union data inside the Predicates_Item as the provided VulnDisclosureRange
func (t *Predicates_Item) FromVulnDisclosureRange(v VulnDisclosureRange) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVulnDisclosureRange performs a merge with any union data inside the Predicates_Item, using the provided VulnDisclosureRange
func (t *Predicates_Item) MergeVulnDisclosureRange(v VulnDisclosureRange) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVulnIsInUse returns the union data inside the Predicates_Item as a VulnIsInUse
func (t Predicates_Item) AsVulnIsInUse() (VulnIsInUse, error) {
	var body VulnIsInUse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVulnIsInUse overwrites any union data inside the Predicates_Item as the provided VulnIsInUse
func (t *Predicates_Item) FromVulnIsInUse(v VulnIsInUse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVulnIsInUse performs a merge with any union data inside the Predicates_Item, using the provided VulnIsInUse
func (t *Predicates_Item) MergeVulnIsInUse(v VulnIsInUse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVulnEpssScoreGte returns the union data inside the Predicates_Item as a VulnEpssScoreGte
func (t Predicates_Item) AsVulnEpssScoreGte() (VulnEpssScoreGte, error) {
	var body VulnEpssScoreGte
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVulnEpssScoreGte overwrites any union data inside the Predicates_Item as the provided VulnEpssScoreGte
func (t *Predicates_Item) FromVulnEpssScoreGte(v VulnEpssScoreGte) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVulnEpssScoreGte performs a merge with any union data inside the Predicates_Item, using the provided VulnEpssScoreGte
func (t *Predicates_Item) MergeVulnEpssScoreGte(v VulnEpssScoreGte) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVulnEpssPercentileGte returns the union data inside the Predicates_Item as a VulnEpssPercentileGte
func (t Predicates_Item) AsVulnEpssPercentileGte() (VulnEpssPercentileGte, error) {
	var body VulnEpssPercentileGte
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVulnEpssPercentileGte overwrites any union data inside the Predicates_Item as the provided VulnEpssPercentileGte
func (t *Predicates_Item) FromVulnEpssPercentileGte(v VulnEpssPercentileGte) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVulnEpssPercentileGte performs a merge with any union data inside the Predicates_Item, using the provided VulnEpssPercentileGte
func (t *Predicates_Item) MergeVulnEpssPercentileGte(v VulnEpssPercentileGte) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCisaKevPublishDate returns the union data inside the Predicates_Item as a CisaKevPublishDate
func (t Predicates_Item) AsCisaKevPublishDate() (CisaKevPublishDate, error) {
	var body CisaKevPublishDate
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCisaKevPublishDate overwrites any union data inside the Predicates_Item as the provided CisaKevPublishDate
func (t *Predicates_Item) FromCisaKevPublishDate(v CisaKevPublishDate) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCisaKevPublishDate performs a merge with any union data inside the Predicates_Item, using the provided CisaKevPublishDate
func (t *Predicates_Item) MergeCisaKevPublishDate(v CisaKevPublishDate) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCisaKevKnownRansomwareCampaignUse returns the union data inside the Predicates_Item as a CisaKevKnownRansomwareCampaignUse
func (t Predicates_Item) AsCisaKevKnownRansomwareCampaignUse() (CisaKevKnownRansomwareCampaignUse, error) {
	var body CisaKevKnownRansomwareCampaignUse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCisaKevKnownRansomwareCampaignUse overwrites any union data inside the Predicates_Item as the provided CisaKevKnownRansomwareCampaignUse
func (t *Predicates_Item) FromCisaKevKnownRansomwareCampaignUse(v CisaKevKnownRansomwareCampaignUse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCisaKevKnownRansomwareCampaignUse performs a merge with any union data inside the Predicates_Item, using the provided CisaKevKnownRansomwareCampaignUse
func (t *Predicates_Item) MergeCisaKevKnownRansomwareCampaignUse(v CisaKevKnownRansomwareCampaignUse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCisaKevAvailableSince returns the union data inside the Predicates_Item as a CisaKevAvailableSince
func (t Predicates_Item) AsCisaKevAvailableSince() (CisaKevAvailableSince, error) {
	var body CisaKevAvailableSince
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCisaKevAvailableSince overwrites any union data inside the Predicates_Item as the provided CisaKevAvailableSince
func (t *Predicates_Item) FromCisaKevAvailableSince(v CisaKevAvailableSince) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCisaKevAvailableSince performs a merge with any union data inside the Predicates_Item, using the provided CisaKevAvailableSince
func (t *Predicates_Item) MergeCisaKevAvailableSince(v CisaKevAvailableSince) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDenyCve returns the union data inside the Predicates_Item as a DenyCve
func (t Predicates_Item) AsDenyCve() (DenyCve, error) {
	var body DenyCve
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDenyCve overwrites any union data inside the Predicates_Item as the provided DenyCve
func (t *Predicates_Item) FromDenyCve(v DenyCve) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDenyCve performs a merge with any union data inside the Predicates_Item, using the provided DenyCve
func (t *Predicates_Item) MergeDenyCve(v DenyCve) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDenyPkg returns the union data inside the Predicates_Item as a DenyPkg
func (t Predicates_Item) AsDenyPkg() (DenyPkg, error) {
	var body DenyPkg
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDenyPkg overwrites any union data inside the Predicates_Item as the provided DenyPkg
func (t *Predicates_Item) FromDenyPkg(v DenyPkg) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDenyPkg performs a merge with any union data inside the Predicates_Item, using the provided DenyPkg
func (t *Predicates_Item) MergeDenyPkg(v DenyPkg) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageConfigDefaultUserList returns the union data inside the Predicates_Item as a ImageConfigDefaultUserList
func (t Predicates_Item) AsImageConfigDefaultUserList() (ImageConfigDefaultUserList, error) {
	var body ImageConfigDefaultUserList
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageConfigDefaultUserList overwrites any union data inside the Predicates_Item as the provided ImageConfigDefaultUserList
func (t *Predicates_Item) FromImageConfigDefaultUserList(v ImageConfigDefaultUserList) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageConfigDefaultUserList performs a merge with any union data inside the Predicates_Item, using the provided ImageConfigDefaultUserList
func (t *Predicates_Item) MergeImageConfigDefaultUserList(v ImageConfigDefaultUserList) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageConfigDefaultUserIsRoot returns the union data inside the Predicates_Item as a ImageConfigDefaultUserIsRoot
func (t Predicates_Item) AsImageConfigDefaultUserIsRoot() (ImageConfigDefaultUserIsRoot, error) {
	var body ImageConfigDefaultUserIsRoot
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageConfigDefaultUserIsRoot overwrites any union data inside the Predicates_Item as the provided ImageConfigDefaultUserIsRoot
func (t *Predicates_Item) FromImageConfigDefaultUserIsRoot(v ImageConfigDefaultUserIsRoot) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageConfigDefaultUserIsRoot performs a merge with any union data inside the Predicates_Item, using the provided ImageConfigDefaultUserIsRoot
func (t *Predicates_Item) MergeImageConfigDefaultUserIsRoot(v ImageConfigDefaultUserIsRoot) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageConfigDefaultUserIsNot returns the union data inside the Predicates_Item as a ImageConfigDefaultUserIsNot
func (t Predicates_Item) AsImageConfigDefaultUserIsNot() (ImageConfigDefaultUserIsNot, error) {
	var body ImageConfigDefaultUserIsNot
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageConfigDefaultUserIsNot overwrites any union data inside the Predicates_Item as the provided ImageConfigDefaultUserIsNot
func (t *Predicates_Item) FromImageConfigDefaultUserIsNot(v ImageConfigDefaultUserIsNot) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageConfigDefaultUserIsNot performs a merge with any union data inside the Predicates_Item, using the provided ImageConfigDefaultUserIsNot
func (t *Predicates_Item) MergeImageConfigDefaultUserIsNot(v ImageConfigDefaultUserIsNot) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageConfigLabelExists returns the union data inside the Predicates_Item as a ImageConfigLabelExists
func (t Predicates_Item) AsImageConfigLabelExists() (ImageConfigLabelExists, error) {
	var body ImageConfigLabelExists
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageConfigLabelExists overwrites any union data inside the Predicates_Item as the provided ImageConfigLabelExists
func (t *Predicates_Item) FromImageConfigLabelExists(v ImageConfigLabelExists) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageConfigLabelExists performs a merge with any union data inside the Predicates_Item, using the provided ImageConfigLabelExists
func (t *Predicates_Item) MergeImageConfigLabelExists(v ImageConfigLabelExists) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageConfigLabelNotExists returns the union data inside the Predicates_Item as a ImageConfigLabelNotExists
func (t Predicates_Item) AsImageConfigLabelNotExists() (ImageConfigLabelNotExists, error) {
	var body ImageConfigLabelNotExists
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageConfigLabelNotExists overwrites any union data inside the Predicates_Item as the provided ImageConfigLabelNotExists
func (t *Predicates_Item) FromImageConfigLabelNotExists(v ImageConfigLabelNotExists) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageConfigLabelNotExists performs a merge with any union data inside the Predicates_Item, using the provided ImageConfigLabelNotExists
func (t *Predicates_Item) MergeImageConfigLabelNotExists(v ImageConfigLabelNotExists) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageConfigLabelNotContains returns the union data inside the Predicates_Item as a ImageConfigLabelNotContains
func (t Predicates_Item) AsImageConfigLabelNotContains() (ImageConfigLabelNotContains, error) {
	var body ImageConfigLabelNotContains
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageConfigLabelNotContains overwrites any union data inside the Predicates_Item as the provided ImageConfigLabelNotContains
func (t *Predicates_Item) FromImageConfigLabelNotContains(v ImageConfigLabelNotContains) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageConfigLabelNotContains performs a merge with any union data inside the Predicates_Item, using the provided ImageConfigLabelNotContains
func (t *Predicates_Item) MergeImageConfigLabelNotContains(v ImageConfigLabelNotContains) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageConfigEnvVariableExists returns the union data inside the Predicates_Item as a ImageConfigEnvVariableExists
func (t Predicates_Item) AsImageConfigEnvVariableExists() (ImageConfigEnvVariableExists, error) {
	var body ImageConfigEnvVariableExists
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageConfigEnvVariableExists overwrites any union data inside the Predicates_Item as the provided ImageConfigEnvVariableExists
func (t *Predicates_Item) FromImageConfigEnvVariableExists(v ImageConfigEnvVariableExists) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageConfigEnvVariableExists performs a merge with any union data inside the Predicates_Item, using the provided ImageConfigEnvVariableExists
func (t *Predicates_Item) MergeImageConfigEnvVariableExists(v ImageConfigEnvVariableExists) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageConfigEnvVariableNotExists returns the union data inside the Predicates_Item as a ImageConfigEnvVariableNotExists
func (t Predicates_Item) AsImageConfigEnvVariableNotExists() (ImageConfigEnvVariableNotExists, error) {
	var body ImageConfigEnvVariableNotExists
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageConfigEnvVariableNotExists overwrites any union data inside the Predicates_Item as the provided ImageConfigEnvVariableNotExists
func (t *Predicates_Item) FromImageConfigEnvVariableNotExists(v ImageConfigEnvVariableNotExists) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageConfigEnvVariableNotExists performs a merge with any union data inside the Predicates_Item, using the provided ImageConfigEnvVariableNotExists
func (t *Predicates_Item) MergeImageConfigEnvVariableNotExists(v ImageConfigEnvVariableNotExists) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageConfigEnvVariableContains returns the union data inside the Predicates_Item as a ImageConfigEnvVariableContains
func (t Predicates_Item) AsImageConfigEnvVariableContains() (ImageConfigEnvVariableContains, error) {
	var body ImageConfigEnvVariableContains
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageConfigEnvVariableContains overwrites any union data inside the Predicates_Item as the provided ImageConfigEnvVariableContains
func (t *Predicates_Item) FromImageConfigEnvVariableContains(v ImageConfigEnvVariableContains) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageConfigEnvVariableContains performs a merge with any union data inside the Predicates_Item, using the provided ImageConfigEnvVariableContains
func (t *Predicates_Item) MergeImageConfigEnvVariableContains(v ImageConfigEnvVariableContains) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageConfigInstructionNotRecommended returns the union data inside the Predicates_Item as a ImageConfigInstructionNotRecommended
func (t Predicates_Item) AsImageConfigInstructionNotRecommended() (ImageConfigInstructionNotRecommended, error) {
	var body ImageConfigInstructionNotRecommended
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageConfigInstructionNotRecommended overwrites any union data inside the Predicates_Item as the provided ImageConfigInstructionNotRecommended
func (t *Predicates_Item) FromImageConfigInstructionNotRecommended(v ImageConfigInstructionNotRecommended) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageConfigInstructionNotRecommended performs a merge with any union data inside the Predicates_Item, using the provided ImageConfigInstructionNotRecommended
func (t *Predicates_Item) MergeImageConfigInstructionNotRecommended(v ImageConfigInstructionNotRecommended) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageConfigInstructionIsPkgManager returns the union data inside the Predicates_Item as a ImageConfigInstructionIsPkgManager
func (t Predicates_Item) AsImageConfigInstructionIsPkgManager() (ImageConfigInstructionIsPkgManager, error) {
	var body ImageConfigInstructionIsPkgManager
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageConfigInstructionIsPkgManager overwrites any union data inside the Predicates_Item as the provided ImageConfigInstructionIsPkgManager
func (t *Predicates_Item) FromImageConfigInstructionIsPkgManager(v ImageConfigInstructionIsPkgManager) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageConfigInstructionIsPkgManager performs a merge with any union data inside the Predicates_Item, using the provided ImageConfigInstructionIsPkgManager
func (t *Predicates_Item) MergeImageConfigInstructionIsPkgManager(v ImageConfigInstructionIsPkgManager) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageConfigCreationDateWithAge returns the union data inside the Predicates_Item as a ImageConfigCreationDateWithAge
func (t Predicates_Item) AsImageConfigCreationDateWithAge() (ImageConfigCreationDateWithAge, error) {
	var body ImageConfigCreationDateWithAge
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageConfigCreationDateWithAge overwrites any union data inside the Predicates_Item as the provided ImageConfigCreationDateWithAge
func (t *Predicates_Item) FromImageConfigCreationDateWithAge(v ImageConfigCreationDateWithAge) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageConfigCreationDateWithAge performs a merge with any union data inside the Predicates_Item, using the provided ImageConfigCreationDateWithAge
func (t *Predicates_Item) MergeImageConfigCreationDateWithAge(v ImageConfigCreationDateWithAge) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsImageConfigSensitiveInformationAndSecrets returns the union data inside the Predicates_Item as a ImageConfigSensitiveInformationAndSecrets
func (t Predicates_Item) AsImageConfigSensitiveInformationAndSecrets() (ImageConfigSensitiveInformationAndSecrets, error) {
	var body ImageConfigSensitiveInformationAndSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageConfigSensitiveInformationAndSecrets overwrites any union data inside the Predicates_Item as the provided ImageConfigSensitiveInformationAndSecrets
func (t *Predicates_Item) FromImageConfigSensitiveInformationAndSecrets(v ImageConfigSensitiveInformationAndSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageConfigSensitiveInformationAndSecrets performs a merge with any union data inside the Predicates_Item, using the provided ImageConfigSensitiveInformationAndSecrets
func (t *Predicates_Item) MergeImageConfigSensitiveInformationAndSecrets(v ImageConfigSensitiveInformationAndSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Predicates_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Predicates_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsContextEmpty returns the union data inside the RiskAcceptedResponse_Context as a ContextEmpty
func (t RiskAcceptedResponse_Context) AsContextEmpty() (ContextEmpty, error) {
	var body ContextEmpty
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextEmpty overwrites any union data inside the RiskAcceptedResponse_Context as the provided ContextEmpty
func (t *RiskAcceptedResponse_Context) FromContextEmpty(v ContextEmpty) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextEmpty performs a merge with any union data inside the RiskAcceptedResponse_Context, using the provided ContextEmpty
func (t *RiskAcceptedResponse_Context) MergeContextEmpty(v ContextEmpty) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContextImageName returns the union data inside the RiskAcceptedResponse_Context as a ContextImageName
func (t RiskAcceptedResponse_Context) AsContextImageName() (ContextImageName, error) {
	var body ContextImageName
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextImageName overwrites any union data inside the RiskAcceptedResponse_Context as the provided ContextImageName
func (t *RiskAcceptedResponse_Context) FromContextImageName(v ContextImageName) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextImageName performs a merge with any union data inside the RiskAcceptedResponse_Context, using the provided ContextImageName
func (t *RiskAcceptedResponse_Context) MergeContextImageName(v ContextImageName) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContextImageSuffix returns the union data inside the RiskAcceptedResponse_Context as a ContextImageSuffix
func (t RiskAcceptedResponse_Context) AsContextImageSuffix() (ContextImageSuffix, error) {
	var body ContextImageSuffix
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextImageSuffix overwrites any union data inside the RiskAcceptedResponse_Context as the provided ContextImageSuffix
func (t *RiskAcceptedResponse_Context) FromContextImageSuffix(v ContextImageSuffix) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextImageSuffix performs a merge with any union data inside the RiskAcceptedResponse_Context, using the provided ContextImageSuffix
func (t *RiskAcceptedResponse_Context) MergeContextImageSuffix(v ContextImageSuffix) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContextImagePrefix returns the union data inside the RiskAcceptedResponse_Context as a ContextImagePrefix
func (t RiskAcceptedResponse_Context) AsContextImagePrefix() (ContextImagePrefix, error) {
	var body ContextImagePrefix
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextImagePrefix overwrites any union data inside the RiskAcceptedResponse_Context as the provided ContextImagePrefix
func (t *RiskAcceptedResponse_Context) FromContextImagePrefix(v ContextImagePrefix) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextImagePrefix performs a merge with any union data inside the RiskAcceptedResponse_Context, using the provided ContextImagePrefix
func (t *RiskAcceptedResponse_Context) MergeContextImagePrefix(v ContextImagePrefix) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContextImageContains returns the union data inside the RiskAcceptedResponse_Context as a ContextImageContains
func (t RiskAcceptedResponse_Context) AsContextImageContains() (ContextImageContains, error) {
	var body ContextImageContains
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextImageContains overwrites any union data inside the RiskAcceptedResponse_Context as the provided ContextImageContains
func (t *RiskAcceptedResponse_Context) FromContextImageContains(v ContextImageContains) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextImageContains performs a merge with any union data inside the RiskAcceptedResponse_Context, using the provided ContextImageContains
func (t *RiskAcceptedResponse_Context) MergeContextImageContains(v ContextImageContains) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContextPackageName returns the union data inside the RiskAcceptedResponse_Context as a ContextPackageName
func (t RiskAcceptedResponse_Context) AsContextPackageName() (ContextPackageName, error) {
	var body ContextPackageName
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextPackageName overwrites any union data inside the RiskAcceptedResponse_Context as the provided ContextPackageName
func (t *RiskAcceptedResponse_Context) FromContextPackageName(v ContextPackageName) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextPackageName performs a merge with any union data inside the RiskAcceptedResponse_Context, using the provided ContextPackageName
func (t *RiskAcceptedResponse_Context) MergeContextPackageName(v ContextPackageName) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContextPackageNameVersion returns the union data inside the RiskAcceptedResponse_Context as a ContextPackageNameVersion
func (t RiskAcceptedResponse_Context) AsContextPackageNameVersion() (ContextPackageNameVersion, error) {
	var body ContextPackageNameVersion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextPackageNameVersion overwrites any union data inside the RiskAcceptedResponse_Context as the provided ContextPackageNameVersion
func (t *RiskAcceptedResponse_Context) FromContextPackageNameVersion(v ContextPackageNameVersion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextPackageNameVersion performs a merge with any union data inside the RiskAcceptedResponse_Context, using the provided ContextPackageNameVersion
func (t *RiskAcceptedResponse_Context) MergeContextPackageNameVersion(v ContextPackageNameVersion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContextHostName returns the union data inside the RiskAcceptedResponse_Context as a ContextHostName
func (t RiskAcceptedResponse_Context) AsContextHostName() (ContextHostName, error) {
	var body ContextHostName
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextHostName overwrites any union data inside the RiskAcceptedResponse_Context as the provided ContextHostName
func (t *RiskAcceptedResponse_Context) FromContextHostName(v ContextHostName) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextHostName performs a merge with any union data inside the RiskAcceptedResponse_Context, using the provided ContextHostName
func (t *RiskAcceptedResponse_Context) MergeContextHostName(v ContextHostName) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContextHostContains returns the union data inside the RiskAcceptedResponse_Context as a ContextHostContains
func (t RiskAcceptedResponse_Context) AsContextHostContains() (ContextHostContains, error) {
	var body ContextHostContains
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextHostContains overwrites any union data inside the RiskAcceptedResponse_Context as the provided ContextHostContains
func (t *RiskAcceptedResponse_Context) FromContextHostContains(v ContextHostContains) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextHostContains performs a merge with any union data inside the RiskAcceptedResponse_Context, using the provided ContextHostContains
func (t *RiskAcceptedResponse_Context) MergeContextHostContains(v ContextHostContains) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContextPackagePath returns the union data inside the RiskAcceptedResponse_Context as a ContextPackagePath
func (t RiskAcceptedResponse_Context) AsContextPackagePath() (ContextPackagePath, error) {
	var body ContextPackagePath
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextPackagePath overwrites any union data inside the RiskAcceptedResponse_Context as the provided ContextPackagePath
func (t *RiskAcceptedResponse_Context) FromContextPackagePath(v ContextPackagePath) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextPackagePath performs a merge with any union data inside the RiskAcceptedResponse_Context, using the provided ContextPackagePath
func (t *RiskAcceptedResponse_Context) MergeContextPackagePath(v ContextPackagePath) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContextPackageVersion returns the union data inside the RiskAcceptedResponse_Context as a ContextPackageVersion
func (t RiskAcceptedResponse_Context) AsContextPackageVersion() (ContextPackageVersion, error) {
	var body ContextPackageVersion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextPackageVersion overwrites any union data inside the RiskAcceptedResponse_Context as the provided ContextPackageVersion
func (t *RiskAcceptedResponse_Context) FromContextPackageVersion(v ContextPackageVersion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextPackageVersion performs a merge with any union data inside the RiskAcceptedResponse_Context, using the provided ContextPackageVersion
func (t *RiskAcceptedResponse_Context) MergeContextPackageVersion(v ContextPackageVersion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsContextPackagePathVersion returns the union data inside the RiskAcceptedResponse_Context as a ContextPackagePathVersion
func (t RiskAcceptedResponse_Context) AsContextPackagePathVersion() (ContextPackagePathVersion, error) {
	var body ContextPackagePathVersion
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromContextPackagePathVersion overwrites any union data inside the RiskAcceptedResponse_Context as the provided ContextPackagePathVersion
func (t *RiskAcceptedResponse_Context) FromContextPackagePathVersion(v ContextPackagePathVersion) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeContextPackagePathVersion performs a merge with any union data inside the RiskAcceptedResponse_Context, using the provided ContextPackagePathVersion
func (t *RiskAcceptedResponse_Context) MergeContextPackagePathVersion(v ContextPackagePathVersion) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RiskAcceptedResponse_Context) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RiskAcceptedResponse_Context) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsImageConfigFailure returns the union data inside the Rule_Failures_Item as a ImageConfigFailure
func (t Rule_Failures_Item) AsImageConfigFailure() (ImageConfigFailure, error) {
	var body ImageConfigFailure
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageConfigFailure overwrites any union data inside the Rule_Failures_Item as the provided ImageConfigFailure
func (t *Rule_Failures_Item) FromImageConfigFailure(v ImageConfigFailure) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageConfigFailure performs a merge with any union data inside the Rule_Failures_Item, using the provided ImageConfigFailure
func (t *Rule_Failures_Item) MergeImageConfigFailure(v ImageConfigFailure) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPkgVulnFailure returns the union data inside the Rule_Failures_Item as a PkgVulnFailure
func (t Rule_Failures_Item) AsPkgVulnFailure() (PkgVulnFailure, error) {
	var body PkgVulnFailure
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPkgVulnFailure overwrites any union data inside the Rule_Failures_Item as the provided PkgVulnFailure
func (t *Rule_Failures_Item) FromPkgVulnFailure(v PkgVulnFailure) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePkgVulnFailure performs a merge with any union data inside the Rule_Failures_Item, using the provided PkgVulnFailure
func (t *Rule_Failures_Item) MergePkgVulnFailure(v PkgVulnFailure) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Rule_Failures_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Rule_Failures_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsImageMetadata returns the union data inside the ScanResultResponse_Metadata as a ImageMetadata
func (t ScanResultResponse_Metadata) AsImageMetadata() (ImageMetadata, error) {
	var body ImageMetadata
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromImageMetadata overwrites any union data inside the ScanResultResponse_Metadata as the provided ImageMetadata
func (t *ScanResultResponse_Metadata) FromImageMetadata(v ImageMetadata) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeImageMetadata performs a merge with any union data inside the ScanResultResponse_Metadata, using the provided ImageMetadata
func (t *ScanResultResponse_Metadata) MergeImageMetadata(v ImageMetadata) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHostMetadata returns the union data inside the ScanResultResponse_Metadata as a HostMetadata
func (t ScanResultResponse_Metadata) AsHostMetadata() (HostMetadata, error) {
	var body HostMetadata
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHostMetadata overwrites any union data inside the ScanResultResponse_Metadata as the provided HostMetadata
func (t *ScanResultResponse_Metadata) FromHostMetadata(v HostMetadata) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHostMetadata performs a merge with any union data inside the ScanResultResponse_Metadata, using the provided HostMetadata
func (t *ScanResultResponse_Metadata) MergeHostMetadata(v HostMetadata) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ScanResultResponse_Metadata) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ScanResultResponse_Metadata) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateChronicleIntegrationConnInfoV2 returns the union data inside the UpdateChronicleIntegrationRequest_ConnectionInfo as a UpdateChronicleIntegrationConnInfoV2
func (t UpdateChronicleIntegrationRequest_ConnectionInfo) AsUpdateChronicleIntegrationConnInfoV2() (UpdateChronicleIntegrationConnInfoV2, error) {
	var body UpdateChronicleIntegrationConnInfoV2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateChronicleIntegrationConnInfoV2 overwrites any union data inside the UpdateChronicleIntegrationRequest_ConnectionInfo as the provided UpdateChronicleIntegrationConnInfoV2
func (t *UpdateChronicleIntegrationRequest_ConnectionInfo) FromUpdateChronicleIntegrationConnInfoV2(v UpdateChronicleIntegrationConnInfoV2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateChronicleIntegrationConnInfoV2 performs a merge with any union data inside the UpdateChronicleIntegrationRequest_ConnectionInfo, using the provided UpdateChronicleIntegrationConnInfoV2
func (t *UpdateChronicleIntegrationRequest_ConnectionInfo) MergeUpdateChronicleIntegrationConnInfoV2(v UpdateChronicleIntegrationConnInfoV2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateChronicleIntegrationConnInfo returns the union data inside the UpdateChronicleIntegrationRequest_ConnectionInfo as a UpdateChronicleIntegrationConnInfo
func (t UpdateChronicleIntegrationRequest_ConnectionInfo) AsUpdateChronicleIntegrationConnInfo() (UpdateChronicleIntegrationConnInfo, error) {
	var body UpdateChronicleIntegrationConnInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateChronicleIntegrationConnInfo overwrites any union data inside the UpdateChronicleIntegrationRequest_ConnectionInfo as the provided UpdateChronicleIntegrationConnInfo
func (t *UpdateChronicleIntegrationRequest_ConnectionInfo) FromUpdateChronicleIntegrationConnInfo(v UpdateChronicleIntegrationConnInfo) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateChronicleIntegrationConnInfo performs a merge with any union data inside the UpdateChronicleIntegrationRequest_ConnectionInfo, using the provided UpdateChronicleIntegrationConnInfo
func (t *UpdateChronicleIntegrationRequest_ConnectionInfo) MergeUpdateChronicleIntegrationConnInfo(v UpdateChronicleIntegrationConnInfo) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateChronicleIntegrationRequest_ConnectionInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateChronicleIntegrationRequest_ConnectionInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateChronicleIntegrationRequest returns the union data inside the UpdateEfoIntegrationRequestV1 as a UpdateChronicleIntegrationRequest
func (t UpdateEfoIntegrationRequestV1) AsUpdateChronicleIntegrationRequest() (UpdateChronicleIntegrationRequest, error) {
	var body UpdateChronicleIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateChronicleIntegrationRequest overwrites any union data inside the UpdateEfoIntegrationRequestV1 as the provided UpdateChronicleIntegrationRequest
func (t *UpdateEfoIntegrationRequestV1) FromUpdateChronicleIntegrationRequest(v UpdateChronicleIntegrationRequest) error {
	v.Type = "CHRONICLE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateChronicleIntegrationRequest performs a merge with any union data inside the UpdateEfoIntegrationRequestV1, using the provided UpdateChronicleIntegrationRequest
func (t *UpdateEfoIntegrationRequestV1) MergeUpdateChronicleIntegrationRequest(v UpdateChronicleIntegrationRequest) error {
	v.Type = "CHRONICLE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateElasticsearchIntegrationRequest returns the union data inside the UpdateEfoIntegrationRequestV1 as a UpdateElasticsearchIntegrationRequest
func (t UpdateEfoIntegrationRequestV1) AsUpdateElasticsearchIntegrationRequest() (UpdateElasticsearchIntegrationRequest, error) {
	var body UpdateElasticsearchIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateElasticsearchIntegrationRequest overwrites any union data inside the UpdateEfoIntegrationRequestV1 as the provided UpdateElasticsearchIntegrationRequest
func (t *UpdateEfoIntegrationRequestV1) FromUpdateElasticsearchIntegrationRequest(v UpdateElasticsearchIntegrationRequest) error {
	v.Type = "ELASTIC"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateElasticsearchIntegrationRequest performs a merge with any union data inside the UpdateEfoIntegrationRequestV1, using the provided UpdateElasticsearchIntegrationRequest
func (t *UpdateEfoIntegrationRequestV1) MergeUpdateElasticsearchIntegrationRequest(v UpdateElasticsearchIntegrationRequest) error {
	v.Type = "ELASTIC"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateGooglePubSubIntegrationRequest returns the union data inside the UpdateEfoIntegrationRequestV1 as a UpdateGooglePubSubIntegrationRequest
func (t UpdateEfoIntegrationRequestV1) AsUpdateGooglePubSubIntegrationRequest() (UpdateGooglePubSubIntegrationRequest, error) {
	var body UpdateGooglePubSubIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateGooglePubSubIntegrationRequest overwrites any union data inside the UpdateEfoIntegrationRequestV1 as the provided UpdateGooglePubSubIntegrationRequest
func (t *UpdateEfoIntegrationRequestV1) FromUpdateGooglePubSubIntegrationRequest(v UpdateGooglePubSubIntegrationRequest) error {
	v.Type = "PUBSUB"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateGooglePubSubIntegrationRequest performs a merge with any union data inside the UpdateEfoIntegrationRequestV1, using the provided UpdateGooglePubSubIntegrationRequest
func (t *UpdateEfoIntegrationRequestV1) MergeUpdateGooglePubSubIntegrationRequest(v UpdateGooglePubSubIntegrationRequest) error {
	v.Type = "PUBSUB"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateKafkaIntegrationRequestV1 returns the union data inside the UpdateEfoIntegrationRequestV1 as a UpdateKafkaIntegrationRequestV1
func (t UpdateEfoIntegrationRequestV1) AsUpdateKafkaIntegrationRequestV1() (UpdateKafkaIntegrationRequestV1, error) {
	var body UpdateKafkaIntegrationRequestV1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateKafkaIntegrationRequestV1 overwrites any union data inside the UpdateEfoIntegrationRequestV1 as the provided UpdateKafkaIntegrationRequestV1
func (t *UpdateEfoIntegrationRequestV1) FromUpdateKafkaIntegrationRequestV1(v UpdateKafkaIntegrationRequestV1) error {
	v.Type = "KAFKA"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateKafkaIntegrationRequestV1 performs a merge with any union data inside the UpdateEfoIntegrationRequestV1, using the provided UpdateKafkaIntegrationRequestV1
func (t *UpdateEfoIntegrationRequestV1) MergeUpdateKafkaIntegrationRequestV1(v UpdateKafkaIntegrationRequestV1) error {
	v.Type = "KAFKA"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateMcmIntegrationRequest returns the union data inside the UpdateEfoIntegrationRequestV1 as a UpdateMcmIntegrationRequest
func (t UpdateEfoIntegrationRequestV1) AsUpdateMcmIntegrationRequest() (UpdateMcmIntegrationRequest, error) {
	var body UpdateMcmIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateMcmIntegrationRequest overwrites any union data inside the UpdateEfoIntegrationRequestV1 as the provided UpdateMcmIntegrationRequest
func (t *UpdateEfoIntegrationRequestV1) FromUpdateMcmIntegrationRequest(v UpdateMcmIntegrationRequest) error {
	v.Type = "MCM"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateMcmIntegrationRequest performs a merge with any union data inside the UpdateEfoIntegrationRequestV1, using the provided UpdateMcmIntegrationRequest
func (t *UpdateEfoIntegrationRequestV1) MergeUpdateMcmIntegrationRequest(v UpdateMcmIntegrationRequest) error {
	v.Type = "MCM"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateQradarIntegrationRequest returns the union data inside the UpdateEfoIntegrationRequestV1 as a UpdateQradarIntegrationRequest
func (t UpdateEfoIntegrationRequestV1) AsUpdateQradarIntegrationRequest() (UpdateQradarIntegrationRequest, error) {
	var body UpdateQradarIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateQradarIntegrationRequest overwrites any union data inside the UpdateEfoIntegrationRequestV1 as the provided UpdateQradarIntegrationRequest
func (t *UpdateEfoIntegrationRequestV1) FromUpdateQradarIntegrationRequest(v UpdateQradarIntegrationRequest) error {
	v.Type = "QRADAR"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateQradarIntegrationRequest performs a merge with any union data inside the UpdateEfoIntegrationRequestV1, using the provided UpdateQradarIntegrationRequest
func (t *UpdateEfoIntegrationRequestV1) MergeUpdateQradarIntegrationRequest(v UpdateQradarIntegrationRequest) error {
	v.Type = "QRADAR"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateGoogleSccIntegrationRequest returns the union data inside the UpdateEfoIntegrationRequestV1 as a UpdateGoogleSccIntegrationRequest
func (t UpdateEfoIntegrationRequestV1) AsUpdateGoogleSccIntegrationRequest() (UpdateGoogleSccIntegrationRequest, error) {
	var body UpdateGoogleSccIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateGoogleSccIntegrationRequest overwrites any union data inside the UpdateEfoIntegrationRequestV1 as the provided UpdateGoogleSccIntegrationRequest
func (t *UpdateEfoIntegrationRequestV1) FromUpdateGoogleSccIntegrationRequest(v UpdateGoogleSccIntegrationRequest) error {
	v.Type = "SCC"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateGoogleSccIntegrationRequest performs a merge with any union data inside the UpdateEfoIntegrationRequestV1, using the provided UpdateGoogleSccIntegrationRequest
func (t *UpdateEfoIntegrationRequestV1) MergeUpdateGoogleSccIntegrationRequest(v UpdateGoogleSccIntegrationRequest) error {
	v.Type = "SCC"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateMicrosoftSentinelIntegrationRequest returns the union data inside the UpdateEfoIntegrationRequestV1 as a UpdateMicrosoftSentinelIntegrationRequest
func (t UpdateEfoIntegrationRequestV1) AsUpdateMicrosoftSentinelIntegrationRequest() (UpdateMicrosoftSentinelIntegrationRequest, error) {
	var body UpdateMicrosoftSentinelIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateMicrosoftSentinelIntegrationRequest overwrites any union data inside the UpdateEfoIntegrationRequestV1 as the provided UpdateMicrosoftSentinelIntegrationRequest
func (t *UpdateEfoIntegrationRequestV1) FromUpdateMicrosoftSentinelIntegrationRequest(v UpdateMicrosoftSentinelIntegrationRequest) error {
	v.Type = "SENTINEL"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateMicrosoftSentinelIntegrationRequest performs a merge with any union data inside the UpdateEfoIntegrationRequestV1, using the provided UpdateMicrosoftSentinelIntegrationRequest
func (t *UpdateEfoIntegrationRequestV1) MergeUpdateMicrosoftSentinelIntegrationRequest(v UpdateMicrosoftSentinelIntegrationRequest) error {
	v.Type = "SENTINEL"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateSplunkIntegrationRequest returns the union data inside the UpdateEfoIntegrationRequestV1 as a UpdateSplunkIntegrationRequest
func (t UpdateEfoIntegrationRequestV1) AsUpdateSplunkIntegrationRequest() (UpdateSplunkIntegrationRequest, error) {
	var body UpdateSplunkIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateSplunkIntegrationRequest overwrites any union data inside the UpdateEfoIntegrationRequestV1 as the provided UpdateSplunkIntegrationRequest
func (t *UpdateEfoIntegrationRequestV1) FromUpdateSplunkIntegrationRequest(v UpdateSplunkIntegrationRequest) error {
	v.Type = "SPLUNK"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateSplunkIntegrationRequest performs a merge with any union data inside the UpdateEfoIntegrationRequestV1, using the provided UpdateSplunkIntegrationRequest
func (t *UpdateEfoIntegrationRequestV1) MergeUpdateSplunkIntegrationRequest(v UpdateSplunkIntegrationRequest) error {
	v.Type = "SPLUNK"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateAmazonSqsIntegrationRequest returns the union data inside the UpdateEfoIntegrationRequestV1 as a UpdateAmazonSqsIntegrationRequest
func (t UpdateEfoIntegrationRequestV1) AsUpdateAmazonSqsIntegrationRequest() (UpdateAmazonSqsIntegrationRequest, error) {
	var body UpdateAmazonSqsIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateAmazonSqsIntegrationRequest overwrites any union data inside the UpdateEfoIntegrationRequestV1 as the provided UpdateAmazonSqsIntegrationRequest
func (t *UpdateEfoIntegrationRequestV1) FromUpdateAmazonSqsIntegrationRequest(v UpdateAmazonSqsIntegrationRequest) error {
	v.Type = "SQS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateAmazonSqsIntegrationRequest performs a merge with any union data inside the UpdateEfoIntegrationRequestV1, using the provided UpdateAmazonSqsIntegrationRequest
func (t *UpdateEfoIntegrationRequestV1) MergeUpdateAmazonSqsIntegrationRequest(v UpdateAmazonSqsIntegrationRequest) error {
	v.Type = "SQS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateSyslogIntegrationRequest returns the union data inside the UpdateEfoIntegrationRequestV1 as a UpdateSyslogIntegrationRequest
func (t UpdateEfoIntegrationRequestV1) AsUpdateSyslogIntegrationRequest() (UpdateSyslogIntegrationRequest, error) {
	var body UpdateSyslogIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateSyslogIntegrationRequest overwrites any union data inside the UpdateEfoIntegrationRequestV1 as the provided UpdateSyslogIntegrationRequest
func (t *UpdateEfoIntegrationRequestV1) FromUpdateSyslogIntegrationRequest(v UpdateSyslogIntegrationRequest) error {
	v.Type = "SYSLOG"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateSyslogIntegrationRequest performs a merge with any union data inside the UpdateEfoIntegrationRequestV1, using the provided UpdateSyslogIntegrationRequest
func (t *UpdateEfoIntegrationRequestV1) MergeUpdateSyslogIntegrationRequest(v UpdateSyslogIntegrationRequest) error {
	v.Type = "SYSLOG"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateWebhookIntegrationRequest returns the union data inside the UpdateEfoIntegrationRequestV1 as a UpdateWebhookIntegrationRequest
func (t UpdateEfoIntegrationRequestV1) AsUpdateWebhookIntegrationRequest() (UpdateWebhookIntegrationRequest, error) {
	var body UpdateWebhookIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateWebhookIntegrationRequest overwrites any union data inside the UpdateEfoIntegrationRequestV1 as the provided UpdateWebhookIntegrationRequest
func (t *UpdateEfoIntegrationRequestV1) FromUpdateWebhookIntegrationRequest(v UpdateWebhookIntegrationRequest) error {
	v.Type = "WEBHOOK"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateWebhookIntegrationRequest performs a merge with any union data inside the UpdateEfoIntegrationRequestV1, using the provided UpdateWebhookIntegrationRequest
func (t *UpdateEfoIntegrationRequestV1) MergeUpdateWebhookIntegrationRequest(v UpdateWebhookIntegrationRequest) error {
	v.Type = "WEBHOOK"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateEfoIntegrationRequestV1) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UpdateEfoIntegrationRequestV1) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "CHRONICLE":
		return t.AsUpdateChronicleIntegrationRequest()
	case "ELASTIC":
		return t.AsUpdateElasticsearchIntegrationRequest()
	case "KAFKA":
		return t.AsUpdateKafkaIntegrationRequestV1()
	case "MCM":
		return t.AsUpdateMcmIntegrationRequest()
	case "PUBSUB":
		return t.AsUpdateGooglePubSubIntegrationRequest()
	case "QRADAR":
		return t.AsUpdateQradarIntegrationRequest()
	case "SCC":
		return t.AsUpdateGoogleSccIntegrationRequest()
	case "SENTINEL":
		return t.AsUpdateMicrosoftSentinelIntegrationRequest()
	case "SPLUNK":
		return t.AsUpdateSplunkIntegrationRequest()
	case "SQS":
		return t.AsUpdateAmazonSqsIntegrationRequest()
	case "SYSLOG":
		return t.AsUpdateSyslogIntegrationRequest()
	case "WEBHOOK":
		return t.AsUpdateWebhookIntegrationRequest()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UpdateEfoIntegrationRequestV1) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateEfoIntegrationRequestV1) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateChronicleIntegrationRequest returns the union data inside the UpdateIntegrationRequest as a UpdateChronicleIntegrationRequest
func (t UpdateIntegrationRequest) AsUpdateChronicleIntegrationRequest() (UpdateChronicleIntegrationRequest, error) {
	var body UpdateChronicleIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateChronicleIntegrationRequest overwrites any union data inside the UpdateIntegrationRequest as the provided UpdateChronicleIntegrationRequest
func (t *UpdateIntegrationRequest) FromUpdateChronicleIntegrationRequest(v UpdateChronicleIntegrationRequest) error {
	v.Type = "CHRONICLE"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateChronicleIntegrationRequest performs a merge with any union data inside the UpdateIntegrationRequest, using the provided UpdateChronicleIntegrationRequest
func (t *UpdateIntegrationRequest) MergeUpdateChronicleIntegrationRequest(v UpdateChronicleIntegrationRequest) error {
	v.Type = "CHRONICLE"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateElasticsearchIntegrationRequest returns the union data inside the UpdateIntegrationRequest as a UpdateElasticsearchIntegrationRequest
func (t UpdateIntegrationRequest) AsUpdateElasticsearchIntegrationRequest() (UpdateElasticsearchIntegrationRequest, error) {
	var body UpdateElasticsearchIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateElasticsearchIntegrationRequest overwrites any union data inside the UpdateIntegrationRequest as the provided UpdateElasticsearchIntegrationRequest
func (t *UpdateIntegrationRequest) FromUpdateElasticsearchIntegrationRequest(v UpdateElasticsearchIntegrationRequest) error {
	v.Type = "ELASTIC"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateElasticsearchIntegrationRequest performs a merge with any union data inside the UpdateIntegrationRequest, using the provided UpdateElasticsearchIntegrationRequest
func (t *UpdateIntegrationRequest) MergeUpdateElasticsearchIntegrationRequest(v UpdateElasticsearchIntegrationRequest) error {
	v.Type = "ELASTIC"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateGooglePubSubIntegrationRequest returns the union data inside the UpdateIntegrationRequest as a UpdateGooglePubSubIntegrationRequest
func (t UpdateIntegrationRequest) AsUpdateGooglePubSubIntegrationRequest() (UpdateGooglePubSubIntegrationRequest, error) {
	var body UpdateGooglePubSubIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateGooglePubSubIntegrationRequest overwrites any union data inside the UpdateIntegrationRequest as the provided UpdateGooglePubSubIntegrationRequest
func (t *UpdateIntegrationRequest) FromUpdateGooglePubSubIntegrationRequest(v UpdateGooglePubSubIntegrationRequest) error {
	v.Type = "PUBSUB"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateGooglePubSubIntegrationRequest performs a merge with any union data inside the UpdateIntegrationRequest, using the provided UpdateGooglePubSubIntegrationRequest
func (t *UpdateIntegrationRequest) MergeUpdateGooglePubSubIntegrationRequest(v UpdateGooglePubSubIntegrationRequest) error {
	v.Type = "PUBSUB"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateKafkaIntegrationRequest returns the union data inside the UpdateIntegrationRequest as a UpdateKafkaIntegrationRequest
func (t UpdateIntegrationRequest) AsUpdateKafkaIntegrationRequest() (UpdateKafkaIntegrationRequest, error) {
	var body UpdateKafkaIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateKafkaIntegrationRequest overwrites any union data inside the UpdateIntegrationRequest as the provided UpdateKafkaIntegrationRequest
func (t *UpdateIntegrationRequest) FromUpdateKafkaIntegrationRequest(v UpdateKafkaIntegrationRequest) error {
	v.Type = "KAFKA"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateKafkaIntegrationRequest performs a merge with any union data inside the UpdateIntegrationRequest, using the provided UpdateKafkaIntegrationRequest
func (t *UpdateIntegrationRequest) MergeUpdateKafkaIntegrationRequest(v UpdateKafkaIntegrationRequest) error {
	v.Type = "KAFKA"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateMcmIntegrationRequest returns the union data inside the UpdateIntegrationRequest as a UpdateMcmIntegrationRequest
func (t UpdateIntegrationRequest) AsUpdateMcmIntegrationRequest() (UpdateMcmIntegrationRequest, error) {
	var body UpdateMcmIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateMcmIntegrationRequest overwrites any union data inside the UpdateIntegrationRequest as the provided UpdateMcmIntegrationRequest
func (t *UpdateIntegrationRequest) FromUpdateMcmIntegrationRequest(v UpdateMcmIntegrationRequest) error {
	v.Type = "MCM"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateMcmIntegrationRequest performs a merge with any union data inside the UpdateIntegrationRequest, using the provided UpdateMcmIntegrationRequest
func (t *UpdateIntegrationRequest) MergeUpdateMcmIntegrationRequest(v UpdateMcmIntegrationRequest) error {
	v.Type = "MCM"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateQradarIntegrationRequest returns the union data inside the UpdateIntegrationRequest as a UpdateQradarIntegrationRequest
func (t UpdateIntegrationRequest) AsUpdateQradarIntegrationRequest() (UpdateQradarIntegrationRequest, error) {
	var body UpdateQradarIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateQradarIntegrationRequest overwrites any union data inside the UpdateIntegrationRequest as the provided UpdateQradarIntegrationRequest
func (t *UpdateIntegrationRequest) FromUpdateQradarIntegrationRequest(v UpdateQradarIntegrationRequest) error {
	v.Type = "QRADAR"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateQradarIntegrationRequest performs a merge with any union data inside the UpdateIntegrationRequest, using the provided UpdateQradarIntegrationRequest
func (t *UpdateIntegrationRequest) MergeUpdateQradarIntegrationRequest(v UpdateQradarIntegrationRequest) error {
	v.Type = "QRADAR"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateGoogleSccIntegrationRequest returns the union data inside the UpdateIntegrationRequest as a UpdateGoogleSccIntegrationRequest
func (t UpdateIntegrationRequest) AsUpdateGoogleSccIntegrationRequest() (UpdateGoogleSccIntegrationRequest, error) {
	var body UpdateGoogleSccIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateGoogleSccIntegrationRequest overwrites any union data inside the UpdateIntegrationRequest as the provided UpdateGoogleSccIntegrationRequest
func (t *UpdateIntegrationRequest) FromUpdateGoogleSccIntegrationRequest(v UpdateGoogleSccIntegrationRequest) error {
	v.Type = "SCC"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateGoogleSccIntegrationRequest performs a merge with any union data inside the UpdateIntegrationRequest, using the provided UpdateGoogleSccIntegrationRequest
func (t *UpdateIntegrationRequest) MergeUpdateGoogleSccIntegrationRequest(v UpdateGoogleSccIntegrationRequest) error {
	v.Type = "SCC"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateMicrosoftSentinelIntegrationRequest returns the union data inside the UpdateIntegrationRequest as a UpdateMicrosoftSentinelIntegrationRequest
func (t UpdateIntegrationRequest) AsUpdateMicrosoftSentinelIntegrationRequest() (UpdateMicrosoftSentinelIntegrationRequest, error) {
	var body UpdateMicrosoftSentinelIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateMicrosoftSentinelIntegrationRequest overwrites any union data inside the UpdateIntegrationRequest as the provided UpdateMicrosoftSentinelIntegrationRequest
func (t *UpdateIntegrationRequest) FromUpdateMicrosoftSentinelIntegrationRequest(v UpdateMicrosoftSentinelIntegrationRequest) error {
	v.Type = "SENTINEL"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateMicrosoftSentinelIntegrationRequest performs a merge with any union data inside the UpdateIntegrationRequest, using the provided UpdateMicrosoftSentinelIntegrationRequest
func (t *UpdateIntegrationRequest) MergeUpdateMicrosoftSentinelIntegrationRequest(v UpdateMicrosoftSentinelIntegrationRequest) error {
	v.Type = "SENTINEL"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateSplunkIntegrationRequest returns the union data inside the UpdateIntegrationRequest as a UpdateSplunkIntegrationRequest
func (t UpdateIntegrationRequest) AsUpdateSplunkIntegrationRequest() (UpdateSplunkIntegrationRequest, error) {
	var body UpdateSplunkIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateSplunkIntegrationRequest overwrites any union data inside the UpdateIntegrationRequest as the provided UpdateSplunkIntegrationRequest
func (t *UpdateIntegrationRequest) FromUpdateSplunkIntegrationRequest(v UpdateSplunkIntegrationRequest) error {
	v.Type = "SPLUNK"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateSplunkIntegrationRequest performs a merge with any union data inside the UpdateIntegrationRequest, using the provided UpdateSplunkIntegrationRequest
func (t *UpdateIntegrationRequest) MergeUpdateSplunkIntegrationRequest(v UpdateSplunkIntegrationRequest) error {
	v.Type = "SPLUNK"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateAmazonSqsIntegrationRequest returns the union data inside the UpdateIntegrationRequest as a UpdateAmazonSqsIntegrationRequest
func (t UpdateIntegrationRequest) AsUpdateAmazonSqsIntegrationRequest() (UpdateAmazonSqsIntegrationRequest, error) {
	var body UpdateAmazonSqsIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateAmazonSqsIntegrationRequest overwrites any union data inside the UpdateIntegrationRequest as the provided UpdateAmazonSqsIntegrationRequest
func (t *UpdateIntegrationRequest) FromUpdateAmazonSqsIntegrationRequest(v UpdateAmazonSqsIntegrationRequest) error {
	v.Type = "SQS"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateAmazonSqsIntegrationRequest performs a merge with any union data inside the UpdateIntegrationRequest, using the provided UpdateAmazonSqsIntegrationRequest
func (t *UpdateIntegrationRequest) MergeUpdateAmazonSqsIntegrationRequest(v UpdateAmazonSqsIntegrationRequest) error {
	v.Type = "SQS"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateSyslogIntegrationRequest returns the union data inside the UpdateIntegrationRequest as a UpdateSyslogIntegrationRequest
func (t UpdateIntegrationRequest) AsUpdateSyslogIntegrationRequest() (UpdateSyslogIntegrationRequest, error) {
	var body UpdateSyslogIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateSyslogIntegrationRequest overwrites any union data inside the UpdateIntegrationRequest as the provided UpdateSyslogIntegrationRequest
func (t *UpdateIntegrationRequest) FromUpdateSyslogIntegrationRequest(v UpdateSyslogIntegrationRequest) error {
	v.Type = "SYSLOG"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateSyslogIntegrationRequest performs a merge with any union data inside the UpdateIntegrationRequest, using the provided UpdateSyslogIntegrationRequest
func (t *UpdateIntegrationRequest) MergeUpdateSyslogIntegrationRequest(v UpdateSyslogIntegrationRequest) error {
	v.Type = "SYSLOG"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateWebhookIntegrationRequest returns the union data inside the UpdateIntegrationRequest as a UpdateWebhookIntegrationRequest
func (t UpdateIntegrationRequest) AsUpdateWebhookIntegrationRequest() (UpdateWebhookIntegrationRequest, error) {
	var body UpdateWebhookIntegrationRequest
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateWebhookIntegrationRequest overwrites any union data inside the UpdateIntegrationRequest as the provided UpdateWebhookIntegrationRequest
func (t *UpdateIntegrationRequest) FromUpdateWebhookIntegrationRequest(v UpdateWebhookIntegrationRequest) error {
	v.Type = "WEBHOOK"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateWebhookIntegrationRequest performs a merge with any union data inside the UpdateIntegrationRequest, using the provided UpdateWebhookIntegrationRequest
func (t *UpdateIntegrationRequest) MergeUpdateWebhookIntegrationRequest(v UpdateWebhookIntegrationRequest) error {
	v.Type = "WEBHOOK"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateIntegrationRequest) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t UpdateIntegrationRequest) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "CHRONICLE":
		return t.AsUpdateChronicleIntegrationRequest()
	case "ELASTIC":
		return t.AsUpdateElasticsearchIntegrationRequest()
	case "KAFKA":
		return t.AsUpdateKafkaIntegrationRequest()
	case "MCM":
		return t.AsUpdateMcmIntegrationRequest()
	case "PUBSUB":
		return t.AsUpdateGooglePubSubIntegrationRequest()
	case "QRADAR":
		return t.AsUpdateQradarIntegrationRequest()
	case "SCC":
		return t.AsUpdateGoogleSccIntegrationRequest()
	case "SENTINEL":
		return t.AsUpdateMicrosoftSentinelIntegrationRequest()
	case "SPLUNK":
		return t.AsUpdateSplunkIntegrationRequest()
	case "SQS":
		return t.AsUpdateAmazonSqsIntegrationRequest()
	case "SYSLOG":
		return t.AsUpdateSyslogIntegrationRequest()
	case "WEBHOOK":
		return t.AsUpdateWebhookIntegrationRequest()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t UpdateIntegrationRequest) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateIntegrationRequest) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBaseConnectionInfoKafka returns the union data inside the UpdateKafkaIntegrationRequest_ConnectionInfo as a BaseConnectionInfoKafka
func (t UpdateKafkaIntegrationRequest_ConnectionInfo) AsBaseConnectionInfoKafka() (BaseConnectionInfoKafka, error) {
	var body BaseConnectionInfoKafka
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBaseConnectionInfoKafka overwrites any union data inside the UpdateKafkaIntegrationRequest_ConnectionInfo as the provided BaseConnectionInfoKafka
func (t *UpdateKafkaIntegrationRequest_ConnectionInfo) FromBaseConnectionInfoKafka(v BaseConnectionInfoKafka) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBaseConnectionInfoKafka performs a merge with any union data inside the UpdateKafkaIntegrationRequest_ConnectionInfo, using the provided BaseConnectionInfoKafka
func (t *UpdateKafkaIntegrationRequest_ConnectionInfo) MergeBaseConnectionInfoKafka(v BaseConnectionInfoKafka) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKafkaAuthenticatedPrivateConnectionInfo returns the union data inside the UpdateKafkaIntegrationRequest_ConnectionInfo as a KafkaAuthenticatedPrivateConnectionInfo
func (t UpdateKafkaIntegrationRequest_ConnectionInfo) AsKafkaAuthenticatedPrivateConnectionInfo() (KafkaAuthenticatedPrivateConnectionInfo, error) {
	var body KafkaAuthenticatedPrivateConnectionInfo
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaAuthenticatedPrivateConnectionInfo overwrites any union data inside the UpdateKafkaIntegrationRequest_ConnectionInfo as the provided KafkaAuthenticatedPrivateConnectionInfo
func (t *UpdateKafkaIntegrationRequest_ConnectionInfo) FromKafkaAuthenticatedPrivateConnectionInfo(v KafkaAuthenticatedPrivateConnectionInfo) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaAuthenticatedPrivateConnectionInfo performs a merge with any union data inside the UpdateKafkaIntegrationRequest_ConnectionInfo, using the provided KafkaAuthenticatedPrivateConnectionInfo
func (t *UpdateKafkaIntegrationRequest_ConnectionInfo) MergeKafkaAuthenticatedPrivateConnectionInfo(v KafkaAuthenticatedPrivateConnectionInfo) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateKafkaIntegrationRequest_ConnectionInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateKafkaIntegrationRequest_ConnectionInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsKafkaPlaintextV1 returns the union data inside the UpdateKafkaIntegrationRequestV1_ConnectionInfo as a KafkaPlaintextV1
func (t UpdateKafkaIntegrationRequestV1_ConnectionInfo) AsKafkaPlaintextV1() (KafkaPlaintextV1, error) {
	var body KafkaPlaintextV1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaPlaintextV1 overwrites any union data inside the UpdateKafkaIntegrationRequestV1_ConnectionInfo as the provided KafkaPlaintextV1
func (t *UpdateKafkaIntegrationRequestV1_ConnectionInfo) FromKafkaPlaintextV1(v KafkaPlaintextV1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaPlaintextV1 performs a merge with any union data inside the UpdateKafkaIntegrationRequestV1_ConnectionInfo, using the provided KafkaPlaintextV1
func (t *UpdateKafkaIntegrationRequestV1_ConnectionInfo) MergeKafkaPlaintextV1(v KafkaPlaintextV1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsKafkaTlsEncryptedV1 returns the union data inside the UpdateKafkaIntegrationRequestV1_ConnectionInfo as a KafkaTlsEncryptedV1
func (t UpdateKafkaIntegrationRequestV1_ConnectionInfo) AsKafkaTlsEncryptedV1() (KafkaTlsEncryptedV1, error) {
	var body KafkaTlsEncryptedV1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromKafkaTlsEncryptedV1 overwrites any union data inside the UpdateKafkaIntegrationRequestV1_ConnectionInfo as the provided KafkaTlsEncryptedV1
func (t *UpdateKafkaIntegrationRequestV1_ConnectionInfo) FromKafkaTlsEncryptedV1(v KafkaTlsEncryptedV1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeKafkaTlsEncryptedV1 performs a merge with any union data inside the UpdateKafkaIntegrationRequestV1_ConnectionInfo, using the provided KafkaTlsEncryptedV1
func (t *UpdateKafkaIntegrationRequestV1_ConnectionInfo) MergeKafkaTlsEncryptedV1(v KafkaTlsEncryptedV1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateKafkaIntegrationRequestV1_ConnectionInfo) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if t.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	object["auth"], err = json.Marshal(t.Auth)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'auth': %w", err)
	}

	if t.Balancer != nil {
		object["balancer"], err = json.Marshal(t.Balancer)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'balancer': %w", err)
		}
	}

	object["brokers"], err = json.Marshal(t.Brokers)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'brokers': %w", err)
	}

	if t.Compression != nil {
		object["compression"], err = json.Marshal(t.Compression)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'compression': %w", err)
		}
	}

	if t.Keytab != nil {
		object["keytab"], err = json.Marshal(t.Keytab)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'keytab': %w", err)
		}
	}

	object["krb5"], err = json.Marshal(t.Krb5)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'krb5': %w", err)
	}

	object["principal"], err = json.Marshal(t.Principal)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'principal': %w", err)
	}

	object["realm"], err = json.Marshal(t.Realm)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'realm': %w", err)
	}

	object["service"], err = json.Marshal(t.Service)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'service': %w", err)
	}

	object["topic"], err = json.Marshal(t.Topic)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'topic': %w", err)
	}

	b, err = json.Marshal(object)
	return b, err
}

func (t *UpdateKafkaIntegrationRequestV1_ConnectionInfo) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["auth"]; found {
		err = json.Unmarshal(raw, &t.Auth)
		if err != nil {
			return fmt.Errorf("error reading 'auth': %w", err)
		}
	}

	if raw, found := object["balancer"]; found {
		err = json.Unmarshal(raw, &t.Balancer)
		if err != nil {
			return fmt.Errorf("error reading 'balancer': %w", err)
		}
	}

	if raw, found := object["brokers"]; found {
		err = json.Unmarshal(raw, &t.Brokers)
		if err != nil {
			return fmt.Errorf("error reading 'brokers': %w", err)
		}
	}

	if raw, found := object["compression"]; found {
		err = json.Unmarshal(raw, &t.Compression)
		if err != nil {
			return fmt.Errorf("error reading 'compression': %w", err)
		}
	}

	if raw, found := object["keytab"]; found {
		err = json.Unmarshal(raw, &t.Keytab)
		if err != nil {
			return fmt.Errorf("error reading 'keytab': %w", err)
		}
	}

	if raw, found := object["krb5"]; found {
		err = json.Unmarshal(raw, &t.Krb5)
		if err != nil {
			return fmt.Errorf("error reading 'krb5': %w", err)
		}
	}

	if raw, found := object["principal"]; found {
		err = json.Unmarshal(raw, &t.Principal)
		if err != nil {
			return fmt.Errorf("error reading 'principal': %w", err)
		}
	}

	if raw, found := object["realm"]; found {
		err = json.Unmarshal(raw, &t.Realm)
		if err != nil {
			return fmt.Errorf("error reading 'realm': %w", err)
		}
	}

	if raw, found := object["service"]; found {
		err = json.Unmarshal(raw, &t.Service)
		if err != nil {
			return fmt.Errorf("error reading 'service': %w", err)
		}
	}

	if raw, found := object["topic"]; found {
		err = json.Unmarshal(raw, &t.Topic)
		if err != nil {
			return fmt.Errorf("error reading 'topic': %w", err)
		}
	}

	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// QuerySysqlGet request
	QuerySysqlGet(ctx context.Context, params *QuerySysqlGetParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// QuerySysqlPostWithBody request with any body
	QuerySysqlPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	QuerySysqlPost(ctx context.Context, body QuerySysqlPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSysqlSchema request
	GetSysqlSchema(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInhibitionRules request
	GetInhibitionRules(ctx context.Context, params *GetInhibitionRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateInhibitionRuleWithBody request with any body
	CreateInhibitionRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateInhibitionRule(ctx context.Context, body CreateInhibitionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteInhibitionRuleById request
	DeleteInhibitionRuleById(ctx context.Context, inhibitionRuleId InhibitionRulePath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInhibitionRuleById request
	GetInhibitionRuleById(ctx context.Context, inhibitionRuleId InhibitionRulePath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateInhibitionRuleWithBody request with any body
	UpdateInhibitionRuleWithBody(ctx context.Context, inhibitionRuleId InhibitionRulePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateInhibitionRule(ctx context.Context, inhibitionRuleId InhibitionRulePath, body UpdateInhibitionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPricingV1 request
	GetPricingV1(ctx context.Context, params *GetPricingV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePricingV1WithBody request with any body
	CreatePricingV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePricingV1(ctx context.Context, body CreatePricingV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePricingByIdV1 request
	DeletePricingByIdV1(ctx context.Context, pricingId PricingIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPricingByIdV1 request
	GetPricingByIdV1(ctx context.Context, pricingId PricingIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePricingByIdV1WithBody request with any body
	UpdatePricingByIdV1WithBody(ctx context.Context, pricingId PricingIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePricingByIdV1(ctx context.Context, pricingId PricingIdPath, body UpdatePricingByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPricingProjectedCostsV1 request
	GetPricingProjectedCostsV1(ctx context.Context, pricingId PricingIdPath, params *GetPricingProjectedCostsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWastedWorkloadDataWithBody request with any body
	GetWastedWorkloadDataWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetWastedWorkloadData(ctx context.Context, body GetWastedWorkloadDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkloadCostDataV1WithBody request with any body
	GetWorkloadCostDataV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetWorkloadCostDataV1(ctx context.Context, body GetWorkloadCostDataV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWorkloadRightsizingDataWithBody request with any body
	GetWorkloadRightsizingDataWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetWorkloadRightsizingData(ctx context.Context, body GetWorkloadRightsizingDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMonitorEventsV1 request
	GetMonitorEventsV1(ctx context.Context, params *GetMonitorEventsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDisabledMetricsByJobV1 request
	GetDisabledMetricsByJobV1(ctx context.Context, params *GetDisabledMetricsByJobV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDisabledMetricsV1WithBody request with any body
	PostDisabledMetricsV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDisabledMetricsV1(ctx context.Context, body PostDisabledMetricsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomPrometheusJobsV1 request
	GetCustomPrometheusJobsV1(ctx context.Context, params *GetCustomPrometheusJobsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomPrometheusJobByIdV1 request
	DeleteCustomPrometheusJobByIdV1(ctx context.Context, jobName JobNamePath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomPrometheusJobByNameV1 request
	GetCustomPrometheusJobByNameV1(ctx context.Context, jobName JobNamePath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCustomPrometheusJobV1WithBody request with any body
	CreateCustomPrometheusJobV1WithBody(ctx context.Context, jobName JobNamePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCustomPrometheusJobByIdV1WithBody request with any body
	UpdateCustomPrometheusJobByIdV1WithBody(ctx context.Context, jobName JobNamePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomPrometheusJobEnablementV1 request
	GetCustomPrometheusJobEnablementV1(ctx context.Context, jobName JobNamePath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCustomPrometheusJobEnablementV1WithBody request with any body
	UpdateCustomPrometheusJobEnablementV1WithBody(ctx context.Context, jobName JobNamePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCustomPrometheusJobEnablementV1(ctx context.Context, jobName JobNamePath, body UpdateCustomPrometheusJobEnablementV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJiraIntegrationsV1 request
	GetJiraIntegrationsV1(ctx context.Context, params *GetJiraIntegrationsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateJiraIntegrationV1WithBody request with any body
	CreateJiraIntegrationV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateJiraIntegrationV1(ctx context.Context, body CreateJiraIntegrationV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteJiraIntegrationV1 request
	DeleteJiraIntegrationV1(ctx context.Context, integrationID IntegrationID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJiraIntegrationV1 request
	GetJiraIntegrationV1(ctx context.Context, integrationID IntegrationID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateJiraIntegrationV1WithBody request with any body
	UpdateJiraIntegrationV1WithBody(ctx context.Context, integrationID IntegrationID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateJiraIntegrationV1(ctx context.Context, integrationID IntegrationID, body UpdateJiraIntegrationV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJiraIssueTypesV1 request
	GetJiraIssueTypesV1(ctx context.Context, integrationID IntegrationID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateJiraIssueTypeV1WithBody request with any body
	CreateJiraIssueTypeV1WithBody(ctx context.Context, integrationID IntegrationID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateJiraIssueTypeV1(ctx context.Context, integrationID IntegrationID, body CreateJiraIssueTypeV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteJiraIssueTypeV1 request
	DeleteJiraIssueTypeV1(ctx context.Context, integrationID IntegrationID, issueTypeID IssueTypeID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJiraIssueTypeV1 request
	GetJiraIssueTypeV1(ctx context.Context, integrationID IntegrationID, issueTypeID IssueTypeID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateJiraIssueTypeV1WithBody request with any body
	UpdateJiraIssueTypeV1WithBody(ctx context.Context, integrationID IntegrationID, issueTypeID IssueTypeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateJiraIssueTypeV1(ctx context.Context, integrationID IntegrationID, issueTypeID IssueTypeID, body UpdateJiraIssueTypeV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListJobsV1 request
	ListJobsV1(ctx context.Context, params *ListJobsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSchedulesV1 request
	ListSchedulesV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccessKeysV1 request
	GetAccessKeysV1(ctx context.Context, params *GetAccessKeysV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAccessKeyV1WithBody request with any body
	CreateAccessKeyV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAccessKeyV1(ctx context.Context, body CreateAccessKeyV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAccessKeyByIdV1 request
	DeleteAccessKeyByIdV1(ctx context.Context, accessKeyId AccessKeyIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccessKeyByIdV1 request
	GetAccessKeyByIdV1(ctx context.Context, accessKeyId AccessKeyIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAccessKeyByIdV1WithBody request with any body
	UpdateAccessKeyByIdV1WithBody(ctx context.Context, accessKeyId AccessKeyIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAccessKeyByIdV1(ctx context.Context, accessKeyId AccessKeyIdPath, body UpdateAccessKeyByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCaptureStorageConfigurationV1 request
	GetCaptureStorageConfigurationV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCaptureStorageConfigurationV1WithBody request with any body
	UpdateCaptureStorageConfigurationV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCaptureStorageConfigurationV1(ctx context.Context, body UpdateCaptureStorageConfigurationV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserDeactivationConfigurationV1 request
	GetUserDeactivationConfigurationV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserDeactivationConfigurationByIdV1WithBody request with any body
	UpdateUserDeactivationConfigurationByIdV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserDeactivationConfigurationByIdV1(ctx context.Context, body UpdateUserDeactivationConfigurationByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDefaultRoleByDisplayNameV1 request
	GetDefaultRoleByDisplayNameV1(ctx context.Context, roleDisplayName GetDefaultRoleByDisplayNameV1ParamsRoleDisplayName, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGlobaSsoSettingsV1 request
	GetGlobaSsoSettingsV1(ctx context.Context, ssoProductId GetGlobaSsoSettingsV1ParamsSsoProductId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGlobalSsoSettingsV1WithBody request with any body
	UpdateGlobalSsoSettingsV1WithBody(ctx context.Context, ssoProductId UpdateGlobalSsoSettingsV1ParamsSsoProductId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGlobalSsoSettingsV1(ctx context.Context, ssoProductId UpdateGlobalSsoSettingsV1ParamsSsoProductId, body UpdateGlobalSsoSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupMappingsV1 request
	GetGroupMappingsV1(ctx context.Context, params *GetGroupMappingsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGroupMappingV1WithBody request with any body
	CreateGroupMappingV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGroupMappingV1(ctx context.Context, body CreateGroupMappingV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupMappingSettingsV1 request
	GetGroupMappingSettingsV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveGroupMappingSettingsV1WithBody request with any body
	SaveGroupMappingSettingsV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveGroupMappingSettingsV1(ctx context.Context, body SaveGroupMappingSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroupMappingByIdV1 request
	DeleteGroupMappingByIdV1(ctx context.Context, groupMappingId GroupMappingIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupMappingByIdV1 request
	GetGroupMappingByIdV1(ctx context.Context, groupMappingId GroupMappingIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGroupMappingByIdV1WithBody request with any body
	UpdateGroupMappingByIdV1WithBody(ctx context.Context, groupMappingId GroupMappingIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGroupMappingByIdV1(ctx context.Context, groupMappingId GroupMappingIdPath, body UpdateGroupMappingByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIpFiltersV1 request
	GetIpFiltersV1(ctx context.Context, params *GetIpFiltersV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateIpFilterV1WithBody request with any body
	CreateIpFilterV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateIpFilterV1(ctx context.Context, body CreateIpFilterV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIpFiltersSettingsV1 request
	GetIpFiltersSettingsV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveIpFiltersSettingsV1WithBody request with any body
	SaveIpFiltersSettingsV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveIpFiltersSettingsV1(ctx context.Context, body SaveIpFiltersSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteIpFilterByIdV1 request
	DeleteIpFilterByIdV1(ctx context.Context, ipFilterId IpFilterIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetIpFilterByIdV1 request
	GetIpFilterByIdV1(ctx context.Context, ipFilterId IpFilterIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateIpFilterV1WithBody request with any body
	UpdateIpFilterV1WithBody(ctx context.Context, ipFilterId IpFilterIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateIpFilterV1(ctx context.Context, ipFilterId IpFilterIdPath, body UpdateIpFilterV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotificationChannels request
	GetNotificationChannels(ctx context.Context, params *GetNotificationChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateNotificationChannelWithBody request with any body
	CreateNotificationChannelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateNotificationChannel(ctx context.Context, body CreateNotificationChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteNotificationChannelById request
	DeleteNotificationChannelById(ctx context.Context, notificationChannelID NotificationChannelID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNotificationChannelById request
	GetNotificationChannelById(ctx context.Context, notificationChannelID NotificationChannelID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateNotificationChannelByIdWithBody request with any body
	UpdateNotificationChannelByIdWithBody(ctx context.Context, notificationChannelID NotificationChannelID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateNotificationChannelById(ctx context.Context, notificationChannelID NotificationChannelID, body UpdateNotificationChannelByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPermissionsV1 request
	GetPermissionsV1(ctx context.Context, params *GetPermissionsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlatformAuditEventsV1 request
	GetPlatformAuditEventsV1(ctx context.Context, params *GetPlatformAuditEventsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRolesV1 request
	GetRolesV1(ctx context.Context, params *GetRolesV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRoleV1WithBody request with any body
	CreateRoleV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRoleV1(ctx context.Context, body CreateRoleV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRoleByIdV1 request
	DeleteRoleByIdV1(ctx context.Context, roleId RoleIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRoleByIdV1 request
	GetRoleByIdV1(ctx context.Context, roleId RoleIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRoleByIdV1WithBody request with any body
	UpdateRoleByIdV1WithBody(ctx context.Context, roleId RoleIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRoleByIdV1(ctx context.Context, roleId RoleIdPath, body UpdateRoleByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGlobalServiceAccountsV1 request
	GetGlobalServiceAccountsV1(ctx context.Context, params *GetGlobalServiceAccountsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGlobalServiceAccountV1WithBody request with any body
	CreateGlobalServiceAccountV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGlobalServiceAccountV1(ctx context.Context, body CreateGlobalServiceAccountV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGlobalServiceAccountsNotificationSettingsV1 request
	DeleteGlobalServiceAccountsNotificationSettingsV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGlobalServiceAccountsNotificationSettingsV1 request
	GetGlobalServiceAccountsNotificationSettingsV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGlobalServiceAccountsNotificationSettingsV1WithBody request with any body
	CreateGlobalServiceAccountsNotificationSettingsV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGlobalServiceAccountsNotificationSettingsV1(ctx context.Context, body CreateGlobalServiceAccountsNotificationSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateGlobalServiceAccountsNotificationSettingsV1WithBody request with any body
	UpdateGlobalServiceAccountsNotificationSettingsV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateGlobalServiceAccountsNotificationSettingsV1(ctx context.Context, body UpdateGlobalServiceAccountsNotificationSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGlobalServiceAccountByIdV1 request
	DeleteGlobalServiceAccountByIdV1(ctx context.Context, serviceAccountId ServiceAccountIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGlobalServiceAccountByIdV1 request
	GetGlobalServiceAccountByIdV1(ctx context.Context, serviceAccountId ServiceAccountIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSsoSettingsV1 request
	GetSsoSettingsV1(ctx context.Context, params *GetSsoSettingsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSsoSettingsV1WithBody request with any body
	CreateSsoSettingsV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSsoSettingsV1(ctx context.Context, body CreateSsoSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSsoSettingsByIdV1 request
	DeleteSsoSettingsByIdV1(ctx context.Context, ssoSettingsId SsoSettingsIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSsoSettingsByIdV1 request
	GetSsoSettingsByIdV1(ctx context.Context, ssoSettingsId SsoSettingsIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSsoSettingsByIdV1WithBody request with any body
	UpdateSsoSettingsByIdV1WithBody(ctx context.Context, ssoSettingsId SsoSettingsIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSsoSettingsByIdV1(ctx context.Context, ssoSettingsId SsoSettingsIdPath, body UpdateSsoSettingsByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamsV1 request
	GetTeamsV1(ctx context.Context, params *GetTeamsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTeamV1WithBody request with any body
	CreateTeamV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTeamV1(ctx context.Context, body CreateTeamV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTeamByIdV1 request
	DeleteTeamByIdV1(ctx context.Context, teamId TeamIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamByIdV1 request
	GetTeamByIdV1(ctx context.Context, teamId TeamIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTeamByIdV1WithBody request with any body
	UpdateTeamByIdV1WithBody(ctx context.Context, teamId TeamIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTeamByIdV1(ctx context.Context, teamId TeamIdPath, body UpdateTeamByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamServiceAccountsV1 request
	GetTeamServiceAccountsV1(ctx context.Context, teamId TeamIdPath, params *GetTeamServiceAccountsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTeamServiceAccountV1WithBody request with any body
	CreateTeamServiceAccountV1WithBody(ctx context.Context, teamId TeamIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTeamServiceAccountV1(ctx context.Context, teamId TeamIdPath, body CreateTeamServiceAccountV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteServiceAccountsNotificationSettingsV1 request
	DeleteServiceAccountsNotificationSettingsV1(ctx context.Context, teamId TeamIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetServiceAccountsNotificationSettingsV1 request
	GetServiceAccountsNotificationSettingsV1(ctx context.Context, teamId TeamIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateServiceAccountsNotificationSettingsV1WithBody request with any body
	CreateServiceAccountsNotificationSettingsV1WithBody(ctx context.Context, teamId TeamIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateServiceAccountsNotificationSettingsV1(ctx context.Context, teamId TeamIdPath, body CreateServiceAccountsNotificationSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateServiceAccountsNotificationSettingsV1WithBody request with any body
	UpdateServiceAccountsNotificationSettingsV1WithBody(ctx context.Context, teamId TeamIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateServiceAccountsNotificationSettingsV1(ctx context.Context, teamId TeamIdPath, body UpdateServiceAccountsNotificationSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTeamServiceAccountByIdV1 request
	DeleteTeamServiceAccountByIdV1(ctx context.Context, teamId TeamIdPath, serviceAccountId ServiceAccountIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamServiceAccountByIdV1 request
	GetTeamServiceAccountByIdV1(ctx context.Context, teamId TeamIdPath, serviceAccountId ServiceAccountIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamUsersV1 request
	GetTeamUsersV1(ctx context.Context, teamId TeamIdPath, params *GetTeamUsersV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTeamUserByIdV1 request
	DeleteTeamUserByIdV1(ctx context.Context, teamId TeamIdPath, userId UserIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeamUserByIdV1 request
	GetTeamUserByIdV1(ctx context.Context, teamId TeamIdPath, userId UserIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SaveTeamUserV1WithBody request with any body
	SaveTeamUserV1WithBody(ctx context.Context, teamId TeamIdPath, userId UserIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SaveTeamUserV1(ctx context.Context, teamId TeamIdPath, userId UserIdPath, body SaveTeamUserV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersV1 request
	GetUsersV1(ctx context.Context, params *GetUsersV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUserV1WithBody request with any body
	CreateUserV1WithBody(ctx context.Context, params *CreateUserV1Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUserV1(ctx context.Context, params *CreateUserV1Params, body CreateUserV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserByIdV1 request
	DeleteUserByIdV1(ctx context.Context, userId UserIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserByIdV1 request
	GetUserByIdV1(ctx context.Context, userId UserIdPath, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserV1WithBody request with any body
	UpdateUserV1WithBody(ctx context.Context, userId UserIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserV1(ctx context.Context, userId UserIdPath, body UpdateUserV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListZonesV1 request
	ListZonesV1(ctx context.Context, params *ListZonesV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateZoneV1WithBody request with any body
	CreateZoneV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateZoneV1(ctx context.Context, body CreateZoneV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteZoneV1 request
	DeleteZoneV1(ctx context.Context, zoneId ZoneId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetZoneByIdV1 request
	GetZoneByIdV1(ctx context.Context, zoneId ZoneId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditZoneV1WithBody request with any body
	EditZoneV1WithBody(ctx context.Context, zoneId ZoneId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditZoneV1(ctx context.Context, zoneId ZoneId, body EditZoneV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActivityAuditEntriesV1 request
	GetActivityAuditEntriesV1(ctx context.Context, params *GetActivityAuditEntriesV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActivityAuditEntryV1 request
	GetActivityAuditEntryV1(ctx context.Context, entryId EntryId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActivityAuditEntriesSupportedFiltersV1 request
	GetActivityAuditEntriesSupportedFiltersV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCertificatesV1 request
	GetCertificatesV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadCertificateV1WithBody request with any body
	UploadCertificateV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCertificateV1 request
	DeleteCertificateV1(ctx context.Context, certId PathCertificateId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCertificateV1 request
	GetCertificateV1(ctx context.Context, certId PathCertificateId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCertificateRegistrationV1 request
	GetCertificateRegistrationV1(ctx context.Context, certId PathCertificateId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCSRV1 request
	CreateCSRV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEFOChannelsByIntegrationV1 request
	ListEFOChannelsByIntegrationV1(ctx context.Context, params *ListEFOChannelsByIntegrationV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEFOIntegrationsV1 request
	ListEFOIntegrationsV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEFOIntegrationV1WithBody request with any body
	CreateEFOIntegrationV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEFOIntegrationV1(ctx context.Context, body CreateEFOIntegrationV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEFOIntegrationByIdV1 request
	DeleteEFOIntegrationByIdV1(ctx context.Context, integrationId IntegrationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEFOIntegrationByIdV1 request
	GetEFOIntegrationByIdV1(ctx context.Context, integrationId IntegrationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEFOIntegrationByIdV1WithBody request with any body
	UpdateEFOIntegrationByIdV1WithBody(ctx context.Context, integrationId IntegrationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEFOIntegrationByIdV1(ctx context.Context, integrationId IntegrationId, body UpdateEFOIntegrationByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEFOIntegrationsTypesV1 request
	ListEFOIntegrationsTypesV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEFOChannelsByIntegrationV2 request
	ListEFOChannelsByIntegrationV2(ctx context.Context, params *ListEFOChannelsByIntegrationV2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEFOIntegrationsV2 request
	ListEFOIntegrationsV2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateEFOIntegrationV2WithBody request with any body
	CreateEFOIntegrationV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateEFOIntegrationV2(ctx context.Context, body CreateEFOIntegrationV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteEFOIntegrationByIdV2 request
	DeleteEFOIntegrationByIdV2(ctx context.Context, integrationId IntegrationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEFOIntegrationByIdV2 request
	GetEFOIntegrationByIdV2(ctx context.Context, integrationId IntegrationId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEFOIntegrationByIdV2WithBody request with any body
	UpdateEFOIntegrationByIdV2WithBody(ctx context.Context, integrationId IntegrationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEFOIntegrationByIdV2(ctx context.Context, integrationId IntegrationId, body UpdateEFOIntegrationByIdV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListEFOIntegrationsTypesV2 request
	ListEFOIntegrationsTypesV2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEventsV1 request
	GetEventsV1(ctx context.Context, params *GetEventsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEventV1 request
	GetEventV1(ctx context.Context, eventId EventId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEventsSupportedFiltersV1 request
	GetEventsSupportedFiltersV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResources request
	GetResources(ctx context.Context, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResource request
	GetResource(ctx context.Context, hash string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActionExecutionsv1 request
	GetActionExecutionsv1(ctx context.Context, params *GetActionExecutionsv1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SubmitActionExecutionv1WithBody request with any body
	SubmitActionExecutionv1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SubmitActionExecutionv1(ctx context.Context, body SubmitActionExecutionv1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UndoActionExecutionV1 request
	UndoActionExecutionV1(ctx context.Context, actionExecutionId ActionExecutionId, params *UndoActionExecutionV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActionExecutionV1 request
	GetActionExecutionV1(ctx context.Context, actionExecutionId ActionExecutionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActionExecutionFileAcquireV1 request
	GetActionExecutionFileAcquireV1(ctx context.Context, actionExecutionId ActionExecutionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActionsV1 request
	GetActionsV1(ctx context.Context, params *GetActionsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSecureVulnerabilityV1Bundles request
	GetSecureVulnerabilityV1Bundles(ctx context.Context, params *GetSecureVulnerabilityV1BundlesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSecureVulnerabilityV1BundlesWithBody request with any body
	PostSecureVulnerabilityV1BundlesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSecureVulnerabilityV1Bundles(ctx context.Context, body PostSecureVulnerabilityV1BundlesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSecureVulnerabilityV1BundlesBundleId request
	DeleteSecureVulnerabilityV1BundlesBundleId(ctx context.Context, bundleId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSecureVulnerabilityV1BundlesBundleId request
	GetSecureVulnerabilityV1BundlesBundleId(ctx context.Context, bundleId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutSecureVulnerabilityV1BundlesBundleIdWithBody request with any body
	PutSecureVulnerabilityV1BundlesBundleIdWithBody(ctx context.Context, bundleId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutSecureVulnerabilityV1BundlesBundleId(ctx context.Context, bundleId int64, body PutSecureVulnerabilityV1BundlesBundleIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSecureVulnerabilityV1PipelineResults request
	GetSecureVulnerabilityV1PipelineResults(ctx context.Context, params *GetSecureVulnerabilityV1PipelineResultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSecureVulnerabilityV1Policies request
	GetSecureVulnerabilityV1Policies(ctx context.Context, params *GetSecureVulnerabilityV1PoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSecureVulnerabilityV1PoliciesWithBody request with any body
	PostSecureVulnerabilityV1PoliciesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSecureVulnerabilityV1Policies(ctx context.Context, body PostSecureVulnerabilityV1PoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSecureVulnerabilityV1PoliciesPolicyId request
	DeleteSecureVulnerabilityV1PoliciesPolicyId(ctx context.Context, policyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSecureVulnerabilityV1PoliciesPolicyId request
	GetSecureVulnerabilityV1PoliciesPolicyId(ctx context.Context, policyId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutSecureVulnerabilityV1PoliciesPolicyIdWithBody request with any body
	PutSecureVulnerabilityV1PoliciesPolicyIdWithBody(ctx context.Context, policyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutSecureVulnerabilityV1PoliciesPolicyId(ctx context.Context, policyId int64, body PutSecureVulnerabilityV1PoliciesPolicyIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScannerAPIServiceListRegistryResults request
	ScannerAPIServiceListRegistryResults(ctx context.Context, params *ScannerAPIServiceListRegistryResultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSecureVulnerabilityV1ResultsResultId request
	GetSecureVulnerabilityV1ResultsResultId(ctx context.Context, resultId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ScannerAPIServiceListRuntimeResults request
	ScannerAPIServiceListRuntimeResults(ctx context.Context, params *ScannerAPIServiceListRuntimeResultsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAcceptedRisksV1 request
	GetAcceptedRisksV1(ctx context.Context, params *GetAcceptedRisksV1Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAcceptedRiskV1WithBody request with any body
	PostAcceptedRiskV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAcceptedRiskV1(ctx context.Context, body PostAcceptedRiskV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAcceptedRiskV1 request
	DeleteAcceptedRiskV1(ctx context.Context, acceptedRiskID AcceptedRiskID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAcceptedRiskV1 request
	GetAcceptedRiskV1(ctx context.Context, acceptedRiskID AcceptedRiskID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAcceptedRiskV1WithBody request with any body
	UpdateAcceptedRiskV1WithBody(ctx context.Context, acceptedRiskID AcceptedRiskID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAcceptedRiskV1(ctx context.Context, acceptedRiskID AcceptedRiskID, body UpdateAcceptedRiskV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSBOMV1beta1 request
	GetSBOMV1beta1(ctx context.Context, params *GetSBOMV1beta1Params, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) QuerySysqlGet(ctx context.Context, params *QuerySysqlGetParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQuerySysqlGetRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QuerySysqlPostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQuerySysqlPostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) QuerySysqlPost(ctx context.Context, body QuerySysqlPostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewQuerySysqlPostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSysqlSchema(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSysqlSchemaRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInhibitionRules(ctx context.Context, params *GetInhibitionRulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInhibitionRulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInhibitionRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInhibitionRuleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateInhibitionRule(ctx context.Context, body CreateInhibitionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateInhibitionRuleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteInhibitionRuleById(ctx context.Context, inhibitionRuleId InhibitionRulePath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteInhibitionRuleByIdRequest(c.Server, inhibitionRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInhibitionRuleById(ctx context.Context, inhibitionRuleId InhibitionRulePath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInhibitionRuleByIdRequest(c.Server, inhibitionRuleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInhibitionRuleWithBody(ctx context.Context, inhibitionRuleId InhibitionRulePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInhibitionRuleRequestWithBody(c.Server, inhibitionRuleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateInhibitionRule(ctx context.Context, inhibitionRuleId InhibitionRulePath, body UpdateInhibitionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateInhibitionRuleRequest(c.Server, inhibitionRuleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPricingV1(ctx context.Context, params *GetPricingV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPricingV1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePricingV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePricingV1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePricingV1(ctx context.Context, body CreatePricingV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePricingV1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePricingByIdV1(ctx context.Context, pricingId PricingIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePricingByIdV1Request(c.Server, pricingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPricingByIdV1(ctx context.Context, pricingId PricingIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPricingByIdV1Request(c.Server, pricingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePricingByIdV1WithBody(ctx context.Context, pricingId PricingIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePricingByIdV1RequestWithBody(c.Server, pricingId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePricingByIdV1(ctx context.Context, pricingId PricingIdPath, body UpdatePricingByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePricingByIdV1Request(c.Server, pricingId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPricingProjectedCostsV1(ctx context.Context, pricingId PricingIdPath, params *GetPricingProjectedCostsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPricingProjectedCostsV1Request(c.Server, pricingId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWastedWorkloadDataWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWastedWorkloadDataRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWastedWorkloadData(ctx context.Context, body GetWastedWorkloadDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWastedWorkloadDataRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkloadCostDataV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkloadCostDataV1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkloadCostDataV1(ctx context.Context, body GetWorkloadCostDataV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkloadCostDataV1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkloadRightsizingDataWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkloadRightsizingDataRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWorkloadRightsizingData(ctx context.Context, body GetWorkloadRightsizingDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWorkloadRightsizingDataRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMonitorEventsV1(ctx context.Context, params *GetMonitorEventsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMonitorEventsV1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDisabledMetricsByJobV1(ctx context.Context, params *GetDisabledMetricsByJobV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDisabledMetricsByJobV1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDisabledMetricsV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDisabledMetricsV1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDisabledMetricsV1(ctx context.Context, body PostDisabledMetricsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDisabledMetricsV1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomPrometheusJobsV1(ctx context.Context, params *GetCustomPrometheusJobsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomPrometheusJobsV1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomPrometheusJobByIdV1(ctx context.Context, jobName JobNamePath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomPrometheusJobByIdV1Request(c.Server, jobName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomPrometheusJobByNameV1(ctx context.Context, jobName JobNamePath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomPrometheusJobByNameV1Request(c.Server, jobName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomPrometheusJobV1WithBody(ctx context.Context, jobName JobNamePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomPrometheusJobV1RequestWithBody(c.Server, jobName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomPrometheusJobByIdV1WithBody(ctx context.Context, jobName JobNamePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomPrometheusJobByIdV1RequestWithBody(c.Server, jobName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomPrometheusJobEnablementV1(ctx context.Context, jobName JobNamePath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomPrometheusJobEnablementV1Request(c.Server, jobName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomPrometheusJobEnablementV1WithBody(ctx context.Context, jobName JobNamePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomPrometheusJobEnablementV1RequestWithBody(c.Server, jobName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomPrometheusJobEnablementV1(ctx context.Context, jobName JobNamePath, body UpdateCustomPrometheusJobEnablementV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomPrometheusJobEnablementV1Request(c.Server, jobName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJiraIntegrationsV1(ctx context.Context, params *GetJiraIntegrationsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJiraIntegrationsV1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJiraIntegrationV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJiraIntegrationV1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJiraIntegrationV1(ctx context.Context, body CreateJiraIntegrationV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJiraIntegrationV1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteJiraIntegrationV1(ctx context.Context, integrationID IntegrationID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteJiraIntegrationV1Request(c.Server, integrationID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJiraIntegrationV1(ctx context.Context, integrationID IntegrationID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJiraIntegrationV1Request(c.Server, integrationID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateJiraIntegrationV1WithBody(ctx context.Context, integrationID IntegrationID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateJiraIntegrationV1RequestWithBody(c.Server, integrationID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateJiraIntegrationV1(ctx context.Context, integrationID IntegrationID, body UpdateJiraIntegrationV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateJiraIntegrationV1Request(c.Server, integrationID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJiraIssueTypesV1(ctx context.Context, integrationID IntegrationID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJiraIssueTypesV1Request(c.Server, integrationID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJiraIssueTypeV1WithBody(ctx context.Context, integrationID IntegrationID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJiraIssueTypeV1RequestWithBody(c.Server, integrationID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateJiraIssueTypeV1(ctx context.Context, integrationID IntegrationID, body CreateJiraIssueTypeV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateJiraIssueTypeV1Request(c.Server, integrationID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteJiraIssueTypeV1(ctx context.Context, integrationID IntegrationID, issueTypeID IssueTypeID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteJiraIssueTypeV1Request(c.Server, integrationID, issueTypeID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJiraIssueTypeV1(ctx context.Context, integrationID IntegrationID, issueTypeID IssueTypeID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJiraIssueTypeV1Request(c.Server, integrationID, issueTypeID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateJiraIssueTypeV1WithBody(ctx context.Context, integrationID IntegrationID, issueTypeID IssueTypeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateJiraIssueTypeV1RequestWithBody(c.Server, integrationID, issueTypeID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateJiraIssueTypeV1(ctx context.Context, integrationID IntegrationID, issueTypeID IssueTypeID, body UpdateJiraIssueTypeV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateJiraIssueTypeV1Request(c.Server, integrationID, issueTypeID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListJobsV1(ctx context.Context, params *ListJobsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJobsV1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSchedulesV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSchedulesV1Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccessKeysV1(ctx context.Context, params *GetAccessKeysV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccessKeysV1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccessKeyV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccessKeyV1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccessKeyV1(ctx context.Context, body CreateAccessKeyV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccessKeyV1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAccessKeyByIdV1(ctx context.Context, accessKeyId AccessKeyIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAccessKeyByIdV1Request(c.Server, accessKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccessKeyByIdV1(ctx context.Context, accessKeyId AccessKeyIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccessKeyByIdV1Request(c.Server, accessKeyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccessKeyByIdV1WithBody(ctx context.Context, accessKeyId AccessKeyIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccessKeyByIdV1RequestWithBody(c.Server, accessKeyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAccessKeyByIdV1(ctx context.Context, accessKeyId AccessKeyIdPath, body UpdateAccessKeyByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAccessKeyByIdV1Request(c.Server, accessKeyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCaptureStorageConfigurationV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCaptureStorageConfigurationV1Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCaptureStorageConfigurationV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCaptureStorageConfigurationV1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCaptureStorageConfigurationV1(ctx context.Context, body UpdateCaptureStorageConfigurationV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCaptureStorageConfigurationV1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserDeactivationConfigurationV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserDeactivationConfigurationV1Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserDeactivationConfigurationByIdV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserDeactivationConfigurationByIdV1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserDeactivationConfigurationByIdV1(ctx context.Context, body UpdateUserDeactivationConfigurationByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserDeactivationConfigurationByIdV1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDefaultRoleByDisplayNameV1(ctx context.Context, roleDisplayName GetDefaultRoleByDisplayNameV1ParamsRoleDisplayName, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDefaultRoleByDisplayNameV1Request(c.Server, roleDisplayName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGlobaSsoSettingsV1(ctx context.Context, ssoProductId GetGlobaSsoSettingsV1ParamsSsoProductId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGlobaSsoSettingsV1Request(c.Server, ssoProductId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGlobalSsoSettingsV1WithBody(ctx context.Context, ssoProductId UpdateGlobalSsoSettingsV1ParamsSsoProductId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGlobalSsoSettingsV1RequestWithBody(c.Server, ssoProductId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGlobalSsoSettingsV1(ctx context.Context, ssoProductId UpdateGlobalSsoSettingsV1ParamsSsoProductId, body UpdateGlobalSsoSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGlobalSsoSettingsV1Request(c.Server, ssoProductId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupMappingsV1(ctx context.Context, params *GetGroupMappingsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupMappingsV1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupMappingV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupMappingV1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGroupMappingV1(ctx context.Context, body CreateGroupMappingV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGroupMappingV1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupMappingSettingsV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupMappingSettingsV1Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveGroupMappingSettingsV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveGroupMappingSettingsV1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveGroupMappingSettingsV1(ctx context.Context, body SaveGroupMappingSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveGroupMappingSettingsV1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupMappingByIdV1(ctx context.Context, groupMappingId GroupMappingIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupMappingByIdV1Request(c.Server, groupMappingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupMappingByIdV1(ctx context.Context, groupMappingId GroupMappingIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupMappingByIdV1Request(c.Server, groupMappingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroupMappingByIdV1WithBody(ctx context.Context, groupMappingId GroupMappingIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupMappingByIdV1RequestWithBody(c.Server, groupMappingId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGroupMappingByIdV1(ctx context.Context, groupMappingId GroupMappingIdPath, body UpdateGroupMappingByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGroupMappingByIdV1Request(c.Server, groupMappingId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIpFiltersV1(ctx context.Context, params *GetIpFiltersV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIpFiltersV1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIpFilterV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIpFilterV1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateIpFilterV1(ctx context.Context, body CreateIpFilterV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateIpFilterV1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIpFiltersSettingsV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIpFiltersSettingsV1Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveIpFiltersSettingsV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveIpFiltersSettingsV1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveIpFiltersSettingsV1(ctx context.Context, body SaveIpFiltersSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveIpFiltersSettingsV1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteIpFilterByIdV1(ctx context.Context, ipFilterId IpFilterIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteIpFilterByIdV1Request(c.Server, ipFilterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetIpFilterByIdV1(ctx context.Context, ipFilterId IpFilterIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetIpFilterByIdV1Request(c.Server, ipFilterId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIpFilterV1WithBody(ctx context.Context, ipFilterId IpFilterIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIpFilterV1RequestWithBody(c.Server, ipFilterId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateIpFilterV1(ctx context.Context, ipFilterId IpFilterIdPath, body UpdateIpFilterV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateIpFilterV1Request(c.Server, ipFilterId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotificationChannels(ctx context.Context, params *GetNotificationChannelsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationChannelsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNotificationChannelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNotificationChannelRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateNotificationChannel(ctx context.Context, body CreateNotificationChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateNotificationChannelRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteNotificationChannelById(ctx context.Context, notificationChannelID NotificationChannelID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteNotificationChannelByIdRequest(c.Server, notificationChannelID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNotificationChannelById(ctx context.Context, notificationChannelID NotificationChannelID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNotificationChannelByIdRequest(c.Server, notificationChannelID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNotificationChannelByIdWithBody(ctx context.Context, notificationChannelID NotificationChannelID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNotificationChannelByIdRequestWithBody(c.Server, notificationChannelID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateNotificationChannelById(ctx context.Context, notificationChannelID NotificationChannelID, body UpdateNotificationChannelByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateNotificationChannelByIdRequest(c.Server, notificationChannelID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPermissionsV1(ctx context.Context, params *GetPermissionsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPermissionsV1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlatformAuditEventsV1(ctx context.Context, params *GetPlatformAuditEventsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlatformAuditEventsV1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRolesV1(ctx context.Context, params *GetRolesV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRolesV1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoleV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleV1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRoleV1(ctx context.Context, body CreateRoleV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRoleV1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRoleByIdV1(ctx context.Context, roleId RoleIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRoleByIdV1Request(c.Server, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRoleByIdV1(ctx context.Context, roleId RoleIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRoleByIdV1Request(c.Server, roleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoleByIdV1WithBody(ctx context.Context, roleId RoleIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleByIdV1RequestWithBody(c.Server, roleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRoleByIdV1(ctx context.Context, roleId RoleIdPath, body UpdateRoleByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRoleByIdV1Request(c.Server, roleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGlobalServiceAccountsV1(ctx context.Context, params *GetGlobalServiceAccountsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGlobalServiceAccountsV1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGlobalServiceAccountV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGlobalServiceAccountV1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGlobalServiceAccountV1(ctx context.Context, body CreateGlobalServiceAccountV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGlobalServiceAccountV1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGlobalServiceAccountsNotificationSettingsV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGlobalServiceAccountsNotificationSettingsV1Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGlobalServiceAccountsNotificationSettingsV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGlobalServiceAccountsNotificationSettingsV1Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGlobalServiceAccountsNotificationSettingsV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGlobalServiceAccountsNotificationSettingsV1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGlobalServiceAccountsNotificationSettingsV1(ctx context.Context, body CreateGlobalServiceAccountsNotificationSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGlobalServiceAccountsNotificationSettingsV1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGlobalServiceAccountsNotificationSettingsV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGlobalServiceAccountsNotificationSettingsV1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateGlobalServiceAccountsNotificationSettingsV1(ctx context.Context, body UpdateGlobalServiceAccountsNotificationSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateGlobalServiceAccountsNotificationSettingsV1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGlobalServiceAccountByIdV1(ctx context.Context, serviceAccountId ServiceAccountIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGlobalServiceAccountByIdV1Request(c.Server, serviceAccountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGlobalServiceAccountByIdV1(ctx context.Context, serviceAccountId ServiceAccountIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGlobalServiceAccountByIdV1Request(c.Server, serviceAccountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSsoSettingsV1(ctx context.Context, params *GetSsoSettingsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSsoSettingsV1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSsoSettingsV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSsoSettingsV1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSsoSettingsV1(ctx context.Context, body CreateSsoSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSsoSettingsV1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSsoSettingsByIdV1(ctx context.Context, ssoSettingsId SsoSettingsIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSsoSettingsByIdV1Request(c.Server, ssoSettingsId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSsoSettingsByIdV1(ctx context.Context, ssoSettingsId SsoSettingsIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSsoSettingsByIdV1Request(c.Server, ssoSettingsId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSsoSettingsByIdV1WithBody(ctx context.Context, ssoSettingsId SsoSettingsIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSsoSettingsByIdV1RequestWithBody(c.Server, ssoSettingsId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSsoSettingsByIdV1(ctx context.Context, ssoSettingsId SsoSettingsIdPath, body UpdateSsoSettingsByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSsoSettingsByIdV1Request(c.Server, ssoSettingsId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamsV1(ctx context.Context, params *GetTeamsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamsV1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTeamV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTeamV1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTeamV1(ctx context.Context, body CreateTeamV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTeamV1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTeamByIdV1(ctx context.Context, teamId TeamIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTeamByIdV1Request(c.Server, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamByIdV1(ctx context.Context, teamId TeamIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamByIdV1Request(c.Server, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTeamByIdV1WithBody(ctx context.Context, teamId TeamIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTeamByIdV1RequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTeamByIdV1(ctx context.Context, teamId TeamIdPath, body UpdateTeamByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTeamByIdV1Request(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamServiceAccountsV1(ctx context.Context, teamId TeamIdPath, params *GetTeamServiceAccountsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamServiceAccountsV1Request(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTeamServiceAccountV1WithBody(ctx context.Context, teamId TeamIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTeamServiceAccountV1RequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTeamServiceAccountV1(ctx context.Context, teamId TeamIdPath, body CreateTeamServiceAccountV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTeamServiceAccountV1Request(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteServiceAccountsNotificationSettingsV1(ctx context.Context, teamId TeamIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteServiceAccountsNotificationSettingsV1Request(c.Server, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetServiceAccountsNotificationSettingsV1(ctx context.Context, teamId TeamIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetServiceAccountsNotificationSettingsV1Request(c.Server, teamId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceAccountsNotificationSettingsV1WithBody(ctx context.Context, teamId TeamIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceAccountsNotificationSettingsV1RequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateServiceAccountsNotificationSettingsV1(ctx context.Context, teamId TeamIdPath, body CreateServiceAccountsNotificationSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateServiceAccountsNotificationSettingsV1Request(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceAccountsNotificationSettingsV1WithBody(ctx context.Context, teamId TeamIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceAccountsNotificationSettingsV1RequestWithBody(c.Server, teamId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateServiceAccountsNotificationSettingsV1(ctx context.Context, teamId TeamIdPath, body UpdateServiceAccountsNotificationSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateServiceAccountsNotificationSettingsV1Request(c.Server, teamId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTeamServiceAccountByIdV1(ctx context.Context, teamId TeamIdPath, serviceAccountId ServiceAccountIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTeamServiceAccountByIdV1Request(c.Server, teamId, serviceAccountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamServiceAccountByIdV1(ctx context.Context, teamId TeamIdPath, serviceAccountId ServiceAccountIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamServiceAccountByIdV1Request(c.Server, teamId, serviceAccountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamUsersV1(ctx context.Context, teamId TeamIdPath, params *GetTeamUsersV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamUsersV1Request(c.Server, teamId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTeamUserByIdV1(ctx context.Context, teamId TeamIdPath, userId UserIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTeamUserByIdV1Request(c.Server, teamId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeamUserByIdV1(ctx context.Context, teamId TeamIdPath, userId UserIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeamUserByIdV1Request(c.Server, teamId, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveTeamUserV1WithBody(ctx context.Context, teamId TeamIdPath, userId UserIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveTeamUserV1RequestWithBody(c.Server, teamId, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SaveTeamUserV1(ctx context.Context, teamId TeamIdPath, userId UserIdPath, body SaveTeamUserV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSaveTeamUserV1Request(c.Server, teamId, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersV1(ctx context.Context, params *GetUsersV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersV1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserV1WithBody(ctx context.Context, params *CreateUserV1Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserV1RequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUserV1(ctx context.Context, params *CreateUserV1Params, body CreateUserV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUserV1Request(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserByIdV1(ctx context.Context, userId UserIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserByIdV1Request(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserByIdV1(ctx context.Context, userId UserIdPath, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserByIdV1Request(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserV1WithBody(ctx context.Context, userId UserIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserV1RequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserV1(ctx context.Context, userId UserIdPath, body UpdateUserV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserV1Request(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListZonesV1(ctx context.Context, params *ListZonesV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListZonesV1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateZoneV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateZoneV1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateZoneV1(ctx context.Context, body CreateZoneV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateZoneV1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteZoneV1(ctx context.Context, zoneId ZoneId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteZoneV1Request(c.Server, zoneId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetZoneByIdV1(ctx context.Context, zoneId ZoneId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetZoneByIdV1Request(c.Server, zoneId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditZoneV1WithBody(ctx context.Context, zoneId ZoneId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditZoneV1RequestWithBody(c.Server, zoneId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditZoneV1(ctx context.Context, zoneId ZoneId, body EditZoneV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditZoneV1Request(c.Server, zoneId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActivityAuditEntriesV1(ctx context.Context, params *GetActivityAuditEntriesV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivityAuditEntriesV1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActivityAuditEntryV1(ctx context.Context, entryId EntryId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivityAuditEntryV1Request(c.Server, entryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActivityAuditEntriesSupportedFiltersV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActivityAuditEntriesSupportedFiltersV1Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCertificatesV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCertificatesV1Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadCertificateV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadCertificateV1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCertificateV1(ctx context.Context, certId PathCertificateId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCertificateV1Request(c.Server, certId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCertificateV1(ctx context.Context, certId PathCertificateId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCertificateV1Request(c.Server, certId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCertificateRegistrationV1(ctx context.Context, certId PathCertificateId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCertificateRegistrationV1Request(c.Server, certId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCSRV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCSRV1Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEFOChannelsByIntegrationV1(ctx context.Context, params *ListEFOChannelsByIntegrationV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEFOChannelsByIntegrationV1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEFOIntegrationsV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEFOIntegrationsV1Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEFOIntegrationV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEFOIntegrationV1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEFOIntegrationV1(ctx context.Context, body CreateEFOIntegrationV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEFOIntegrationV1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEFOIntegrationByIdV1(ctx context.Context, integrationId IntegrationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEFOIntegrationByIdV1Request(c.Server, integrationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEFOIntegrationByIdV1(ctx context.Context, integrationId IntegrationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEFOIntegrationByIdV1Request(c.Server, integrationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEFOIntegrationByIdV1WithBody(ctx context.Context, integrationId IntegrationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEFOIntegrationByIdV1RequestWithBody(c.Server, integrationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEFOIntegrationByIdV1(ctx context.Context, integrationId IntegrationId, body UpdateEFOIntegrationByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEFOIntegrationByIdV1Request(c.Server, integrationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEFOIntegrationsTypesV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEFOIntegrationsTypesV1Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEFOChannelsByIntegrationV2(ctx context.Context, params *ListEFOChannelsByIntegrationV2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEFOChannelsByIntegrationV2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEFOIntegrationsV2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEFOIntegrationsV2Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEFOIntegrationV2WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEFOIntegrationV2RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateEFOIntegrationV2(ctx context.Context, body CreateEFOIntegrationV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateEFOIntegrationV2Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteEFOIntegrationByIdV2(ctx context.Context, integrationId IntegrationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteEFOIntegrationByIdV2Request(c.Server, integrationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEFOIntegrationByIdV2(ctx context.Context, integrationId IntegrationId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEFOIntegrationByIdV2Request(c.Server, integrationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEFOIntegrationByIdV2WithBody(ctx context.Context, integrationId IntegrationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEFOIntegrationByIdV2RequestWithBody(c.Server, integrationId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEFOIntegrationByIdV2(ctx context.Context, integrationId IntegrationId, body UpdateEFOIntegrationByIdV2JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEFOIntegrationByIdV2Request(c.Server, integrationId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListEFOIntegrationsTypesV2(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListEFOIntegrationsTypesV2Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEventsV1(ctx context.Context, params *GetEventsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventsV1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEventV1(ctx context.Context, eventId EventId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventV1Request(c.Server, eventId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEventsSupportedFiltersV1(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventsSupportedFiltersV1Request(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResources(ctx context.Context, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourcesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResource(ctx context.Context, hash string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResourceRequest(c.Server, hash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActionExecutionsv1(ctx context.Context, params *GetActionExecutionsv1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActionExecutionsv1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitActionExecutionv1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitActionExecutionv1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SubmitActionExecutionv1(ctx context.Context, body SubmitActionExecutionv1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSubmitActionExecutionv1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UndoActionExecutionV1(ctx context.Context, actionExecutionId ActionExecutionId, params *UndoActionExecutionV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUndoActionExecutionV1Request(c.Server, actionExecutionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActionExecutionV1(ctx context.Context, actionExecutionId ActionExecutionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActionExecutionV1Request(c.Server, actionExecutionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActionExecutionFileAcquireV1(ctx context.Context, actionExecutionId ActionExecutionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActionExecutionFileAcquireV1Request(c.Server, actionExecutionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActionsV1(ctx context.Context, params *GetActionsV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActionsV1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSecureVulnerabilityV1Bundles(ctx context.Context, params *GetSecureVulnerabilityV1BundlesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSecureVulnerabilityV1BundlesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSecureVulnerabilityV1BundlesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSecureVulnerabilityV1BundlesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSecureVulnerabilityV1Bundles(ctx context.Context, body PostSecureVulnerabilityV1BundlesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSecureVulnerabilityV1BundlesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSecureVulnerabilityV1BundlesBundleId(ctx context.Context, bundleId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSecureVulnerabilityV1BundlesBundleIdRequest(c.Server, bundleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSecureVulnerabilityV1BundlesBundleId(ctx context.Context, bundleId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSecureVulnerabilityV1BundlesBundleIdRequest(c.Server, bundleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutSecureVulnerabilityV1BundlesBundleIdWithBody(ctx context.Context, bundleId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutSecureVulnerabilityV1BundlesBundleIdRequestWithBody(c.Server, bundleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutSecureVulnerabilityV1BundlesBundleId(ctx context.Context, bundleId int64, body PutSecureVulnerabilityV1BundlesBundleIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutSecureVulnerabilityV1BundlesBundleIdRequest(c.Server, bundleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSecureVulnerabilityV1PipelineResults(ctx context.Context, params *GetSecureVulnerabilityV1PipelineResultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSecureVulnerabilityV1PipelineResultsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSecureVulnerabilityV1Policies(ctx context.Context, params *GetSecureVulnerabilityV1PoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSecureVulnerabilityV1PoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSecureVulnerabilityV1PoliciesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSecureVulnerabilityV1PoliciesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSecureVulnerabilityV1Policies(ctx context.Context, body PostSecureVulnerabilityV1PoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSecureVulnerabilityV1PoliciesRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSecureVulnerabilityV1PoliciesPolicyId(ctx context.Context, policyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSecureVulnerabilityV1PoliciesPolicyIdRequest(c.Server, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSecureVulnerabilityV1PoliciesPolicyId(ctx context.Context, policyId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSecureVulnerabilityV1PoliciesPolicyIdRequest(c.Server, policyId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutSecureVulnerabilityV1PoliciesPolicyIdWithBody(ctx context.Context, policyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutSecureVulnerabilityV1PoliciesPolicyIdRequestWithBody(c.Server, policyId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutSecureVulnerabilityV1PoliciesPolicyId(ctx context.Context, policyId int64, body PutSecureVulnerabilityV1PoliciesPolicyIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutSecureVulnerabilityV1PoliciesPolicyIdRequest(c.Server, policyId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScannerAPIServiceListRegistryResults(ctx context.Context, params *ScannerAPIServiceListRegistryResultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannerAPIServiceListRegistryResultsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSecureVulnerabilityV1ResultsResultId(ctx context.Context, resultId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSecureVulnerabilityV1ResultsResultIdRequest(c.Server, resultId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ScannerAPIServiceListRuntimeResults(ctx context.Context, params *ScannerAPIServiceListRuntimeResultsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewScannerAPIServiceListRuntimeResultsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAcceptedRisksV1(ctx context.Context, params *GetAcceptedRisksV1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAcceptedRisksV1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAcceptedRiskV1WithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAcceptedRiskV1RequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAcceptedRiskV1(ctx context.Context, body PostAcceptedRiskV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAcceptedRiskV1Request(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAcceptedRiskV1(ctx context.Context, acceptedRiskID AcceptedRiskID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAcceptedRiskV1Request(c.Server, acceptedRiskID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAcceptedRiskV1(ctx context.Context, acceptedRiskID AcceptedRiskID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAcceptedRiskV1Request(c.Server, acceptedRiskID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAcceptedRiskV1WithBody(ctx context.Context, acceptedRiskID AcceptedRiskID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAcceptedRiskV1RequestWithBody(c.Server, acceptedRiskID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAcceptedRiskV1(ctx context.Context, acceptedRiskID AcceptedRiskID, body UpdateAcceptedRiskV1JSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAcceptedRiskV1Request(c.Server, acceptedRiskID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSBOMV1beta1(ctx context.Context, params *GetSBOMV1beta1Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSBOMV1beta1Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewQuerySysqlGetRequest generates requests for QuerySysqlGet
func NewQuerySysqlGetRequest(server string, params *QuerySysqlGetParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/sysql/v2/query")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, params.Q); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.DeterministicOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deterministic_order", runtime.ParamLocationQuery, *params.DeterministicOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewQuerySysqlPostRequest calls the generic QuerySysqlPost builder with application/json body
func NewQuerySysqlPostRequest(server string, body QuerySysqlPostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewQuerySysqlPostRequestWithBody(server, "application/json", bodyReader)
}

// NewQuerySysqlPostRequestWithBody generates requests for QuerySysqlPost with any type of body
func NewQuerySysqlPostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/sysql/v2/query")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSysqlSchemaRequest generates requests for GetSysqlSchema
func NewGetSysqlSchemaRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/sysql/v2/schema")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInhibitionRulesRequest generates requests for GetInhibitionRules
func NewGetInhibitionRulesRequest(server string, params *GetInhibitionRulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/alerts/v1/inhibition-rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateInhibitionRuleRequest calls the generic CreateInhibitionRule builder with application/json body
func NewCreateInhibitionRuleRequest(server string, body CreateInhibitionRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateInhibitionRuleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateInhibitionRuleRequestWithBody generates requests for CreateInhibitionRule with any type of body
func NewCreateInhibitionRuleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/alerts/v1/inhibition-rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteInhibitionRuleByIdRequest generates requests for DeleteInhibitionRuleById
func NewDeleteInhibitionRuleByIdRequest(server string, inhibitionRuleId InhibitionRulePath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inhibitionRuleId", runtime.ParamLocationPath, inhibitionRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/alerts/v1/inhibition-rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInhibitionRuleByIdRequest generates requests for GetInhibitionRuleById
func NewGetInhibitionRuleByIdRequest(server string, inhibitionRuleId InhibitionRulePath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inhibitionRuleId", runtime.ParamLocationPath, inhibitionRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/alerts/v1/inhibition-rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateInhibitionRuleRequest calls the generic UpdateInhibitionRule builder with application/json body
func NewUpdateInhibitionRuleRequest(server string, inhibitionRuleId InhibitionRulePath, body UpdateInhibitionRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateInhibitionRuleRequestWithBody(server, inhibitionRuleId, "application/json", bodyReader)
}

// NewUpdateInhibitionRuleRequestWithBody generates requests for UpdateInhibitionRule with any type of body
func NewUpdateInhibitionRuleRequestWithBody(server string, inhibitionRuleId InhibitionRulePath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "inhibitionRuleId", runtime.ParamLocationPath, inhibitionRuleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/alerts/v1/inhibition-rules/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPricingV1Request generates requests for GetPricingV1
func NewGetPricingV1Request(server string, params *GetPricingV1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/cost-advisor/v1/pricing")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ClusterName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "clusterName", runtime.ParamLocationQuery, *params.ClusterName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePricingV1Request calls the generic CreatePricingV1 builder with application/json body
func NewCreatePricingV1Request(server string, body CreatePricingV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePricingV1RequestWithBody(server, "application/json", bodyReader)
}

// NewCreatePricingV1RequestWithBody generates requests for CreatePricingV1 with any type of body
func NewCreatePricingV1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/cost-advisor/v1/pricing")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePricingByIdV1Request generates requests for DeletePricingByIdV1
func NewDeletePricingByIdV1Request(server string, pricingId PricingIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pricingId", runtime.ParamLocationPath, pricingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/cost-advisor/v1/pricing/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPricingByIdV1Request generates requests for GetPricingByIdV1
func NewGetPricingByIdV1Request(server string, pricingId PricingIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pricingId", runtime.ParamLocationPath, pricingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/cost-advisor/v1/pricing/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePricingByIdV1Request calls the generic UpdatePricingByIdV1 builder with application/json body
func NewUpdatePricingByIdV1Request(server string, pricingId PricingIdPath, body UpdatePricingByIdV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePricingByIdV1RequestWithBody(server, pricingId, "application/json", bodyReader)
}

// NewUpdatePricingByIdV1RequestWithBody generates requests for UpdatePricingByIdV1 with any type of body
func NewUpdatePricingByIdV1RequestWithBody(server string, pricingId PricingIdPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pricingId", runtime.ParamLocationPath, pricingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/cost-advisor/v1/pricing/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPricingProjectedCostsV1Request generates requests for GetPricingProjectedCostsV1
func NewGetPricingProjectedCostsV1Request(server string, pricingId PricingIdPath, params *GetPricingProjectedCostsV1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pricingId", runtime.ParamLocationPath, pricingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/cost-advisor/v1/pricing/%s/projected-costs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWastedWorkloadDataRequest calls the generic GetWastedWorkloadData builder with application/json body
func NewGetWastedWorkloadDataRequest(server string, body GetWastedWorkloadDataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetWastedWorkloadDataRequestWithBody(server, "application/json", bodyReader)
}

// NewGetWastedWorkloadDataRequestWithBody generates requests for GetWastedWorkloadData with any type of body
func NewGetWastedWorkloadDataRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/cost-advisor/v1alpha1/data/wasted-workload-spend")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWorkloadCostDataV1Request calls the generic GetWorkloadCostDataV1 builder with application/json body
func NewGetWorkloadCostDataV1Request(server string, body GetWorkloadCostDataV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetWorkloadCostDataV1RequestWithBody(server, "application/json", bodyReader)
}

// NewGetWorkloadCostDataV1RequestWithBody generates requests for GetWorkloadCostDataV1 with any type of body
func NewGetWorkloadCostDataV1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/cost-advisor/v1alpha1/data/workload-cost-trends")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetWorkloadRightsizingDataRequest calls the generic GetWorkloadRightsizingData builder with application/json body
func NewGetWorkloadRightsizingDataRequest(server string, body GetWorkloadRightsizingDataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetWorkloadRightsizingDataRequestWithBody(server, "application/json", bodyReader)
}

// NewGetWorkloadRightsizingDataRequestWithBody generates requests for GetWorkloadRightsizingData with any type of body
func NewGetWorkloadRightsizingDataRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/cost-advisor/v1alpha1/data/workload-rightsizing")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMonitorEventsV1Request generates requests for GetMonitorEventsV1
func NewGetMonitorEventsV1Request(server string, params *GetMonitorEventsV1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/events/v1/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDisabledMetricsByJobV1Request generates requests for GetDisabledMetricsByJobV1
func NewGetDisabledMetricsByJobV1Request(server string, params *GetDisabledMetricsByJobV1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/prometheus-jobs/v1/disabled-metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.JobName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jobName", runtime.ParamLocationQuery, *params.JobName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MetricName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metricName", runtime.ParamLocationQuery, *params.MetricName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostDisabledMetricsV1Request calls the generic PostDisabledMetricsV1 builder with application/json body
func NewPostDisabledMetricsV1Request(server string, body PostDisabledMetricsV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDisabledMetricsV1RequestWithBody(server, "application/json", bodyReader)
}

// NewPostDisabledMetricsV1RequestWithBody generates requests for PostDisabledMetricsV1 with any type of body
func NewPostDisabledMetricsV1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/prometheus-jobs/v1/disabled-metrics")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomPrometheusJobsV1Request generates requests for GetCustomPrometheusJobsV1
func NewGetCustomPrometheusJobsV1Request(server string, params *GetCustomPrometheusJobsV1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/prometheus-jobs/v1alpha1/custom-jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCustomPrometheusJobByIdV1Request generates requests for DeleteCustomPrometheusJobByIdV1
func NewDeleteCustomPrometheusJobByIdV1Request(server string, jobName JobNamePath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobName", runtime.ParamLocationPath, jobName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/prometheus-jobs/v1alpha1/custom-jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCustomPrometheusJobByNameV1Request generates requests for GetCustomPrometheusJobByNameV1
func NewGetCustomPrometheusJobByNameV1Request(server string, jobName JobNamePath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobName", runtime.ParamLocationPath, jobName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/prometheus-jobs/v1alpha1/custom-jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCustomPrometheusJobV1RequestWithBody generates requests for CreateCustomPrometheusJobV1 with any type of body
func NewCreateCustomPrometheusJobV1RequestWithBody(server string, jobName JobNamePath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobName", runtime.ParamLocationPath, jobName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/prometheus-jobs/v1alpha1/custom-jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateCustomPrometheusJobByIdV1RequestWithBody generates requests for UpdateCustomPrometheusJobByIdV1 with any type of body
func NewUpdateCustomPrometheusJobByIdV1RequestWithBody(server string, jobName JobNamePath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobName", runtime.ParamLocationPath, jobName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/prometheus-jobs/v1alpha1/custom-jobs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomPrometheusJobEnablementV1Request generates requests for GetCustomPrometheusJobEnablementV1
func NewGetCustomPrometheusJobEnablementV1Request(server string, jobName JobNamePath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobName", runtime.ParamLocationPath, jobName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/prometheus-jobs/v1alpha1/custom-jobs/%s/enablement", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCustomPrometheusJobEnablementV1Request calls the generic UpdateCustomPrometheusJobEnablementV1 builder with application/json body
func NewUpdateCustomPrometheusJobEnablementV1Request(server string, jobName JobNamePath, body UpdateCustomPrometheusJobEnablementV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCustomPrometheusJobEnablementV1RequestWithBody(server, jobName, "application/json", bodyReader)
}

// NewUpdateCustomPrometheusJobEnablementV1RequestWithBody generates requests for UpdateCustomPrometheusJobEnablementV1 with any type of body
func NewUpdateCustomPrometheusJobEnablementV1RequestWithBody(server string, jobName JobNamePath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "jobName", runtime.ParamLocationPath, jobName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/monitor/prometheus-jobs/v1alpha1/custom-jobs/%s/enablement", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetJiraIntegrationsV1Request generates requests for GetJiraIntegrationsV1
func NewGetJiraIntegrationsV1Request(server string, params *GetJiraIntegrationsV1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/jira/v1/integrations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Enabled != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "enabled", runtime.ParamLocationQuery, *params.Enabled); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateJiraIntegrationV1Request calls the generic CreateJiraIntegrationV1 builder with application/json body
func NewCreateJiraIntegrationV1Request(server string, body CreateJiraIntegrationV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateJiraIntegrationV1RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateJiraIntegrationV1RequestWithBody generates requests for CreateJiraIntegrationV1 with any type of body
func NewCreateJiraIntegrationV1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/jira/v1/integrations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteJiraIntegrationV1Request generates requests for DeleteJiraIntegrationV1
func NewDeleteJiraIntegrationV1Request(server string, integrationID IntegrationID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/jira/v1/integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJiraIntegrationV1Request generates requests for GetJiraIntegrationV1
func NewGetJiraIntegrationV1Request(server string, integrationID IntegrationID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/jira/v1/integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateJiraIntegrationV1Request calls the generic UpdateJiraIntegrationV1 builder with application/json body
func NewUpdateJiraIntegrationV1Request(server string, integrationID IntegrationID, body UpdateJiraIntegrationV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateJiraIntegrationV1RequestWithBody(server, integrationID, "application/json", bodyReader)
}

// NewUpdateJiraIntegrationV1RequestWithBody generates requests for UpdateJiraIntegrationV1 with any type of body
func NewUpdateJiraIntegrationV1RequestWithBody(server string, integrationID IntegrationID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/jira/v1/integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetJiraIssueTypesV1Request generates requests for GetJiraIssueTypesV1
func NewGetJiraIssueTypesV1Request(server string, integrationID IntegrationID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/jira/v1/integrations/%s/issue-types", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateJiraIssueTypeV1Request calls the generic CreateJiraIssueTypeV1 builder with application/json body
func NewCreateJiraIssueTypeV1Request(server string, integrationID IntegrationID, body CreateJiraIssueTypeV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateJiraIssueTypeV1RequestWithBody(server, integrationID, "application/json", bodyReader)
}

// NewCreateJiraIssueTypeV1RequestWithBody generates requests for CreateJiraIssueTypeV1 with any type of body
func NewCreateJiraIssueTypeV1RequestWithBody(server string, integrationID IntegrationID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/jira/v1/integrations/%s/issue-types", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteJiraIssueTypeV1Request generates requests for DeleteJiraIssueTypeV1
func NewDeleteJiraIssueTypeV1Request(server string, integrationID IntegrationID, issueTypeID IssueTypeID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "issueTypeId", runtime.ParamLocationPath, issueTypeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/jira/v1/integrations/%s/issue-types/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJiraIssueTypeV1Request generates requests for GetJiraIssueTypeV1
func NewGetJiraIssueTypeV1Request(server string, integrationID IntegrationID, issueTypeID IssueTypeID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "issueTypeId", runtime.ParamLocationPath, issueTypeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/jira/v1/integrations/%s/issue-types/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateJiraIssueTypeV1Request calls the generic UpdateJiraIssueTypeV1 builder with application/json body
func NewUpdateJiraIssueTypeV1Request(server string, integrationID IntegrationID, issueTypeID IssueTypeID, body UpdateJiraIssueTypeV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateJiraIssueTypeV1RequestWithBody(server, integrationID, issueTypeID, "application/json", bodyReader)
}

// NewUpdateJiraIssueTypeV1RequestWithBody generates requests for UpdateJiraIssueTypeV1 with any type of body
func NewUpdateJiraIssueTypeV1RequestWithBody(server string, integrationID IntegrationID, issueTypeID IssueTypeID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "issueTypeId", runtime.ParamLocationPath, issueTypeID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/jira/v1/integrations/%s/issue-types/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListJobsV1Request generates requests for ListJobsV1
func NewListJobsV1Request(server string, params *ListJobsV1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/reporting/v1/jobs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduleId", runtime.ParamLocationQuery, params.ScheduleId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.ReportId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reportId", runtime.ParamLocationQuery, *params.ReportId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IsReportTemplate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "isReportTemplate", runtime.ParamLocationQuery, *params.IsReportTemplate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CompletedOn != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "completedOn", runtime.ParamLocationQuery, *params.CompletedOn); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.JobType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jobType", runtime.ParamLocationQuery, *params.JobType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kind", runtime.ParamLocationQuery, *params.Kind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Policies != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "policies", runtime.ParamLocationQuery, *params.Policies); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Zones != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "zones", runtime.ParamLocationQuery, *params.Zones); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSchedulesV1Request generates requests for ListSchedulesV1
func NewListSchedulesV1Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/reporting/v1/schedules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccessKeysV1Request generates requests for GetAccessKeysV1
func NewGetAccessKeysV1Request(server string, params *GetAccessKeysV1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/access-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Orderby != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderby", runtime.ParamLocationQuery, *params.Orderby); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAccessKeyV1Request calls the generic CreateAccessKeyV1 builder with application/json body
func NewCreateAccessKeyV1Request(server string, body CreateAccessKeyV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAccessKeyV1RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAccessKeyV1RequestWithBody generates requests for CreateAccessKeyV1 with any type of body
func NewCreateAccessKeyV1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/access-keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAccessKeyByIdV1Request generates requests for DeleteAccessKeyByIdV1
func NewDeleteAccessKeyByIdV1Request(server string, accessKeyId AccessKeyIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accessKeyId", runtime.ParamLocationPath, accessKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/access-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccessKeyByIdV1Request generates requests for GetAccessKeyByIdV1
func NewGetAccessKeyByIdV1Request(server string, accessKeyId AccessKeyIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accessKeyId", runtime.ParamLocationPath, accessKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/access-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAccessKeyByIdV1Request calls the generic UpdateAccessKeyByIdV1 builder with application/json body
func NewUpdateAccessKeyByIdV1Request(server string, accessKeyId AccessKeyIdPath, body UpdateAccessKeyByIdV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAccessKeyByIdV1RequestWithBody(server, accessKeyId, "application/json", bodyReader)
}

// NewUpdateAccessKeyByIdV1RequestWithBody generates requests for UpdateAccessKeyByIdV1 with any type of body
func NewUpdateAccessKeyByIdV1RequestWithBody(server string, accessKeyId AccessKeyIdPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accessKeyId", runtime.ParamLocationPath, accessKeyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/access-keys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCaptureStorageConfigurationV1Request generates requests for GetCaptureStorageConfigurationV1
func NewGetCaptureStorageConfigurationV1Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/configuration/capture-storage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCaptureStorageConfigurationV1Request calls the generic UpdateCaptureStorageConfigurationV1 builder with application/json body
func NewUpdateCaptureStorageConfigurationV1Request(server string, body UpdateCaptureStorageConfigurationV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCaptureStorageConfigurationV1RequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateCaptureStorageConfigurationV1RequestWithBody generates requests for UpdateCaptureStorageConfigurationV1 with any type of body
func NewUpdateCaptureStorageConfigurationV1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/configuration/capture-storage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserDeactivationConfigurationV1Request generates requests for GetUserDeactivationConfigurationV1
func NewGetUserDeactivationConfigurationV1Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/configuration/user-deactivation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserDeactivationConfigurationByIdV1Request calls the generic UpdateUserDeactivationConfigurationByIdV1 builder with application/json body
func NewUpdateUserDeactivationConfigurationByIdV1Request(server string, body UpdateUserDeactivationConfigurationByIdV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserDeactivationConfigurationByIdV1RequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateUserDeactivationConfigurationByIdV1RequestWithBody generates requests for UpdateUserDeactivationConfigurationByIdV1 with any type of body
func NewUpdateUserDeactivationConfigurationByIdV1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/configuration/user-deactivation")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDefaultRoleByDisplayNameV1Request generates requests for GetDefaultRoleByDisplayNameV1
func NewGetDefaultRoleByDisplayNameV1Request(server string, roleDisplayName GetDefaultRoleByDisplayNameV1ParamsRoleDisplayName) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleDisplayName", runtime.ParamLocationPath, roleDisplayName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/default-roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGlobaSsoSettingsV1Request generates requests for GetGlobaSsoSettingsV1
func NewGetGlobaSsoSettingsV1Request(server string, ssoProductId GetGlobaSsoSettingsV1ParamsSsoProductId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ssoProductId", runtime.ParamLocationPath, ssoProductId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/global-sso-settings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGlobalSsoSettingsV1Request calls the generic UpdateGlobalSsoSettingsV1 builder with application/json body
func NewUpdateGlobalSsoSettingsV1Request(server string, ssoProductId UpdateGlobalSsoSettingsV1ParamsSsoProductId, body UpdateGlobalSsoSettingsV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGlobalSsoSettingsV1RequestWithBody(server, ssoProductId, "application/json", bodyReader)
}

// NewUpdateGlobalSsoSettingsV1RequestWithBody generates requests for UpdateGlobalSsoSettingsV1 with any type of body
func NewUpdateGlobalSsoSettingsV1RequestWithBody(server string, ssoProductId UpdateGlobalSsoSettingsV1ParamsSsoProductId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ssoProductId", runtime.ParamLocationPath, ssoProductId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/global-sso-settings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGroupMappingsV1Request generates requests for GetGroupMappingsV1
func NewGetGroupMappingsV1Request(server string, params *GetGroupMappingsV1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/group-mappings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Orderby != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderby", runtime.ParamLocationQuery, *params.Orderby); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGroupMappingV1Request calls the generic CreateGroupMappingV1 builder with application/json body
func NewCreateGroupMappingV1Request(server string, body CreateGroupMappingV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGroupMappingV1RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateGroupMappingV1RequestWithBody generates requests for CreateGroupMappingV1 with any type of body
func NewCreateGroupMappingV1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/group-mappings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGroupMappingSettingsV1Request generates requests for GetGroupMappingSettingsV1
func NewGetGroupMappingSettingsV1Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/group-mappings-settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveGroupMappingSettingsV1Request calls the generic SaveGroupMappingSettingsV1 builder with application/json body
func NewSaveGroupMappingSettingsV1Request(server string, body SaveGroupMappingSettingsV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveGroupMappingSettingsV1RequestWithBody(server, "application/json", bodyReader)
}

// NewSaveGroupMappingSettingsV1RequestWithBody generates requests for SaveGroupMappingSettingsV1 with any type of body
func NewSaveGroupMappingSettingsV1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/group-mappings-settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGroupMappingByIdV1Request generates requests for DeleteGroupMappingByIdV1
func NewDeleteGroupMappingByIdV1Request(server string, groupMappingId GroupMappingIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupMappingId", runtime.ParamLocationPath, groupMappingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/group-mappings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupMappingByIdV1Request generates requests for GetGroupMappingByIdV1
func NewGetGroupMappingByIdV1Request(server string, groupMappingId GroupMappingIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupMappingId", runtime.ParamLocationPath, groupMappingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/group-mappings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateGroupMappingByIdV1Request calls the generic UpdateGroupMappingByIdV1 builder with application/json body
func NewUpdateGroupMappingByIdV1Request(server string, groupMappingId GroupMappingIdPath, body UpdateGroupMappingByIdV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGroupMappingByIdV1RequestWithBody(server, groupMappingId, "application/json", bodyReader)
}

// NewUpdateGroupMappingByIdV1RequestWithBody generates requests for UpdateGroupMappingByIdV1 with any type of body
func NewUpdateGroupMappingByIdV1RequestWithBody(server string, groupMappingId GroupMappingIdPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupMappingId", runtime.ParamLocationPath, groupMappingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/group-mappings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIpFiltersV1Request generates requests for GetIpFiltersV1
func NewGetIpFiltersV1Request(server string, params *GetIpFiltersV1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/ip-filters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateIpFilterV1Request calls the generic CreateIpFilterV1 builder with application/json body
func NewCreateIpFilterV1Request(server string, body CreateIpFilterV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateIpFilterV1RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateIpFilterV1RequestWithBody generates requests for CreateIpFilterV1 with any type of body
func NewCreateIpFilterV1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/ip-filters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetIpFiltersSettingsV1Request generates requests for GetIpFiltersSettingsV1
func NewGetIpFiltersSettingsV1Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/ip-filters-settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveIpFiltersSettingsV1Request calls the generic SaveIpFiltersSettingsV1 builder with application/json body
func NewSaveIpFiltersSettingsV1Request(server string, body SaveIpFiltersSettingsV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveIpFiltersSettingsV1RequestWithBody(server, "application/json", bodyReader)
}

// NewSaveIpFiltersSettingsV1RequestWithBody generates requests for SaveIpFiltersSettingsV1 with any type of body
func NewSaveIpFiltersSettingsV1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/ip-filters-settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteIpFilterByIdV1Request generates requests for DeleteIpFilterByIdV1
func NewDeleteIpFilterByIdV1Request(server string, ipFilterId IpFilterIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ipFilterId", runtime.ParamLocationPath, ipFilterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/ip-filters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetIpFilterByIdV1Request generates requests for GetIpFilterByIdV1
func NewGetIpFilterByIdV1Request(server string, ipFilterId IpFilterIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ipFilterId", runtime.ParamLocationPath, ipFilterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/ip-filters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateIpFilterV1Request calls the generic UpdateIpFilterV1 builder with application/json body
func NewUpdateIpFilterV1Request(server string, ipFilterId IpFilterIdPath, body UpdateIpFilterV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateIpFilterV1RequestWithBody(server, ipFilterId, "application/json", bodyReader)
}

// NewUpdateIpFilterV1RequestWithBody generates requests for UpdateIpFilterV1 with any type of body
func NewUpdateIpFilterV1RequestWithBody(server string, ipFilterId IpFilterIdPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ipFilterId", runtime.ParamLocationPath, ipFilterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/ip-filters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNotificationChannelsRequest generates requests for GetNotificationChannels
func NewGetNotificationChannelsRequest(server string, params *GetNotificationChannelsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/notification-channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateNotificationChannelRequest calls the generic CreateNotificationChannel builder with application/json body
func NewCreateNotificationChannelRequest(server string, body CreateNotificationChannelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateNotificationChannelRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateNotificationChannelRequestWithBody generates requests for CreateNotificationChannel with any type of body
func NewCreateNotificationChannelRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/notification-channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteNotificationChannelByIdRequest generates requests for DeleteNotificationChannelById
func NewDeleteNotificationChannelByIdRequest(server string, notificationChannelID NotificationChannelID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "notificationChannelId", runtime.ParamLocationPath, notificationChannelID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/notification-channels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNotificationChannelByIdRequest generates requests for GetNotificationChannelById
func NewGetNotificationChannelByIdRequest(server string, notificationChannelID NotificationChannelID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "notificationChannelId", runtime.ParamLocationPath, notificationChannelID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/notification-channels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateNotificationChannelByIdRequest calls the generic UpdateNotificationChannelById builder with application/json body
func NewUpdateNotificationChannelByIdRequest(server string, notificationChannelID NotificationChannelID, body UpdateNotificationChannelByIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateNotificationChannelByIdRequestWithBody(server, notificationChannelID, "application/json", bodyReader)
}

// NewUpdateNotificationChannelByIdRequestWithBody generates requests for UpdateNotificationChannelById with any type of body
func NewUpdateNotificationChannelByIdRequestWithBody(server string, notificationChannelID NotificationChannelID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "notificationChannelId", runtime.ParamLocationPath, notificationChannelID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/notification-channels/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPermissionsV1Request generates requests for GetPermissionsV1
func NewGetPermissionsV1Request(server string, params *GetPermissionsV1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/permissions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlatformAuditEventsV1Request generates requests for GetPlatformAuditEventsV1
func NewGetPlatformAuditEventsV1Request(server string, params *GetPlatformAuditEventsV1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/platform-audit-events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRolesV1Request generates requests for GetRolesV1
func NewGetRolesV1Request(server string, params *GetRolesV1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Orderby != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderby", runtime.ParamLocationQuery, *params.Orderby); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRoleV1Request calls the generic CreateRoleV1 builder with application/json body
func NewCreateRoleV1Request(server string, body CreateRoleV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRoleV1RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRoleV1RequestWithBody generates requests for CreateRoleV1 with any type of body
func NewCreateRoleV1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/roles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRoleByIdV1Request generates requests for DeleteRoleByIdV1
func NewDeleteRoleByIdV1Request(server string, roleId RoleIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRoleByIdV1Request generates requests for GetRoleByIdV1
func NewGetRoleByIdV1Request(server string, roleId RoleIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRoleByIdV1Request calls the generic UpdateRoleByIdV1 builder with application/json body
func NewUpdateRoleByIdV1Request(server string, roleId RoleIdPath, body UpdateRoleByIdV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRoleByIdV1RequestWithBody(server, roleId, "application/json", bodyReader)
}

// NewUpdateRoleByIdV1RequestWithBody generates requests for UpdateRoleByIdV1 with any type of body
func NewUpdateRoleByIdV1RequestWithBody(server string, roleId RoleIdPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "roleId", runtime.ParamLocationPath, roleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/roles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetGlobalServiceAccountsV1Request generates requests for GetGlobalServiceAccountsV1
func NewGetGlobalServiceAccountsV1Request(server string, params *GetGlobalServiceAccountsV1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/service-accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Orderby != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderby", runtime.ParamLocationQuery, *params.Orderby); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGlobalServiceAccountV1Request calls the generic CreateGlobalServiceAccountV1 builder with application/json body
func NewCreateGlobalServiceAccountV1Request(server string, body CreateGlobalServiceAccountV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGlobalServiceAccountV1RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateGlobalServiceAccountV1RequestWithBody generates requests for CreateGlobalServiceAccountV1 with any type of body
func NewCreateGlobalServiceAccountV1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/service-accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGlobalServiceAccountsNotificationSettingsV1Request generates requests for DeleteGlobalServiceAccountsNotificationSettingsV1
func NewDeleteGlobalServiceAccountsNotificationSettingsV1Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/service-accounts/notification-settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGlobalServiceAccountsNotificationSettingsV1Request generates requests for GetGlobalServiceAccountsNotificationSettingsV1
func NewGetGlobalServiceAccountsNotificationSettingsV1Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/service-accounts/notification-settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGlobalServiceAccountsNotificationSettingsV1Request calls the generic CreateGlobalServiceAccountsNotificationSettingsV1 builder with application/json body
func NewCreateGlobalServiceAccountsNotificationSettingsV1Request(server string, body CreateGlobalServiceAccountsNotificationSettingsV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGlobalServiceAccountsNotificationSettingsV1RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateGlobalServiceAccountsNotificationSettingsV1RequestWithBody generates requests for CreateGlobalServiceAccountsNotificationSettingsV1 with any type of body
func NewCreateGlobalServiceAccountsNotificationSettingsV1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/service-accounts/notification-settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateGlobalServiceAccountsNotificationSettingsV1Request calls the generic UpdateGlobalServiceAccountsNotificationSettingsV1 builder with application/json body
func NewUpdateGlobalServiceAccountsNotificationSettingsV1Request(server string, body UpdateGlobalServiceAccountsNotificationSettingsV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateGlobalServiceAccountsNotificationSettingsV1RequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateGlobalServiceAccountsNotificationSettingsV1RequestWithBody generates requests for UpdateGlobalServiceAccountsNotificationSettingsV1 with any type of body
func NewUpdateGlobalServiceAccountsNotificationSettingsV1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/service-accounts/notification-settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteGlobalServiceAccountByIdV1Request generates requests for DeleteGlobalServiceAccountByIdV1
func NewDeleteGlobalServiceAccountByIdV1Request(server string, serviceAccountId ServiceAccountIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/service-accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGlobalServiceAccountByIdV1Request generates requests for GetGlobalServiceAccountByIdV1
func NewGetGlobalServiceAccountByIdV1Request(server string, serviceAccountId ServiceAccountIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/service-accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSsoSettingsV1Request generates requests for GetSsoSettingsV1
func NewGetSsoSettingsV1Request(server string, params *GetSsoSettingsV1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/sso-settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSsoSettingsV1Request calls the generic CreateSsoSettingsV1 builder with application/json body
func NewCreateSsoSettingsV1Request(server string, body CreateSsoSettingsV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSsoSettingsV1RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSsoSettingsV1RequestWithBody generates requests for CreateSsoSettingsV1 with any type of body
func NewCreateSsoSettingsV1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/sso-settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSsoSettingsByIdV1Request generates requests for DeleteSsoSettingsByIdV1
func NewDeleteSsoSettingsByIdV1Request(server string, ssoSettingsId SsoSettingsIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ssoSettingsId", runtime.ParamLocationPath, ssoSettingsId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/sso-settings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSsoSettingsByIdV1Request generates requests for GetSsoSettingsByIdV1
func NewGetSsoSettingsByIdV1Request(server string, ssoSettingsId SsoSettingsIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ssoSettingsId", runtime.ParamLocationPath, ssoSettingsId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/sso-settings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSsoSettingsByIdV1Request calls the generic UpdateSsoSettingsByIdV1 builder with application/json body
func NewUpdateSsoSettingsByIdV1Request(server string, ssoSettingsId SsoSettingsIdPath, body UpdateSsoSettingsByIdV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSsoSettingsByIdV1RequestWithBody(server, ssoSettingsId, "application/json", bodyReader)
}

// NewUpdateSsoSettingsByIdV1RequestWithBody generates requests for UpdateSsoSettingsByIdV1 with any type of body
func NewUpdateSsoSettingsByIdV1RequestWithBody(server string, ssoSettingsId SsoSettingsIdPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ssoSettingsId", runtime.ParamLocationPath, ssoSettingsId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/sso-settings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTeamsV1Request generates requests for GetTeamsV1
func NewGetTeamsV1Request(server string, params *GetTeamsV1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Orderby != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderby", runtime.ParamLocationQuery, *params.Orderby); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTeamV1Request calls the generic CreateTeamV1 builder with application/json body
func NewCreateTeamV1Request(server string, body CreateTeamV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTeamV1RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateTeamV1RequestWithBody generates requests for CreateTeamV1 with any type of body
func NewCreateTeamV1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/teams")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTeamByIdV1Request generates requests for DeleteTeamByIdV1
func NewDeleteTeamByIdV1Request(server string, teamId TeamIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamByIdV1Request generates requests for GetTeamByIdV1
func NewGetTeamByIdV1Request(server string, teamId TeamIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTeamByIdV1Request calls the generic UpdateTeamByIdV1 builder with application/json body
func NewUpdateTeamByIdV1Request(server string, teamId TeamIdPath, body UpdateTeamByIdV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTeamByIdV1RequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewUpdateTeamByIdV1RequestWithBody generates requests for UpdateTeamByIdV1 with any type of body
func NewUpdateTeamByIdV1RequestWithBody(server string, teamId TeamIdPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/teams/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTeamServiceAccountsV1Request generates requests for GetTeamServiceAccountsV1
func NewGetTeamServiceAccountsV1Request(server string, teamId TeamIdPath, params *GetTeamServiceAccountsV1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/teams/%s/service-accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Orderby != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderby", runtime.ParamLocationQuery, *params.Orderby); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateTeamServiceAccountV1Request calls the generic CreateTeamServiceAccountV1 builder with application/json body
func NewCreateTeamServiceAccountV1Request(server string, teamId TeamIdPath, body CreateTeamServiceAccountV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTeamServiceAccountV1RequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewCreateTeamServiceAccountV1RequestWithBody generates requests for CreateTeamServiceAccountV1 with any type of body
func NewCreateTeamServiceAccountV1RequestWithBody(server string, teamId TeamIdPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/teams/%s/service-accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteServiceAccountsNotificationSettingsV1Request generates requests for DeleteServiceAccountsNotificationSettingsV1
func NewDeleteServiceAccountsNotificationSettingsV1Request(server string, teamId TeamIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/teams/%s/service-accounts/notification-settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetServiceAccountsNotificationSettingsV1Request generates requests for GetServiceAccountsNotificationSettingsV1
func NewGetServiceAccountsNotificationSettingsV1Request(server string, teamId TeamIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/teams/%s/service-accounts/notification-settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateServiceAccountsNotificationSettingsV1Request calls the generic CreateServiceAccountsNotificationSettingsV1 builder with application/json body
func NewCreateServiceAccountsNotificationSettingsV1Request(server string, teamId TeamIdPath, body CreateServiceAccountsNotificationSettingsV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateServiceAccountsNotificationSettingsV1RequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewCreateServiceAccountsNotificationSettingsV1RequestWithBody generates requests for CreateServiceAccountsNotificationSettingsV1 with any type of body
func NewCreateServiceAccountsNotificationSettingsV1RequestWithBody(server string, teamId TeamIdPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/teams/%s/service-accounts/notification-settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateServiceAccountsNotificationSettingsV1Request calls the generic UpdateServiceAccountsNotificationSettingsV1 builder with application/json body
func NewUpdateServiceAccountsNotificationSettingsV1Request(server string, teamId TeamIdPath, body UpdateServiceAccountsNotificationSettingsV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateServiceAccountsNotificationSettingsV1RequestWithBody(server, teamId, "application/json", bodyReader)
}

// NewUpdateServiceAccountsNotificationSettingsV1RequestWithBody generates requests for UpdateServiceAccountsNotificationSettingsV1 with any type of body
func NewUpdateServiceAccountsNotificationSettingsV1RequestWithBody(server string, teamId TeamIdPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/teams/%s/service-accounts/notification-settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTeamServiceAccountByIdV1Request generates requests for DeleteTeamServiceAccountByIdV1
func NewDeleteTeamServiceAccountByIdV1Request(server string, teamId TeamIdPath, serviceAccountId ServiceAccountIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/teams/%s/service-accounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamServiceAccountByIdV1Request generates requests for GetTeamServiceAccountByIdV1
func NewGetTeamServiceAccountByIdV1Request(server string, teamId TeamIdPath, serviceAccountId ServiceAccountIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "serviceAccountId", runtime.ParamLocationPath, serviceAccountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/teams/%s/service-accounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamUsersV1Request generates requests for GetTeamUsersV1
func NewGetTeamUsersV1Request(server string, teamId TeamIdPath, params *GetTeamUsersV1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/teams/%s/users", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithAdminUsers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withAdminUsers", runtime.ParamLocationQuery, *params.WithAdminUsers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTeamUserByIdV1Request generates requests for DeleteTeamUserByIdV1
func NewDeleteTeamUserByIdV1Request(server string, teamId TeamIdPath, userId UserIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/teams/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeamUserByIdV1Request generates requests for GetTeamUserByIdV1
func NewGetTeamUserByIdV1Request(server string, teamId TeamIdPath, userId UserIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/teams/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSaveTeamUserV1Request calls the generic SaveTeamUserV1 builder with application/json body
func NewSaveTeamUserV1Request(server string, teamId TeamIdPath, userId UserIdPath, body SaveTeamUserV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSaveTeamUserV1RequestWithBody(server, teamId, userId, "application/json", bodyReader)
}

// NewSaveTeamUserV1RequestWithBody generates requests for SaveTeamUserV1 with any type of body
func NewSaveTeamUserV1RequestWithBody(server string, teamId TeamIdPath, userId UserIdPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "teamId", runtime.ParamLocationPath, teamId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/teams/%s/users/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUsersV1Request generates requests for GetUsersV1
func NewGetUsersV1Request(server string, params *GetUsersV1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Orderby != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderby", runtime.ParamLocationQuery, *params.Orderby); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateUserV1Request calls the generic CreateUserV1 builder with application/json body
func NewCreateUserV1Request(server string, params *CreateUserV1Params, body CreateUserV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUserV1RequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateUserV1RequestWithBody generates requests for CreateUserV1 with any type of body
func NewCreateUserV1RequestWithBody(server string, params *CreateUserV1Params, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ActivationFlow != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "activationFlow", runtime.ParamLocationQuery, *params.ActivationFlow); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserByIdV1Request generates requests for DeleteUserByIdV1
func NewDeleteUserByIdV1Request(server string, userId UserIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserByIdV1Request generates requests for GetUserByIdV1
func NewGetUserByIdV1Request(server string, userId UserIdPath) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserV1Request calls the generic UpdateUserV1 builder with application/json body
func NewUpdateUserV1Request(server string, userId UserIdPath, body UpdateUserV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserV1RequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUpdateUserV1RequestWithBody generates requests for UpdateUserV1 with any type of body
func NewUpdateUserV1RequestWithBody(server string, userId UserIdPath, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListZonesV1Request generates requests for ListZonesV1
func NewListZonesV1Request(server string, params *ListZonesV1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/zones")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Orderby != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orderby", runtime.ParamLocationQuery, *params.Orderby); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateZoneV1Request calls the generic CreateZoneV1 builder with application/json body
func NewCreateZoneV1Request(server string, body CreateZoneV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateZoneV1RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateZoneV1RequestWithBody generates requests for CreateZoneV1 with any type of body
func NewCreateZoneV1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/zones")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteZoneV1Request generates requests for DeleteZoneV1
func NewDeleteZoneV1Request(server string, zoneId ZoneId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/zones/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetZoneByIdV1Request generates requests for GetZoneByIdV1
func NewGetZoneByIdV1Request(server string, zoneId ZoneId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/zones/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewEditZoneV1Request calls the generic EditZoneV1 builder with application/json body
func NewEditZoneV1Request(server string, zoneId ZoneId, body EditZoneV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditZoneV1RequestWithBody(server, zoneId, "application/json", bodyReader)
}

// NewEditZoneV1RequestWithBody generates requests for EditZoneV1 with any type of body
func NewEditZoneV1RequestWithBody(server string, zoneId ZoneId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "zoneId", runtime.ParamLocationPath, zoneId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/platform/v1/zones/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetActivityAuditEntriesV1Request generates requests for GetActivityAuditEntriesV1
func NewGetActivityAuditEntriesV1Request(server string, params *GetActivityAuditEntriesV1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/activity-audit/v1/entries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Zones != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "zones", runtime.ParamLocationQuery, *params.Zones); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Types != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "types", runtime.ParamLocationQuery, *params.Types); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActivityAuditEntryV1Request generates requests for GetActivityAuditEntryV1
func NewGetActivityAuditEntryV1Request(server string, entryId EntryId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "entryId", runtime.ParamLocationPath, entryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/activity-audit/v1/entries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActivityAuditEntriesSupportedFiltersV1Request generates requests for GetActivityAuditEntriesSupportedFiltersV1
func NewGetActivityAuditEntriesSupportedFiltersV1Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/activity-audit/v1/supported-filters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCertificatesV1Request generates requests for GetCertificatesV1
func NewGetCertificatesV1Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/certman/v1/certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadCertificateV1RequestWithBody generates requests for UploadCertificateV1 with any type of body
func NewUploadCertificateV1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/certman/v1/certificates")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCertificateV1Request generates requests for DeleteCertificateV1
func NewDeleteCertificateV1Request(server string, certId PathCertificateId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certId", runtime.ParamLocationPath, certId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/certman/v1/certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCertificateV1Request generates requests for GetCertificateV1
func NewGetCertificateV1Request(server string, certId PathCertificateId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certId", runtime.ParamLocationPath, certId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/certman/v1/certificates/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCertificateRegistrationV1Request generates requests for GetCertificateRegistrationV1
func NewGetCertificateRegistrationV1Request(server string, certId PathCertificateId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "certId", runtime.ParamLocationPath, certId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/certman/v1/certificates/%s/services", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCSRV1Request generates requests for CreateCSRV1
func NewCreateCSRV1Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/certman/v1/csr")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEFOChannelsByIntegrationV1Request generates requests for ListEFOChannelsByIntegrationV1
func NewListEFOChannelsByIntegrationV1Request(server string, params *ListEFOChannelsByIntegrationV1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/events-forwarder/v1/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEFOIntegrationsV1Request generates requests for ListEFOIntegrationsV1
func NewListEFOIntegrationsV1Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/events-forwarder/v1/integrations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEFOIntegrationV1Request calls the generic CreateEFOIntegrationV1 builder with application/json body
func NewCreateEFOIntegrationV1Request(server string, body CreateEFOIntegrationV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEFOIntegrationV1RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateEFOIntegrationV1RequestWithBody generates requests for CreateEFOIntegrationV1 with any type of body
func NewCreateEFOIntegrationV1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/events-forwarder/v1/integrations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEFOIntegrationByIdV1Request generates requests for DeleteEFOIntegrationByIdV1
func NewDeleteEFOIntegrationByIdV1Request(server string, integrationId IntegrationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/events-forwarder/v1/integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEFOIntegrationByIdV1Request generates requests for GetEFOIntegrationByIdV1
func NewGetEFOIntegrationByIdV1Request(server string, integrationId IntegrationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/events-forwarder/v1/integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEFOIntegrationByIdV1Request calls the generic UpdateEFOIntegrationByIdV1 builder with application/json body
func NewUpdateEFOIntegrationByIdV1Request(server string, integrationId IntegrationId, body UpdateEFOIntegrationByIdV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEFOIntegrationByIdV1RequestWithBody(server, integrationId, "application/json", bodyReader)
}

// NewUpdateEFOIntegrationByIdV1RequestWithBody generates requests for UpdateEFOIntegrationByIdV1 with any type of body
func NewUpdateEFOIntegrationByIdV1RequestWithBody(server string, integrationId IntegrationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/events-forwarder/v1/integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListEFOIntegrationsTypesV1Request generates requests for ListEFOIntegrationsTypesV1
func NewListEFOIntegrationsTypesV1Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/events-forwarder/v1/types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEFOChannelsByIntegrationV2Request generates requests for ListEFOChannelsByIntegrationV2
func NewListEFOChannelsByIntegrationV2Request(server string, params *ListEFOChannelsByIntegrationV2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/events-forwarder/v2/channels")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListEFOIntegrationsV2Request generates requests for ListEFOIntegrationsV2
func NewListEFOIntegrationsV2Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/events-forwarder/v2/integrations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateEFOIntegrationV2Request calls the generic CreateEFOIntegrationV2 builder with application/json body
func NewCreateEFOIntegrationV2Request(server string, body CreateEFOIntegrationV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateEFOIntegrationV2RequestWithBody(server, "application/json", bodyReader)
}

// NewCreateEFOIntegrationV2RequestWithBody generates requests for CreateEFOIntegrationV2 with any type of body
func NewCreateEFOIntegrationV2RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/events-forwarder/v2/integrations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteEFOIntegrationByIdV2Request generates requests for DeleteEFOIntegrationByIdV2
func NewDeleteEFOIntegrationByIdV2Request(server string, integrationId IntegrationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/events-forwarder/v2/integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEFOIntegrationByIdV2Request generates requests for GetEFOIntegrationByIdV2
func NewGetEFOIntegrationByIdV2Request(server string, integrationId IntegrationId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/events-forwarder/v2/integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateEFOIntegrationByIdV2Request calls the generic UpdateEFOIntegrationByIdV2 builder with application/json body
func NewUpdateEFOIntegrationByIdV2Request(server string, integrationId IntegrationId, body UpdateEFOIntegrationByIdV2JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEFOIntegrationByIdV2RequestWithBody(server, integrationId, "application/json", bodyReader)
}

// NewUpdateEFOIntegrationByIdV2RequestWithBody generates requests for UpdateEFOIntegrationByIdV2 with any type of body
func NewUpdateEFOIntegrationByIdV2RequestWithBody(server string, integrationId IntegrationId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "integrationId", runtime.ParamLocationPath, integrationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/events-forwarder/v2/integrations/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListEFOIntegrationsTypesV2Request generates requests for ListEFOIntegrationsTypesV2
func NewListEFOIntegrationsTypesV2Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/events-forwarder/v2/types")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEventsV1Request generates requests for GetEventsV1
func NewGetEventsV1Request(server string, params *GetEventsV1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/events/v1/events")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Zones != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "zones", runtime.ParamLocationQuery, *params.Zones); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEventV1Request generates requests for GetEventV1
func NewGetEventV1Request(server string, eventId EventId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "eventId", runtime.ParamLocationPath, eventId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/events/v1/events/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEventsSupportedFiltersV1Request generates requests for GetEventsSupportedFiltersV1
func NewGetEventsSupportedFiltersV1Request(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/events/v1/supported-filters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourcesRequest generates requests for GetResources
func NewGetResourcesRequest(server string, params *GetResourcesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/inventory/v1/resources")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageNumber", runtime.ParamLocationQuery, *params.PageNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithEnrichedContainers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withEnrichedContainers", runtime.ParamLocationQuery, *params.WithEnrichedContainers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResourceRequest generates requests for GetResource
func NewGetResourceRequest(server string, hash string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "hash", runtime.ParamLocationPath, hash)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/inventory/v1/resources/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActionExecutionsv1Request generates requests for GetActionExecutionsv1
func NewGetActionExecutionsv1Request(server string, params *GetActionExecutionsv1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/response-actions/v1alpha1/action-executions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CallerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "callerId", runtime.ParamLocationQuery, *params.CallerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSubmitActionExecutionv1Request calls the generic SubmitActionExecutionv1 builder with application/json body
func NewSubmitActionExecutionv1Request(server string, body SubmitActionExecutionv1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSubmitActionExecutionv1RequestWithBody(server, "application/json", bodyReader)
}

// NewSubmitActionExecutionv1RequestWithBody generates requests for SubmitActionExecutionv1 with any type of body
func NewSubmitActionExecutionv1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/response-actions/v1alpha1/action-executions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUndoActionExecutionV1Request generates requests for UndoActionExecutionV1
func NewUndoActionExecutionV1Request(server string, actionExecutionId ActionExecutionId, params *UndoActionExecutionV1Params) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "actionExecutionId", runtime.ParamLocationPath, actionExecutionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/response-actions/v1alpha1/action-executions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.CallerId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "callerId", runtime.ParamLocationQuery, *params.CallerId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActionExecutionV1Request generates requests for GetActionExecutionV1
func NewGetActionExecutionV1Request(server string, actionExecutionId ActionExecutionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "actionExecutionId", runtime.ParamLocationPath, actionExecutionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/response-actions/v1alpha1/action-executions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActionExecutionFileAcquireV1Request generates requests for GetActionExecutionFileAcquireV1
func NewGetActionExecutionFileAcquireV1Request(server string, actionExecutionId ActionExecutionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "actionExecutionId", runtime.ParamLocationPath, actionExecutionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/response-actions/v1alpha1/action-executions/%s/acquired-file", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActionsV1Request generates requests for GetActionsV1
func NewGetActionsV1Request(server string, params *GetActionsV1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/response-actions/v1alpha1/actions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Context != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "context", runtime.ParamLocationQuery, *params.Context); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSecureVulnerabilityV1BundlesRequest generates requests for GetSecureVulnerabilityV1Bundles
func NewGetSecureVulnerabilityV1BundlesRequest(server string, params *GetSecureVulnerabilityV1BundlesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/vulnerability/v1/bundles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSecureVulnerabilityV1BundlesRequest calls the generic PostSecureVulnerabilityV1Bundles builder with application/json body
func NewPostSecureVulnerabilityV1BundlesRequest(server string, body PostSecureVulnerabilityV1BundlesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSecureVulnerabilityV1BundlesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSecureVulnerabilityV1BundlesRequestWithBody generates requests for PostSecureVulnerabilityV1Bundles with any type of body
func NewPostSecureVulnerabilityV1BundlesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/vulnerability/v1/bundles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSecureVulnerabilityV1BundlesBundleIdRequest generates requests for DeleteSecureVulnerabilityV1BundlesBundleId
func NewDeleteSecureVulnerabilityV1BundlesBundleIdRequest(server string, bundleId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bundleId", runtime.ParamLocationPath, bundleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/vulnerability/v1/bundles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSecureVulnerabilityV1BundlesBundleIdRequest generates requests for GetSecureVulnerabilityV1BundlesBundleId
func NewGetSecureVulnerabilityV1BundlesBundleIdRequest(server string, bundleId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bundleId", runtime.ParamLocationPath, bundleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/vulnerability/v1/bundles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutSecureVulnerabilityV1BundlesBundleIdRequest calls the generic PutSecureVulnerabilityV1BundlesBundleId builder with application/json body
func NewPutSecureVulnerabilityV1BundlesBundleIdRequest(server string, bundleId int64, body PutSecureVulnerabilityV1BundlesBundleIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutSecureVulnerabilityV1BundlesBundleIdRequestWithBody(server, bundleId, "application/json", bodyReader)
}

// NewPutSecureVulnerabilityV1BundlesBundleIdRequestWithBody generates requests for PutSecureVulnerabilityV1BundlesBundleId with any type of body
func NewPutSecureVulnerabilityV1BundlesBundleIdRequestWithBody(server string, bundleId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "bundleId", runtime.ParamLocationPath, bundleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/vulnerability/v1/bundles/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSecureVulnerabilityV1PipelineResultsRequest generates requests for GetSecureVulnerabilityV1PipelineResults
func NewGetSecureVulnerabilityV1PipelineResultsRequest(server string, params *GetSecureVulnerabilityV1PipelineResultsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/vulnerability/v1/pipeline-results")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSecureVulnerabilityV1PoliciesRequest generates requests for GetSecureVulnerabilityV1Policies
func NewGetSecureVulnerabilityV1PoliciesRequest(server string, params *GetSecureVulnerabilityV1PoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/vulnerability/v1/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stages", runtime.ParamLocationQuery, *params.Stages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSecureVulnerabilityV1PoliciesRequest calls the generic PostSecureVulnerabilityV1Policies builder with application/json body
func NewPostSecureVulnerabilityV1PoliciesRequest(server string, body PostSecureVulnerabilityV1PoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSecureVulnerabilityV1PoliciesRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSecureVulnerabilityV1PoliciesRequestWithBody generates requests for PostSecureVulnerabilityV1Policies with any type of body
func NewPostSecureVulnerabilityV1PoliciesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/vulnerability/v1/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSecureVulnerabilityV1PoliciesPolicyIdRequest generates requests for DeleteSecureVulnerabilityV1PoliciesPolicyId
func NewDeleteSecureVulnerabilityV1PoliciesPolicyIdRequest(server string, policyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/vulnerability/v1/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSecureVulnerabilityV1PoliciesPolicyIdRequest generates requests for GetSecureVulnerabilityV1PoliciesPolicyId
func NewGetSecureVulnerabilityV1PoliciesPolicyIdRequest(server string, policyId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/vulnerability/v1/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutSecureVulnerabilityV1PoliciesPolicyIdRequest calls the generic PutSecureVulnerabilityV1PoliciesPolicyId builder with application/json body
func NewPutSecureVulnerabilityV1PoliciesPolicyIdRequest(server string, policyId int64, body PutSecureVulnerabilityV1PoliciesPolicyIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutSecureVulnerabilityV1PoliciesPolicyIdRequestWithBody(server, policyId, "application/json", bodyReader)
}

// NewPutSecureVulnerabilityV1PoliciesPolicyIdRequestWithBody generates requests for PutSecureVulnerabilityV1PoliciesPolicyId with any type of body
func NewPutSecureVulnerabilityV1PoliciesPolicyIdRequestWithBody(server string, policyId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policyId", runtime.ParamLocationPath, policyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/vulnerability/v1/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewScannerAPIServiceListRegistryResultsRequest generates requests for ScannerAPIServiceListRegistryResults
func NewScannerAPIServiceListRegistryResultsRequest(server string, params *ScannerAPIServiceListRegistryResultsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/vulnerability/v1/registry-results")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSecureVulnerabilityV1ResultsResultIdRequest generates requests for GetSecureVulnerabilityV1ResultsResultId
func NewGetSecureVulnerabilityV1ResultsResultIdRequest(server string, resultId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resultId", runtime.ParamLocationPath, resultId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/vulnerability/v1/results/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewScannerAPIServiceListRuntimeResultsRequest generates requests for ScannerAPIServiceListRuntimeResults
func NewScannerAPIServiceListRuntimeResultsRequest(server string, params *ScannerAPIServiceListRuntimeResultsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/vulnerability/v1/runtime-results")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAcceptedRisksV1Request generates requests for GetAcceptedRisksV1
func NewGetAcceptedRisksV1Request(server string, params *GetAcceptedRisksV1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/vulnerability/v1beta1/accepted-risks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cursor", runtime.ParamLocationQuery, *params.Cursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAcceptedRiskV1Request calls the generic PostAcceptedRiskV1 builder with application/json body
func NewPostAcceptedRiskV1Request(server string, body PostAcceptedRiskV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAcceptedRiskV1RequestWithBody(server, "application/json", bodyReader)
}

// NewPostAcceptedRiskV1RequestWithBody generates requests for PostAcceptedRiskV1 with any type of body
func NewPostAcceptedRiskV1RequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/vulnerability/v1beta1/accepted-risks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAcceptedRiskV1Request generates requests for DeleteAcceptedRiskV1
func NewDeleteAcceptedRiskV1Request(server string, acceptedRiskID AcceptedRiskID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "acceptedRiskID", runtime.ParamLocationPath, acceptedRiskID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/vulnerability/v1beta1/accepted-risks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAcceptedRiskV1Request generates requests for GetAcceptedRiskV1
func NewGetAcceptedRiskV1Request(server string, acceptedRiskID AcceptedRiskID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "acceptedRiskID", runtime.ParamLocationPath, acceptedRiskID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/vulnerability/v1beta1/accepted-risks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAcceptedRiskV1Request calls the generic UpdateAcceptedRiskV1 builder with application/json body
func NewUpdateAcceptedRiskV1Request(server string, acceptedRiskID AcceptedRiskID, body UpdateAcceptedRiskV1JSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAcceptedRiskV1RequestWithBody(server, acceptedRiskID, "application/json", bodyReader)
}

// NewUpdateAcceptedRiskV1RequestWithBody generates requests for UpdateAcceptedRiskV1 with any type of body
func NewUpdateAcceptedRiskV1RequestWithBody(server string, acceptedRiskID AcceptedRiskID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "acceptedRiskID", runtime.ParamLocationPath, acceptedRiskID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/vulnerability/v1beta1/accepted-risks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSBOMV1beta1Request generates requests for GetSBOMV1beta1
func NewGetSBOMV1beta1Request(server string, params *GetSBOMV1beta1Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/secure/vulnerability/v1beta1/sboms")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.AssetId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assetId", runtime.ParamLocationQuery, *params.AssetId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AssetType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "assetType", runtime.ParamLocationQuery, *params.AssetType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.BomIdentifier != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bomIdentifier", runtime.ParamLocationQuery, *params.BomIdentifier); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// QuerySysqlGetWithResponse request
	QuerySysqlGetWithResponse(ctx context.Context, params *QuerySysqlGetParams, reqEditors ...RequestEditorFn) (*QuerySysqlGetResponse, error)

	// QuerySysqlPostWithBodyWithResponse request with any body
	QuerySysqlPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QuerySysqlPostResponse, error)

	QuerySysqlPostWithResponse(ctx context.Context, body QuerySysqlPostJSONRequestBody, reqEditors ...RequestEditorFn) (*QuerySysqlPostResponse, error)

	// GetSysqlSchemaWithResponse request
	GetSysqlSchemaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSysqlSchemaResponse, error)

	// GetInhibitionRulesWithResponse request
	GetInhibitionRulesWithResponse(ctx context.Context, params *GetInhibitionRulesParams, reqEditors ...RequestEditorFn) (*GetInhibitionRulesResponse, error)

	// CreateInhibitionRuleWithBodyWithResponse request with any body
	CreateInhibitionRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInhibitionRuleResponse, error)

	CreateInhibitionRuleWithResponse(ctx context.Context, body CreateInhibitionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInhibitionRuleResponse, error)

	// DeleteInhibitionRuleByIdWithResponse request
	DeleteInhibitionRuleByIdWithResponse(ctx context.Context, inhibitionRuleId InhibitionRulePath, reqEditors ...RequestEditorFn) (*DeleteInhibitionRuleByIdResponse, error)

	// GetInhibitionRuleByIdWithResponse request
	GetInhibitionRuleByIdWithResponse(ctx context.Context, inhibitionRuleId InhibitionRulePath, reqEditors ...RequestEditorFn) (*GetInhibitionRuleByIdResponse, error)

	// UpdateInhibitionRuleWithBodyWithResponse request with any body
	UpdateInhibitionRuleWithBodyWithResponse(ctx context.Context, inhibitionRuleId InhibitionRulePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInhibitionRuleResponse, error)

	UpdateInhibitionRuleWithResponse(ctx context.Context, inhibitionRuleId InhibitionRulePath, body UpdateInhibitionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInhibitionRuleResponse, error)

	// GetPricingV1WithResponse request
	GetPricingV1WithResponse(ctx context.Context, params *GetPricingV1Params, reqEditors ...RequestEditorFn) (*GetPricingV1Response, error)

	// CreatePricingV1WithBodyWithResponse request with any body
	CreatePricingV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePricingV1Response, error)

	CreatePricingV1WithResponse(ctx context.Context, body CreatePricingV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePricingV1Response, error)

	// DeletePricingByIdV1WithResponse request
	DeletePricingByIdV1WithResponse(ctx context.Context, pricingId PricingIdPath, reqEditors ...RequestEditorFn) (*DeletePricingByIdV1Response, error)

	// GetPricingByIdV1WithResponse request
	GetPricingByIdV1WithResponse(ctx context.Context, pricingId PricingIdPath, reqEditors ...RequestEditorFn) (*GetPricingByIdV1Response, error)

	// UpdatePricingByIdV1WithBodyWithResponse request with any body
	UpdatePricingByIdV1WithBodyWithResponse(ctx context.Context, pricingId PricingIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePricingByIdV1Response, error)

	UpdatePricingByIdV1WithResponse(ctx context.Context, pricingId PricingIdPath, body UpdatePricingByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePricingByIdV1Response, error)

	// GetPricingProjectedCostsV1WithResponse request
	GetPricingProjectedCostsV1WithResponse(ctx context.Context, pricingId PricingIdPath, params *GetPricingProjectedCostsV1Params, reqEditors ...RequestEditorFn) (*GetPricingProjectedCostsV1Response, error)

	// GetWastedWorkloadDataWithBodyWithResponse request with any body
	GetWastedWorkloadDataWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetWastedWorkloadDataResponse, error)

	GetWastedWorkloadDataWithResponse(ctx context.Context, body GetWastedWorkloadDataJSONRequestBody, reqEditors ...RequestEditorFn) (*GetWastedWorkloadDataResponse, error)

	// GetWorkloadCostDataV1WithBodyWithResponse request with any body
	GetWorkloadCostDataV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetWorkloadCostDataV1Response, error)

	GetWorkloadCostDataV1WithResponse(ctx context.Context, body GetWorkloadCostDataV1JSONRequestBody, reqEditors ...RequestEditorFn) (*GetWorkloadCostDataV1Response, error)

	// GetWorkloadRightsizingDataWithBodyWithResponse request with any body
	GetWorkloadRightsizingDataWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetWorkloadRightsizingDataResponse, error)

	GetWorkloadRightsizingDataWithResponse(ctx context.Context, body GetWorkloadRightsizingDataJSONRequestBody, reqEditors ...RequestEditorFn) (*GetWorkloadRightsizingDataResponse, error)

	// GetMonitorEventsV1WithResponse request
	GetMonitorEventsV1WithResponse(ctx context.Context, params *GetMonitorEventsV1Params, reqEditors ...RequestEditorFn) (*GetMonitorEventsV1Response, error)

	// GetDisabledMetricsByJobV1WithResponse request
	GetDisabledMetricsByJobV1WithResponse(ctx context.Context, params *GetDisabledMetricsByJobV1Params, reqEditors ...RequestEditorFn) (*GetDisabledMetricsByJobV1Response, error)

	// PostDisabledMetricsV1WithBodyWithResponse request with any body
	PostDisabledMetricsV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDisabledMetricsV1Response, error)

	PostDisabledMetricsV1WithResponse(ctx context.Context, body PostDisabledMetricsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*PostDisabledMetricsV1Response, error)

	// GetCustomPrometheusJobsV1WithResponse request
	GetCustomPrometheusJobsV1WithResponse(ctx context.Context, params *GetCustomPrometheusJobsV1Params, reqEditors ...RequestEditorFn) (*GetCustomPrometheusJobsV1Response, error)

	// DeleteCustomPrometheusJobByIdV1WithResponse request
	DeleteCustomPrometheusJobByIdV1WithResponse(ctx context.Context, jobName JobNamePath, reqEditors ...RequestEditorFn) (*DeleteCustomPrometheusJobByIdV1Response, error)

	// GetCustomPrometheusJobByNameV1WithResponse request
	GetCustomPrometheusJobByNameV1WithResponse(ctx context.Context, jobName JobNamePath, reqEditors ...RequestEditorFn) (*GetCustomPrometheusJobByNameV1Response, error)

	// CreateCustomPrometheusJobV1WithBodyWithResponse request with any body
	CreateCustomPrometheusJobV1WithBodyWithResponse(ctx context.Context, jobName JobNamePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomPrometheusJobV1Response, error)

	// UpdateCustomPrometheusJobByIdV1WithBodyWithResponse request with any body
	UpdateCustomPrometheusJobByIdV1WithBodyWithResponse(ctx context.Context, jobName JobNamePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomPrometheusJobByIdV1Response, error)

	// GetCustomPrometheusJobEnablementV1WithResponse request
	GetCustomPrometheusJobEnablementV1WithResponse(ctx context.Context, jobName JobNamePath, reqEditors ...RequestEditorFn) (*GetCustomPrometheusJobEnablementV1Response, error)

	// UpdateCustomPrometheusJobEnablementV1WithBodyWithResponse request with any body
	UpdateCustomPrometheusJobEnablementV1WithBodyWithResponse(ctx context.Context, jobName JobNamePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomPrometheusJobEnablementV1Response, error)

	UpdateCustomPrometheusJobEnablementV1WithResponse(ctx context.Context, jobName JobNamePath, body UpdateCustomPrometheusJobEnablementV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomPrometheusJobEnablementV1Response, error)

	// GetJiraIntegrationsV1WithResponse request
	GetJiraIntegrationsV1WithResponse(ctx context.Context, params *GetJiraIntegrationsV1Params, reqEditors ...RequestEditorFn) (*GetJiraIntegrationsV1Response, error)

	// CreateJiraIntegrationV1WithBodyWithResponse request with any body
	CreateJiraIntegrationV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJiraIntegrationV1Response, error)

	CreateJiraIntegrationV1WithResponse(ctx context.Context, body CreateJiraIntegrationV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJiraIntegrationV1Response, error)

	// DeleteJiraIntegrationV1WithResponse request
	DeleteJiraIntegrationV1WithResponse(ctx context.Context, integrationID IntegrationID, reqEditors ...RequestEditorFn) (*DeleteJiraIntegrationV1Response, error)

	// GetJiraIntegrationV1WithResponse request
	GetJiraIntegrationV1WithResponse(ctx context.Context, integrationID IntegrationID, reqEditors ...RequestEditorFn) (*GetJiraIntegrationV1Response, error)

	// UpdateJiraIntegrationV1WithBodyWithResponse request with any body
	UpdateJiraIntegrationV1WithBodyWithResponse(ctx context.Context, integrationID IntegrationID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateJiraIntegrationV1Response, error)

	UpdateJiraIntegrationV1WithResponse(ctx context.Context, integrationID IntegrationID, body UpdateJiraIntegrationV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateJiraIntegrationV1Response, error)

	// GetJiraIssueTypesV1WithResponse request
	GetJiraIssueTypesV1WithResponse(ctx context.Context, integrationID IntegrationID, reqEditors ...RequestEditorFn) (*GetJiraIssueTypesV1Response, error)

	// CreateJiraIssueTypeV1WithBodyWithResponse request with any body
	CreateJiraIssueTypeV1WithBodyWithResponse(ctx context.Context, integrationID IntegrationID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJiraIssueTypeV1Response, error)

	CreateJiraIssueTypeV1WithResponse(ctx context.Context, integrationID IntegrationID, body CreateJiraIssueTypeV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJiraIssueTypeV1Response, error)

	// DeleteJiraIssueTypeV1WithResponse request
	DeleteJiraIssueTypeV1WithResponse(ctx context.Context, integrationID IntegrationID, issueTypeID IssueTypeID, reqEditors ...RequestEditorFn) (*DeleteJiraIssueTypeV1Response, error)

	// GetJiraIssueTypeV1WithResponse request
	GetJiraIssueTypeV1WithResponse(ctx context.Context, integrationID IntegrationID, issueTypeID IssueTypeID, reqEditors ...RequestEditorFn) (*GetJiraIssueTypeV1Response, error)

	// UpdateJiraIssueTypeV1WithBodyWithResponse request with any body
	UpdateJiraIssueTypeV1WithBodyWithResponse(ctx context.Context, integrationID IntegrationID, issueTypeID IssueTypeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateJiraIssueTypeV1Response, error)

	UpdateJiraIssueTypeV1WithResponse(ctx context.Context, integrationID IntegrationID, issueTypeID IssueTypeID, body UpdateJiraIssueTypeV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateJiraIssueTypeV1Response, error)

	// ListJobsV1WithResponse request
	ListJobsV1WithResponse(ctx context.Context, params *ListJobsV1Params, reqEditors ...RequestEditorFn) (*ListJobsV1Response, error)

	// ListSchedulesV1WithResponse request
	ListSchedulesV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSchedulesV1Response, error)

	// GetAccessKeysV1WithResponse request
	GetAccessKeysV1WithResponse(ctx context.Context, params *GetAccessKeysV1Params, reqEditors ...RequestEditorFn) (*GetAccessKeysV1Response, error)

	// CreateAccessKeyV1WithBodyWithResponse request with any body
	CreateAccessKeyV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccessKeyV1Response, error)

	CreateAccessKeyV1WithResponse(ctx context.Context, body CreateAccessKeyV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccessKeyV1Response, error)

	// DeleteAccessKeyByIdV1WithResponse request
	DeleteAccessKeyByIdV1WithResponse(ctx context.Context, accessKeyId AccessKeyIdPath, reqEditors ...RequestEditorFn) (*DeleteAccessKeyByIdV1Response, error)

	// GetAccessKeyByIdV1WithResponse request
	GetAccessKeyByIdV1WithResponse(ctx context.Context, accessKeyId AccessKeyIdPath, reqEditors ...RequestEditorFn) (*GetAccessKeyByIdV1Response, error)

	// UpdateAccessKeyByIdV1WithBodyWithResponse request with any body
	UpdateAccessKeyByIdV1WithBodyWithResponse(ctx context.Context, accessKeyId AccessKeyIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccessKeyByIdV1Response, error)

	UpdateAccessKeyByIdV1WithResponse(ctx context.Context, accessKeyId AccessKeyIdPath, body UpdateAccessKeyByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccessKeyByIdV1Response, error)

	// GetCaptureStorageConfigurationV1WithResponse request
	GetCaptureStorageConfigurationV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCaptureStorageConfigurationV1Response, error)

	// UpdateCaptureStorageConfigurationV1WithBodyWithResponse request with any body
	UpdateCaptureStorageConfigurationV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCaptureStorageConfigurationV1Response, error)

	UpdateCaptureStorageConfigurationV1WithResponse(ctx context.Context, body UpdateCaptureStorageConfigurationV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCaptureStorageConfigurationV1Response, error)

	// GetUserDeactivationConfigurationV1WithResponse request
	GetUserDeactivationConfigurationV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserDeactivationConfigurationV1Response, error)

	// UpdateUserDeactivationConfigurationByIdV1WithBodyWithResponse request with any body
	UpdateUserDeactivationConfigurationByIdV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserDeactivationConfigurationByIdV1Response, error)

	UpdateUserDeactivationConfigurationByIdV1WithResponse(ctx context.Context, body UpdateUserDeactivationConfigurationByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserDeactivationConfigurationByIdV1Response, error)

	// GetDefaultRoleByDisplayNameV1WithResponse request
	GetDefaultRoleByDisplayNameV1WithResponse(ctx context.Context, roleDisplayName GetDefaultRoleByDisplayNameV1ParamsRoleDisplayName, reqEditors ...RequestEditorFn) (*GetDefaultRoleByDisplayNameV1Response, error)

	// GetGlobaSsoSettingsV1WithResponse request
	GetGlobaSsoSettingsV1WithResponse(ctx context.Context, ssoProductId GetGlobaSsoSettingsV1ParamsSsoProductId, reqEditors ...RequestEditorFn) (*GetGlobaSsoSettingsV1Response, error)

	// UpdateGlobalSsoSettingsV1WithBodyWithResponse request with any body
	UpdateGlobalSsoSettingsV1WithBodyWithResponse(ctx context.Context, ssoProductId UpdateGlobalSsoSettingsV1ParamsSsoProductId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGlobalSsoSettingsV1Response, error)

	UpdateGlobalSsoSettingsV1WithResponse(ctx context.Context, ssoProductId UpdateGlobalSsoSettingsV1ParamsSsoProductId, body UpdateGlobalSsoSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGlobalSsoSettingsV1Response, error)

	// GetGroupMappingsV1WithResponse request
	GetGroupMappingsV1WithResponse(ctx context.Context, params *GetGroupMappingsV1Params, reqEditors ...RequestEditorFn) (*GetGroupMappingsV1Response, error)

	// CreateGroupMappingV1WithBodyWithResponse request with any body
	CreateGroupMappingV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupMappingV1Response, error)

	CreateGroupMappingV1WithResponse(ctx context.Context, body CreateGroupMappingV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupMappingV1Response, error)

	// GetGroupMappingSettingsV1WithResponse request
	GetGroupMappingSettingsV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGroupMappingSettingsV1Response, error)

	// SaveGroupMappingSettingsV1WithBodyWithResponse request with any body
	SaveGroupMappingSettingsV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveGroupMappingSettingsV1Response, error)

	SaveGroupMappingSettingsV1WithResponse(ctx context.Context, body SaveGroupMappingSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*SaveGroupMappingSettingsV1Response, error)

	// DeleteGroupMappingByIdV1WithResponse request
	DeleteGroupMappingByIdV1WithResponse(ctx context.Context, groupMappingId GroupMappingIdPath, reqEditors ...RequestEditorFn) (*DeleteGroupMappingByIdV1Response, error)

	// GetGroupMappingByIdV1WithResponse request
	GetGroupMappingByIdV1WithResponse(ctx context.Context, groupMappingId GroupMappingIdPath, reqEditors ...RequestEditorFn) (*GetGroupMappingByIdV1Response, error)

	// UpdateGroupMappingByIdV1WithBodyWithResponse request with any body
	UpdateGroupMappingByIdV1WithBodyWithResponse(ctx context.Context, groupMappingId GroupMappingIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupMappingByIdV1Response, error)

	UpdateGroupMappingByIdV1WithResponse(ctx context.Context, groupMappingId GroupMappingIdPath, body UpdateGroupMappingByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupMappingByIdV1Response, error)

	// GetIpFiltersV1WithResponse request
	GetIpFiltersV1WithResponse(ctx context.Context, params *GetIpFiltersV1Params, reqEditors ...RequestEditorFn) (*GetIpFiltersV1Response, error)

	// CreateIpFilterV1WithBodyWithResponse request with any body
	CreateIpFilterV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIpFilterV1Response, error)

	CreateIpFilterV1WithResponse(ctx context.Context, body CreateIpFilterV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIpFilterV1Response, error)

	// GetIpFiltersSettingsV1WithResponse request
	GetIpFiltersSettingsV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetIpFiltersSettingsV1Response, error)

	// SaveIpFiltersSettingsV1WithBodyWithResponse request with any body
	SaveIpFiltersSettingsV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveIpFiltersSettingsV1Response, error)

	SaveIpFiltersSettingsV1WithResponse(ctx context.Context, body SaveIpFiltersSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*SaveIpFiltersSettingsV1Response, error)

	// DeleteIpFilterByIdV1WithResponse request
	DeleteIpFilterByIdV1WithResponse(ctx context.Context, ipFilterId IpFilterIdPath, reqEditors ...RequestEditorFn) (*DeleteIpFilterByIdV1Response, error)

	// GetIpFilterByIdV1WithResponse request
	GetIpFilterByIdV1WithResponse(ctx context.Context, ipFilterId IpFilterIdPath, reqEditors ...RequestEditorFn) (*GetIpFilterByIdV1Response, error)

	// UpdateIpFilterV1WithBodyWithResponse request with any body
	UpdateIpFilterV1WithBodyWithResponse(ctx context.Context, ipFilterId IpFilterIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateIpFilterV1Response, error)

	UpdateIpFilterV1WithResponse(ctx context.Context, ipFilterId IpFilterIdPath, body UpdateIpFilterV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateIpFilterV1Response, error)

	// GetNotificationChannelsWithResponse request
	GetNotificationChannelsWithResponse(ctx context.Context, params *GetNotificationChannelsParams, reqEditors ...RequestEditorFn) (*GetNotificationChannelsResponse, error)

	// CreateNotificationChannelWithBodyWithResponse request with any body
	CreateNotificationChannelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNotificationChannelResponse, error)

	CreateNotificationChannelWithResponse(ctx context.Context, body CreateNotificationChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNotificationChannelResponse, error)

	// DeleteNotificationChannelByIdWithResponse request
	DeleteNotificationChannelByIdWithResponse(ctx context.Context, notificationChannelID NotificationChannelID, reqEditors ...RequestEditorFn) (*DeleteNotificationChannelByIdResponse, error)

	// GetNotificationChannelByIdWithResponse request
	GetNotificationChannelByIdWithResponse(ctx context.Context, notificationChannelID NotificationChannelID, reqEditors ...RequestEditorFn) (*GetNotificationChannelByIdResponse, error)

	// UpdateNotificationChannelByIdWithBodyWithResponse request with any body
	UpdateNotificationChannelByIdWithBodyWithResponse(ctx context.Context, notificationChannelID NotificationChannelID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNotificationChannelByIdResponse, error)

	UpdateNotificationChannelByIdWithResponse(ctx context.Context, notificationChannelID NotificationChannelID, body UpdateNotificationChannelByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNotificationChannelByIdResponse, error)

	// GetPermissionsV1WithResponse request
	GetPermissionsV1WithResponse(ctx context.Context, params *GetPermissionsV1Params, reqEditors ...RequestEditorFn) (*GetPermissionsV1Response, error)

	// GetPlatformAuditEventsV1WithResponse request
	GetPlatformAuditEventsV1WithResponse(ctx context.Context, params *GetPlatformAuditEventsV1Params, reqEditors ...RequestEditorFn) (*GetPlatformAuditEventsV1Response, error)

	// GetRolesV1WithResponse request
	GetRolesV1WithResponse(ctx context.Context, params *GetRolesV1Params, reqEditors ...RequestEditorFn) (*GetRolesV1Response, error)

	// CreateRoleV1WithBodyWithResponse request with any body
	CreateRoleV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleV1Response, error)

	CreateRoleV1WithResponse(ctx context.Context, body CreateRoleV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleV1Response, error)

	// DeleteRoleByIdV1WithResponse request
	DeleteRoleByIdV1WithResponse(ctx context.Context, roleId RoleIdPath, reqEditors ...RequestEditorFn) (*DeleteRoleByIdV1Response, error)

	// GetRoleByIdV1WithResponse request
	GetRoleByIdV1WithResponse(ctx context.Context, roleId RoleIdPath, reqEditors ...RequestEditorFn) (*GetRoleByIdV1Response, error)

	// UpdateRoleByIdV1WithBodyWithResponse request with any body
	UpdateRoleByIdV1WithBodyWithResponse(ctx context.Context, roleId RoleIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleByIdV1Response, error)

	UpdateRoleByIdV1WithResponse(ctx context.Context, roleId RoleIdPath, body UpdateRoleByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleByIdV1Response, error)

	// GetGlobalServiceAccountsV1WithResponse request
	GetGlobalServiceAccountsV1WithResponse(ctx context.Context, params *GetGlobalServiceAccountsV1Params, reqEditors ...RequestEditorFn) (*GetGlobalServiceAccountsV1Response, error)

	// CreateGlobalServiceAccountV1WithBodyWithResponse request with any body
	CreateGlobalServiceAccountV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGlobalServiceAccountV1Response, error)

	CreateGlobalServiceAccountV1WithResponse(ctx context.Context, body CreateGlobalServiceAccountV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGlobalServiceAccountV1Response, error)

	// DeleteGlobalServiceAccountsNotificationSettingsV1WithResponse request
	DeleteGlobalServiceAccountsNotificationSettingsV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteGlobalServiceAccountsNotificationSettingsV1Response, error)

	// GetGlobalServiceAccountsNotificationSettingsV1WithResponse request
	GetGlobalServiceAccountsNotificationSettingsV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGlobalServiceAccountsNotificationSettingsV1Response, error)

	// CreateGlobalServiceAccountsNotificationSettingsV1WithBodyWithResponse request with any body
	CreateGlobalServiceAccountsNotificationSettingsV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGlobalServiceAccountsNotificationSettingsV1Response, error)

	CreateGlobalServiceAccountsNotificationSettingsV1WithResponse(ctx context.Context, body CreateGlobalServiceAccountsNotificationSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGlobalServiceAccountsNotificationSettingsV1Response, error)

	// UpdateGlobalServiceAccountsNotificationSettingsV1WithBodyWithResponse request with any body
	UpdateGlobalServiceAccountsNotificationSettingsV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGlobalServiceAccountsNotificationSettingsV1Response, error)

	UpdateGlobalServiceAccountsNotificationSettingsV1WithResponse(ctx context.Context, body UpdateGlobalServiceAccountsNotificationSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGlobalServiceAccountsNotificationSettingsV1Response, error)

	// DeleteGlobalServiceAccountByIdV1WithResponse request
	DeleteGlobalServiceAccountByIdV1WithResponse(ctx context.Context, serviceAccountId ServiceAccountIdPath, reqEditors ...RequestEditorFn) (*DeleteGlobalServiceAccountByIdV1Response, error)

	// GetGlobalServiceAccountByIdV1WithResponse request
	GetGlobalServiceAccountByIdV1WithResponse(ctx context.Context, serviceAccountId ServiceAccountIdPath, reqEditors ...RequestEditorFn) (*GetGlobalServiceAccountByIdV1Response, error)

	// GetSsoSettingsV1WithResponse request
	GetSsoSettingsV1WithResponse(ctx context.Context, params *GetSsoSettingsV1Params, reqEditors ...RequestEditorFn) (*GetSsoSettingsV1Response, error)

	// CreateSsoSettingsV1WithBodyWithResponse request with any body
	CreateSsoSettingsV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSsoSettingsV1Response, error)

	CreateSsoSettingsV1WithResponse(ctx context.Context, body CreateSsoSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSsoSettingsV1Response, error)

	// DeleteSsoSettingsByIdV1WithResponse request
	DeleteSsoSettingsByIdV1WithResponse(ctx context.Context, ssoSettingsId SsoSettingsIdPath, reqEditors ...RequestEditorFn) (*DeleteSsoSettingsByIdV1Response, error)

	// GetSsoSettingsByIdV1WithResponse request
	GetSsoSettingsByIdV1WithResponse(ctx context.Context, ssoSettingsId SsoSettingsIdPath, reqEditors ...RequestEditorFn) (*GetSsoSettingsByIdV1Response, error)

	// UpdateSsoSettingsByIdV1WithBodyWithResponse request with any body
	UpdateSsoSettingsByIdV1WithBodyWithResponse(ctx context.Context, ssoSettingsId SsoSettingsIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSsoSettingsByIdV1Response, error)

	UpdateSsoSettingsByIdV1WithResponse(ctx context.Context, ssoSettingsId SsoSettingsIdPath, body UpdateSsoSettingsByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSsoSettingsByIdV1Response, error)

	// GetTeamsV1WithResponse request
	GetTeamsV1WithResponse(ctx context.Context, params *GetTeamsV1Params, reqEditors ...RequestEditorFn) (*GetTeamsV1Response, error)

	// CreateTeamV1WithBodyWithResponse request with any body
	CreateTeamV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTeamV1Response, error)

	CreateTeamV1WithResponse(ctx context.Context, body CreateTeamV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTeamV1Response, error)

	// DeleteTeamByIdV1WithResponse request
	DeleteTeamByIdV1WithResponse(ctx context.Context, teamId TeamIdPath, reqEditors ...RequestEditorFn) (*DeleteTeamByIdV1Response, error)

	// GetTeamByIdV1WithResponse request
	GetTeamByIdV1WithResponse(ctx context.Context, teamId TeamIdPath, reqEditors ...RequestEditorFn) (*GetTeamByIdV1Response, error)

	// UpdateTeamByIdV1WithBodyWithResponse request with any body
	UpdateTeamByIdV1WithBodyWithResponse(ctx context.Context, teamId TeamIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTeamByIdV1Response, error)

	UpdateTeamByIdV1WithResponse(ctx context.Context, teamId TeamIdPath, body UpdateTeamByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTeamByIdV1Response, error)

	// GetTeamServiceAccountsV1WithResponse request
	GetTeamServiceAccountsV1WithResponse(ctx context.Context, teamId TeamIdPath, params *GetTeamServiceAccountsV1Params, reqEditors ...RequestEditorFn) (*GetTeamServiceAccountsV1Response, error)

	// CreateTeamServiceAccountV1WithBodyWithResponse request with any body
	CreateTeamServiceAccountV1WithBodyWithResponse(ctx context.Context, teamId TeamIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTeamServiceAccountV1Response, error)

	CreateTeamServiceAccountV1WithResponse(ctx context.Context, teamId TeamIdPath, body CreateTeamServiceAccountV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTeamServiceAccountV1Response, error)

	// DeleteServiceAccountsNotificationSettingsV1WithResponse request
	DeleteServiceAccountsNotificationSettingsV1WithResponse(ctx context.Context, teamId TeamIdPath, reqEditors ...RequestEditorFn) (*DeleteServiceAccountsNotificationSettingsV1Response, error)

	// GetServiceAccountsNotificationSettingsV1WithResponse request
	GetServiceAccountsNotificationSettingsV1WithResponse(ctx context.Context, teamId TeamIdPath, reqEditors ...RequestEditorFn) (*GetServiceAccountsNotificationSettingsV1Response, error)

	// CreateServiceAccountsNotificationSettingsV1WithBodyWithResponse request with any body
	CreateServiceAccountsNotificationSettingsV1WithBodyWithResponse(ctx context.Context, teamId TeamIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceAccountsNotificationSettingsV1Response, error)

	CreateServiceAccountsNotificationSettingsV1WithResponse(ctx context.Context, teamId TeamIdPath, body CreateServiceAccountsNotificationSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceAccountsNotificationSettingsV1Response, error)

	// UpdateServiceAccountsNotificationSettingsV1WithBodyWithResponse request with any body
	UpdateServiceAccountsNotificationSettingsV1WithBodyWithResponse(ctx context.Context, teamId TeamIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceAccountsNotificationSettingsV1Response, error)

	UpdateServiceAccountsNotificationSettingsV1WithResponse(ctx context.Context, teamId TeamIdPath, body UpdateServiceAccountsNotificationSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceAccountsNotificationSettingsV1Response, error)

	// DeleteTeamServiceAccountByIdV1WithResponse request
	DeleteTeamServiceAccountByIdV1WithResponse(ctx context.Context, teamId TeamIdPath, serviceAccountId ServiceAccountIdPath, reqEditors ...RequestEditorFn) (*DeleteTeamServiceAccountByIdV1Response, error)

	// GetTeamServiceAccountByIdV1WithResponse request
	GetTeamServiceAccountByIdV1WithResponse(ctx context.Context, teamId TeamIdPath, serviceAccountId ServiceAccountIdPath, reqEditors ...RequestEditorFn) (*GetTeamServiceAccountByIdV1Response, error)

	// GetTeamUsersV1WithResponse request
	GetTeamUsersV1WithResponse(ctx context.Context, teamId TeamIdPath, params *GetTeamUsersV1Params, reqEditors ...RequestEditorFn) (*GetTeamUsersV1Response, error)

	// DeleteTeamUserByIdV1WithResponse request
	DeleteTeamUserByIdV1WithResponse(ctx context.Context, teamId TeamIdPath, userId UserIdPath, reqEditors ...RequestEditorFn) (*DeleteTeamUserByIdV1Response, error)

	// GetTeamUserByIdV1WithResponse request
	GetTeamUserByIdV1WithResponse(ctx context.Context, teamId TeamIdPath, userId UserIdPath, reqEditors ...RequestEditorFn) (*GetTeamUserByIdV1Response, error)

	// SaveTeamUserV1WithBodyWithResponse request with any body
	SaveTeamUserV1WithBodyWithResponse(ctx context.Context, teamId TeamIdPath, userId UserIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveTeamUserV1Response, error)

	SaveTeamUserV1WithResponse(ctx context.Context, teamId TeamIdPath, userId UserIdPath, body SaveTeamUserV1JSONRequestBody, reqEditors ...RequestEditorFn) (*SaveTeamUserV1Response, error)

	// GetUsersV1WithResponse request
	GetUsersV1WithResponse(ctx context.Context, params *GetUsersV1Params, reqEditors ...RequestEditorFn) (*GetUsersV1Response, error)

	// CreateUserV1WithBodyWithResponse request with any body
	CreateUserV1WithBodyWithResponse(ctx context.Context, params *CreateUserV1Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserV1Response, error)

	CreateUserV1WithResponse(ctx context.Context, params *CreateUserV1Params, body CreateUserV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserV1Response, error)

	// DeleteUserByIdV1WithResponse request
	DeleteUserByIdV1WithResponse(ctx context.Context, userId UserIdPath, reqEditors ...RequestEditorFn) (*DeleteUserByIdV1Response, error)

	// GetUserByIdV1WithResponse request
	GetUserByIdV1WithResponse(ctx context.Context, userId UserIdPath, reqEditors ...RequestEditorFn) (*GetUserByIdV1Response, error)

	// UpdateUserV1WithBodyWithResponse request with any body
	UpdateUserV1WithBodyWithResponse(ctx context.Context, userId UserIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserV1Response, error)

	UpdateUserV1WithResponse(ctx context.Context, userId UserIdPath, body UpdateUserV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserV1Response, error)

	// ListZonesV1WithResponse request
	ListZonesV1WithResponse(ctx context.Context, params *ListZonesV1Params, reqEditors ...RequestEditorFn) (*ListZonesV1Response, error)

	// CreateZoneV1WithBodyWithResponse request with any body
	CreateZoneV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateZoneV1Response, error)

	CreateZoneV1WithResponse(ctx context.Context, body CreateZoneV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateZoneV1Response, error)

	// DeleteZoneV1WithResponse request
	DeleteZoneV1WithResponse(ctx context.Context, zoneId ZoneId, reqEditors ...RequestEditorFn) (*DeleteZoneV1Response, error)

	// GetZoneByIdV1WithResponse request
	GetZoneByIdV1WithResponse(ctx context.Context, zoneId ZoneId, reqEditors ...RequestEditorFn) (*GetZoneByIdV1Response, error)

	// EditZoneV1WithBodyWithResponse request with any body
	EditZoneV1WithBodyWithResponse(ctx context.Context, zoneId ZoneId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditZoneV1Response, error)

	EditZoneV1WithResponse(ctx context.Context, zoneId ZoneId, body EditZoneV1JSONRequestBody, reqEditors ...RequestEditorFn) (*EditZoneV1Response, error)

	// GetActivityAuditEntriesV1WithResponse request
	GetActivityAuditEntriesV1WithResponse(ctx context.Context, params *GetActivityAuditEntriesV1Params, reqEditors ...RequestEditorFn) (*GetActivityAuditEntriesV1Response, error)

	// GetActivityAuditEntryV1WithResponse request
	GetActivityAuditEntryV1WithResponse(ctx context.Context, entryId EntryId, reqEditors ...RequestEditorFn) (*GetActivityAuditEntryV1Response, error)

	// GetActivityAuditEntriesSupportedFiltersV1WithResponse request
	GetActivityAuditEntriesSupportedFiltersV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetActivityAuditEntriesSupportedFiltersV1Response, error)

	// GetCertificatesV1WithResponse request
	GetCertificatesV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCertificatesV1Response, error)

	// UploadCertificateV1WithBodyWithResponse request with any body
	UploadCertificateV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadCertificateV1Response, error)

	// DeleteCertificateV1WithResponse request
	DeleteCertificateV1WithResponse(ctx context.Context, certId PathCertificateId, reqEditors ...RequestEditorFn) (*DeleteCertificateV1Response, error)

	// GetCertificateV1WithResponse request
	GetCertificateV1WithResponse(ctx context.Context, certId PathCertificateId, reqEditors ...RequestEditorFn) (*GetCertificateV1Response, error)

	// GetCertificateRegistrationV1WithResponse request
	GetCertificateRegistrationV1WithResponse(ctx context.Context, certId PathCertificateId, reqEditors ...RequestEditorFn) (*GetCertificateRegistrationV1Response, error)

	// CreateCSRV1WithResponse request
	CreateCSRV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateCSRV1Response, error)

	// ListEFOChannelsByIntegrationV1WithResponse request
	ListEFOChannelsByIntegrationV1WithResponse(ctx context.Context, params *ListEFOChannelsByIntegrationV1Params, reqEditors ...RequestEditorFn) (*ListEFOChannelsByIntegrationV1Response, error)

	// ListEFOIntegrationsV1WithResponse request
	ListEFOIntegrationsV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListEFOIntegrationsV1Response, error)

	// CreateEFOIntegrationV1WithBodyWithResponse request with any body
	CreateEFOIntegrationV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEFOIntegrationV1Response, error)

	CreateEFOIntegrationV1WithResponse(ctx context.Context, body CreateEFOIntegrationV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEFOIntegrationV1Response, error)

	// DeleteEFOIntegrationByIdV1WithResponse request
	DeleteEFOIntegrationByIdV1WithResponse(ctx context.Context, integrationId IntegrationId, reqEditors ...RequestEditorFn) (*DeleteEFOIntegrationByIdV1Response, error)

	// GetEFOIntegrationByIdV1WithResponse request
	GetEFOIntegrationByIdV1WithResponse(ctx context.Context, integrationId IntegrationId, reqEditors ...RequestEditorFn) (*GetEFOIntegrationByIdV1Response, error)

	// UpdateEFOIntegrationByIdV1WithBodyWithResponse request with any body
	UpdateEFOIntegrationByIdV1WithBodyWithResponse(ctx context.Context, integrationId IntegrationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEFOIntegrationByIdV1Response, error)

	UpdateEFOIntegrationByIdV1WithResponse(ctx context.Context, integrationId IntegrationId, body UpdateEFOIntegrationByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEFOIntegrationByIdV1Response, error)

	// ListEFOIntegrationsTypesV1WithResponse request
	ListEFOIntegrationsTypesV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListEFOIntegrationsTypesV1Response, error)

	// ListEFOChannelsByIntegrationV2WithResponse request
	ListEFOChannelsByIntegrationV2WithResponse(ctx context.Context, params *ListEFOChannelsByIntegrationV2Params, reqEditors ...RequestEditorFn) (*ListEFOChannelsByIntegrationV2Response, error)

	// ListEFOIntegrationsV2WithResponse request
	ListEFOIntegrationsV2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListEFOIntegrationsV2Response, error)

	// CreateEFOIntegrationV2WithBodyWithResponse request with any body
	CreateEFOIntegrationV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEFOIntegrationV2Response, error)

	CreateEFOIntegrationV2WithResponse(ctx context.Context, body CreateEFOIntegrationV2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEFOIntegrationV2Response, error)

	// DeleteEFOIntegrationByIdV2WithResponse request
	DeleteEFOIntegrationByIdV2WithResponse(ctx context.Context, integrationId IntegrationId, reqEditors ...RequestEditorFn) (*DeleteEFOIntegrationByIdV2Response, error)

	// GetEFOIntegrationByIdV2WithResponse request
	GetEFOIntegrationByIdV2WithResponse(ctx context.Context, integrationId IntegrationId, reqEditors ...RequestEditorFn) (*GetEFOIntegrationByIdV2Response, error)

	// UpdateEFOIntegrationByIdV2WithBodyWithResponse request with any body
	UpdateEFOIntegrationByIdV2WithBodyWithResponse(ctx context.Context, integrationId IntegrationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEFOIntegrationByIdV2Response, error)

	UpdateEFOIntegrationByIdV2WithResponse(ctx context.Context, integrationId IntegrationId, body UpdateEFOIntegrationByIdV2JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEFOIntegrationByIdV2Response, error)

	// ListEFOIntegrationsTypesV2WithResponse request
	ListEFOIntegrationsTypesV2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListEFOIntegrationsTypesV2Response, error)

	// GetEventsV1WithResponse request
	GetEventsV1WithResponse(ctx context.Context, params *GetEventsV1Params, reqEditors ...RequestEditorFn) (*GetEventsV1Response, error)

	// GetEventV1WithResponse request
	GetEventV1WithResponse(ctx context.Context, eventId EventId, reqEditors ...RequestEditorFn) (*GetEventV1Response, error)

	// GetEventsSupportedFiltersV1WithResponse request
	GetEventsSupportedFiltersV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEventsSupportedFiltersV1Response, error)

	// GetResourcesWithResponse request
	GetResourcesWithResponse(ctx context.Context, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*GetResourcesResponse, error)

	// GetResourceWithResponse request
	GetResourceWithResponse(ctx context.Context, hash string, reqEditors ...RequestEditorFn) (*GetResourceResponse, error)

	// GetActionExecutionsv1WithResponse request
	GetActionExecutionsv1WithResponse(ctx context.Context, params *GetActionExecutionsv1Params, reqEditors ...RequestEditorFn) (*GetActionExecutionsv1Response, error)

	// SubmitActionExecutionv1WithBodyWithResponse request with any body
	SubmitActionExecutionv1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitActionExecutionv1Response, error)

	SubmitActionExecutionv1WithResponse(ctx context.Context, body SubmitActionExecutionv1JSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitActionExecutionv1Response, error)

	// UndoActionExecutionV1WithResponse request
	UndoActionExecutionV1WithResponse(ctx context.Context, actionExecutionId ActionExecutionId, params *UndoActionExecutionV1Params, reqEditors ...RequestEditorFn) (*UndoActionExecutionV1Response, error)

	// GetActionExecutionV1WithResponse request
	GetActionExecutionV1WithResponse(ctx context.Context, actionExecutionId ActionExecutionId, reqEditors ...RequestEditorFn) (*GetActionExecutionV1Response, error)

	// GetActionExecutionFileAcquireV1WithResponse request
	GetActionExecutionFileAcquireV1WithResponse(ctx context.Context, actionExecutionId ActionExecutionId, reqEditors ...RequestEditorFn) (*GetActionExecutionFileAcquireV1Response, error)

	// GetActionsV1WithResponse request
	GetActionsV1WithResponse(ctx context.Context, params *GetActionsV1Params, reqEditors ...RequestEditorFn) (*GetActionsV1Response, error)

	// GetSecureVulnerabilityV1BundlesWithResponse request
	GetSecureVulnerabilityV1BundlesWithResponse(ctx context.Context, params *GetSecureVulnerabilityV1BundlesParams, reqEditors ...RequestEditorFn) (*GetSecureVulnerabilityV1BundlesResponse, error)

	// PostSecureVulnerabilityV1BundlesWithBodyWithResponse request with any body
	PostSecureVulnerabilityV1BundlesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSecureVulnerabilityV1BundlesResponse, error)

	PostSecureVulnerabilityV1BundlesWithResponse(ctx context.Context, body PostSecureVulnerabilityV1BundlesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSecureVulnerabilityV1BundlesResponse, error)

	// DeleteSecureVulnerabilityV1BundlesBundleIdWithResponse request
	DeleteSecureVulnerabilityV1BundlesBundleIdWithResponse(ctx context.Context, bundleId int64, reqEditors ...RequestEditorFn) (*DeleteSecureVulnerabilityV1BundlesBundleIdResponse, error)

	// GetSecureVulnerabilityV1BundlesBundleIdWithResponse request
	GetSecureVulnerabilityV1BundlesBundleIdWithResponse(ctx context.Context, bundleId int64, reqEditors ...RequestEditorFn) (*GetSecureVulnerabilityV1BundlesBundleIdResponse, error)

	// PutSecureVulnerabilityV1BundlesBundleIdWithBodyWithResponse request with any body
	PutSecureVulnerabilityV1BundlesBundleIdWithBodyWithResponse(ctx context.Context, bundleId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutSecureVulnerabilityV1BundlesBundleIdResponse, error)

	PutSecureVulnerabilityV1BundlesBundleIdWithResponse(ctx context.Context, bundleId int64, body PutSecureVulnerabilityV1BundlesBundleIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutSecureVulnerabilityV1BundlesBundleIdResponse, error)

	// GetSecureVulnerabilityV1PipelineResultsWithResponse request
	GetSecureVulnerabilityV1PipelineResultsWithResponse(ctx context.Context, params *GetSecureVulnerabilityV1PipelineResultsParams, reqEditors ...RequestEditorFn) (*GetSecureVulnerabilityV1PipelineResultsResponse, error)

	// GetSecureVulnerabilityV1PoliciesWithResponse request
	GetSecureVulnerabilityV1PoliciesWithResponse(ctx context.Context, params *GetSecureVulnerabilityV1PoliciesParams, reqEditors ...RequestEditorFn) (*GetSecureVulnerabilityV1PoliciesResponse, error)

	// PostSecureVulnerabilityV1PoliciesWithBodyWithResponse request with any body
	PostSecureVulnerabilityV1PoliciesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSecureVulnerabilityV1PoliciesResponse, error)

	PostSecureVulnerabilityV1PoliciesWithResponse(ctx context.Context, body PostSecureVulnerabilityV1PoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSecureVulnerabilityV1PoliciesResponse, error)

	// DeleteSecureVulnerabilityV1PoliciesPolicyIdWithResponse request
	DeleteSecureVulnerabilityV1PoliciesPolicyIdWithResponse(ctx context.Context, policyId int64, reqEditors ...RequestEditorFn) (*DeleteSecureVulnerabilityV1PoliciesPolicyIdResponse, error)

	// GetSecureVulnerabilityV1PoliciesPolicyIdWithResponse request
	GetSecureVulnerabilityV1PoliciesPolicyIdWithResponse(ctx context.Context, policyId int64, reqEditors ...RequestEditorFn) (*GetSecureVulnerabilityV1PoliciesPolicyIdResponse, error)

	// PutSecureVulnerabilityV1PoliciesPolicyIdWithBodyWithResponse request with any body
	PutSecureVulnerabilityV1PoliciesPolicyIdWithBodyWithResponse(ctx context.Context, policyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutSecureVulnerabilityV1PoliciesPolicyIdResponse, error)

	PutSecureVulnerabilityV1PoliciesPolicyIdWithResponse(ctx context.Context, policyId int64, body PutSecureVulnerabilityV1PoliciesPolicyIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutSecureVulnerabilityV1PoliciesPolicyIdResponse, error)

	// ScannerAPIServiceListRegistryResultsWithResponse request
	ScannerAPIServiceListRegistryResultsWithResponse(ctx context.Context, params *ScannerAPIServiceListRegistryResultsParams, reqEditors ...RequestEditorFn) (*ScannerAPIServiceListRegistryResultsResponse, error)

	// GetSecureVulnerabilityV1ResultsResultIdWithResponse request
	GetSecureVulnerabilityV1ResultsResultIdWithResponse(ctx context.Context, resultId string, reqEditors ...RequestEditorFn) (*GetSecureVulnerabilityV1ResultsResultIdResponse, error)

	// ScannerAPIServiceListRuntimeResultsWithResponse request
	ScannerAPIServiceListRuntimeResultsWithResponse(ctx context.Context, params *ScannerAPIServiceListRuntimeResultsParams, reqEditors ...RequestEditorFn) (*ScannerAPIServiceListRuntimeResultsResponse, error)

	// GetAcceptedRisksV1WithResponse request
	GetAcceptedRisksV1WithResponse(ctx context.Context, params *GetAcceptedRisksV1Params, reqEditors ...RequestEditorFn) (*GetAcceptedRisksV1Response, error)

	// PostAcceptedRiskV1WithBodyWithResponse request with any body
	PostAcceptedRiskV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAcceptedRiskV1Response, error)

	PostAcceptedRiskV1WithResponse(ctx context.Context, body PostAcceptedRiskV1JSONRequestBody, reqEditors ...RequestEditorFn) (*PostAcceptedRiskV1Response, error)

	// DeleteAcceptedRiskV1WithResponse request
	DeleteAcceptedRiskV1WithResponse(ctx context.Context, acceptedRiskID AcceptedRiskID, reqEditors ...RequestEditorFn) (*DeleteAcceptedRiskV1Response, error)

	// GetAcceptedRiskV1WithResponse request
	GetAcceptedRiskV1WithResponse(ctx context.Context, acceptedRiskID AcceptedRiskID, reqEditors ...RequestEditorFn) (*GetAcceptedRiskV1Response, error)

	// UpdateAcceptedRiskV1WithBodyWithResponse request with any body
	UpdateAcceptedRiskV1WithBodyWithResponse(ctx context.Context, acceptedRiskID AcceptedRiskID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAcceptedRiskV1Response, error)

	UpdateAcceptedRiskV1WithResponse(ctx context.Context, acceptedRiskID AcceptedRiskID, body UpdateAcceptedRiskV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAcceptedRiskV1Response, error)

	// GetSBOMV1beta1WithResponse request
	GetSBOMV1beta1WithResponse(ctx context.Context, params *GetSBOMV1beta1Params, reqEditors ...RequestEditorFn) (*GetSBOMV1beta1Response, error)
}

type QuerySysqlGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QueryResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r QuerySysqlGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QuerySysqlGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type QuerySysqlPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *QueryResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r QuerySysqlPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r QuerySysqlPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSysqlSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSysqlSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSysqlSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInhibitionRulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetInhibitionRulesPaginatedResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetInhibitionRulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInhibitionRulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateInhibitionRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *InhibitionRuleResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateInhibitionRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateInhibitionRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteInhibitionRuleByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteInhibitionRuleByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteInhibitionRuleByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInhibitionRuleByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InhibitionRuleResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetInhibitionRuleByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInhibitionRuleByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateInhibitionRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InhibitionRuleResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON409      *Conflict
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateInhibitionRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateInhibitionRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPricingV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPricingPaginatedResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPricingV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPricingV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePricingV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *PricingResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON409      *Conflict
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreatePricingV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePricingV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePricingByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeletePricingByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePricingByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPricingByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PricingResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPricingByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPricingByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePricingByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PricingResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON409      *Conflict
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdatePricingByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePricingByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPricingProjectedCostsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPricingProjectedPaginatedResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPricingProjectedCostsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPricingProjectedCostsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWastedWorkloadDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WastedWorkloadSpendDataResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetWastedWorkloadDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWastedWorkloadDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkloadCostDataV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkloadCostTrendsDataResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetWorkloadCostDataV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkloadCostDataV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWorkloadRightsizingDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WorkloadRightsizingDataResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetWorkloadRightsizingDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkloadRightsizingDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMonitorEventsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListMonitorEventsResponse
	JSON400      *Error
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetMonitorEventsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMonitorEventsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDisabledMetricsByJobV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseListDisabledMetricsV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDisabledMetricsByJobV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDisabledMetricsByJobV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDisabledMetricsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseListDisabledMetricsV1
	JSON207      *ResponseListDisabledMetricsAndErrorV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostDisabledMetricsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDisabledMetricsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomPrometheusJobsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCustomJobsPaginatedResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCustomPrometheusJobsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomPrometheusJobsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomPrometheusJobByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteCustomPrometheusJobByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomPrometheusJobByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomPrometheusJobByNameV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	YAML200      *CustomJobContentV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCustomPrometheusJobByNameV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomPrometheusJobByNameV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCustomPrometheusJobV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	YAML201      *CustomJobContentV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON409      *Conflict
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateCustomPrometheusJobV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomPrometheusJobV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCustomPrometheusJobByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	YAML200      *CustomJobContentV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON409      *Conflict
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateCustomPrometheusJobByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCustomPrometheusJobByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomPrometheusJobEnablementV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomJobsEnablementV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCustomPrometheusJobEnablementV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomPrometheusJobEnablementV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCustomPrometheusJobEnablementV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomJobsEnablementV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON409      *Conflict
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateCustomPrometheusJobEnablementV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCustomPrometheusJobEnablementV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJiraIntegrationsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PaginatedIntegrationsResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetJiraIntegrationsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJiraIntegrationsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateJiraIntegrationV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IntegrationResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateJiraIntegrationV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateJiraIntegrationV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteJiraIntegrationV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteJiraIntegrationV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteJiraIntegrationV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJiraIntegrationV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetJiraIntegrationV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJiraIntegrationV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateJiraIntegrationV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateJiraIntegrationV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateJiraIntegrationV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJiraIssueTypesV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IssueTypesResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetJiraIssueTypesV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJiraIssueTypesV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateJiraIssueTypeV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IssueTypeResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateJiraIssueTypeV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateJiraIssueTypeV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteJiraIssueTypeV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteJiraIssueTypeV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteJiraIssueTypeV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJiraIssueTypeV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IssueTypeResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetJiraIssueTypeV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJiraIssueTypeV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateJiraIssueTypeV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IssueTypeResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateJiraIssueTypeV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateJiraIssueTypeV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListJobsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListJobs
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListJobsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJobsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSchedulesV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListSchedules
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListSchedulesV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSchedulesV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccessKeysV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAccessKeysPaginatedResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAccessKeysV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccessKeysV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAccessKeyV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AccessKeyResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateAccessKeyV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAccessKeyV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAccessKeyByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteAccessKeyByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAccessKeyByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccessKeyByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccessKeyResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAccessKeyByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccessKeyByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAccessKeyByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccessKeyResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *Conflict
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateAccessKeyByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAccessKeyByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCaptureStorageConfigurationV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CaptureStorageConfigurationResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCaptureStorageConfigurationV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCaptureStorageConfigurationV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCaptureStorageConfigurationV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CaptureStorageConfigurationResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateCaptureStorageConfigurationV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCaptureStorageConfigurationV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserDeactivationConfigurationV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserDeactivationConfigurationResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserDeactivationConfigurationV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserDeactivationConfigurationV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserDeactivationConfigurationByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserDeactivationConfigurationResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON415      *UnsupportedMediaType
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateUserDeactivationConfigurationByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserDeactivationConfigurationByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDefaultRoleByDisplayNameV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DefaultRoleResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetDefaultRoleByDisplayNameV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDefaultRoleByDisplayNameV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGlobaSsoSettingsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalSsoSettingsResponseV1
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGlobaSsoSettingsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGlobaSsoSettingsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGlobalSsoSettingsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GlobalSsoSettingsResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateGlobalSsoSettingsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGlobalSsoSettingsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupMappingsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupMappingsPaginatedResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupMappingsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupMappingsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGroupMappingV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GroupMappingResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON409      *Conflict
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateGroupMappingV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGroupMappingV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupMappingSettingsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupMappingSettingsV1
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupMappingSettingsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupMappingSettingsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveGroupMappingSettingsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupMappingSettingsV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SaveGroupMappingSettingsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveGroupMappingSettingsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupMappingByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteGroupMappingByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupMappingByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupMappingByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupMappingResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGroupMappingByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupMappingByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGroupMappingByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GroupMappingResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateGroupMappingByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGroupMappingByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIpFiltersV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IpFiltersPaginatedResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetIpFiltersV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIpFiltersV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateIpFilterV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IpFilterResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON409      *Conflict
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateIpFilterV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateIpFilterV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIpFiltersSettingsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IpFiltersSettingsV1
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetIpFiltersSettingsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIpFiltersSettingsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveIpFiltersSettingsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IpFiltersSettingsV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON409      *Conflict
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SaveIpFiltersSettingsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveIpFiltersSettingsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteIpFilterByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteIpFilterByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteIpFilterByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetIpFilterByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IpFilterResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetIpFilterByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetIpFilterByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateIpFilterV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IpFilterResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateIpFilterV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateIpFilterV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationChannelsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetNotificationChannelsPaginatedResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetNotificationChannelsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationChannelsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateNotificationChannelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *NotificationChannelResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateNotificationChannelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateNotificationChannelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteNotificationChannelByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteNotificationChannelByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteNotificationChannelByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNotificationChannelByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NotificationChannelResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetNotificationChannelByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNotificationChannelByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateNotificationChannelByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NotificationChannelResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON409      *Conflict
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateNotificationChannelByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateNotificationChannelByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPermissionsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPermissionsResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPermissionsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPermissionsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlatformAuditEventsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAuditEventsResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPlatformAuditEventsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlatformAuditEventsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRolesV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetRolesPaginatedResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetRolesV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRolesV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRoleV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RoleResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateRoleV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRoleV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRoleByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteRoleByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRoleByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRoleByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RoleResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetRoleByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRoleByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRoleByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RoleResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *Conflict
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateRoleByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRoleByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGlobalServiceAccountsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetServiceAccountsPaginatedResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGlobalServiceAccountsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGlobalServiceAccountsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGlobalServiceAccountV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServiceAccountWithKeyResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON409      *Conflict
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateGlobalServiceAccountV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGlobalServiceAccountV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGlobalServiceAccountsNotificationSettingsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteGlobalServiceAccountsNotificationSettingsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGlobalServiceAccountsNotificationSettingsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGlobalServiceAccountsNotificationSettingsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceAccountsNotificationSettingsResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGlobalServiceAccountsNotificationSettingsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGlobalServiceAccountsNotificationSettingsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGlobalServiceAccountsNotificationSettingsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServiceAccountsNotificationSettingsResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateGlobalServiceAccountsNotificationSettingsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGlobalServiceAccountsNotificationSettingsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateGlobalServiceAccountsNotificationSettingsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceAccountsNotificationSettingsResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON415      *UnsupportedMediaType
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateGlobalServiceAccountsNotificationSettingsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateGlobalServiceAccountsNotificationSettingsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGlobalServiceAccountByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteGlobalServiceAccountByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGlobalServiceAccountByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGlobalServiceAccountByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceAccountResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGlobalServiceAccountByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGlobalServiceAccountByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSsoSettingsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AllSsoSettingsResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSsoSettingsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSsoSettingsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSsoSettingsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SsoSettingsResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateSsoSettingsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSsoSettingsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSsoSettingsByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteSsoSettingsByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSsoSettingsByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSsoSettingsByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SsoSettingsResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSsoSettingsByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSsoSettingsByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSsoSettingsByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SsoSettingsResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON415      *UnsupportedMediaType
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateSsoSettingsByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSsoSettingsByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetTeamsPaginatedResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetTeamsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTeamV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *TeamResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON409      *Conflict
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateTeamV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTeamV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTeamByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteTeamByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTeamByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetTeamByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTeamByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *Conflict
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateTeamByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTeamByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamServiceAccountsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetServiceAccountsPaginatedResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetTeamServiceAccountsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamServiceAccountsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTeamServiceAccountV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServiceAccountWithKeyResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON409      *Conflict
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateTeamServiceAccountV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTeamServiceAccountV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteServiceAccountsNotificationSettingsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteServiceAccountsNotificationSettingsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteServiceAccountsNotificationSettingsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetServiceAccountsNotificationSettingsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceAccountsNotificationSettingsResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetServiceAccountsNotificationSettingsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetServiceAccountsNotificationSettingsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateServiceAccountsNotificationSettingsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ServiceAccountsNotificationSettingsResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON415      *UnsupportedMediaType
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateServiceAccountsNotificationSettingsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateServiceAccountsNotificationSettingsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateServiceAccountsNotificationSettingsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceAccountsNotificationSettingsResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON415      *UnsupportedMediaType
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateServiceAccountsNotificationSettingsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateServiceAccountsNotificationSettingsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTeamServiceAccountByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteTeamServiceAccountByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTeamServiceAccountByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamServiceAccountByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServiceAccountResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetTeamServiceAccountByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamServiceAccountByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamUsersV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetTeamUsersPaginatedResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetTeamUsersV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamUsersV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTeamUserByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteTeamUserByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTeamUserByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeamUserByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamUserResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetTeamUserByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamUserByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SaveTeamUserV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TeamUserResponseV1
	JSON201      *TeamUserResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON415      *UnsupportedMediaType
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SaveTeamUserV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SaveTeamUserV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetUsersPaginatedResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUsersV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUserV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *UserResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON409      *Conflict
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateUserV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUserV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteUserByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateUserV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListZonesV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListZonesResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListZonesV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListZonesV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateZoneV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ZoneResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateZoneV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateZoneV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteZoneV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *Conflict
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteZoneV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteZoneV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetZoneByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ZoneResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetZoneByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetZoneByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditZoneV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ZoneResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON422      *UnprocessableEntity
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r EditZoneV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditZoneV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActivityAuditEntriesV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntriesResponse
	JSON400      *Error
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetActivityAuditEntriesV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivityAuditEntriesV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActivityAuditEntryV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntryResponse
	JSON400      *Error
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetActivityAuditEntryV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivityAuditEntryV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActivityAuditEntriesSupportedFiltersV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuditSupportedFiltersResponse
	JSON400      *Error
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetActivityAuditEntriesSupportedFiltersV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActivityAuditEntriesSupportedFiltersV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCertificatesV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CertificatesResponse
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCertificatesV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCertificatesV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadCertificateV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Certificate
	JSON400      *struct {
		Details *[]interface{}                `json:"details,omitempty"`
		Message UploadCertificateV1400Message `json:"message"`
		Type    UploadCertificateV1400Type    `json:"type"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}
type UploadCertificateV1400Message string
type UploadCertificateV1400Type string

// Status returns HTTPResponse.Status
func (r UploadCertificateV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadCertificateV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCertificateV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON409      *Error
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteCertificateV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCertificateV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCertificateV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Certificate
	JSON400      *Error
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCertificateV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCertificateV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCertificateRegistrationV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ServicesResponse
	JSON400      *Error
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCertificateRegistrationV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCertificateRegistrationV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCSRV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateCSRV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCSRV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEFOChannelsByIntegrationV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationChannelsResponse
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListEFOChannelsByIntegrationV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEFOChannelsByIntegrationV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEFOIntegrationsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListEfoIntegrationsResponseV1
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListEFOIntegrationsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEFOIntegrationsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEFOIntegrationV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *EfoIntegrationResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateEFOIntegrationV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEFOIntegrationV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEFOIntegrationByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteEFOIntegrationByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEFOIntegrationByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEFOIntegrationByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EfoIntegrationResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEFOIntegrationByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEFOIntegrationByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEFOIntegrationByIdV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EfoIntegrationResponseV1
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateEFOIntegrationByIdV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEFOIntegrationByIdV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEFOIntegrationsTypesV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationTypesResponse
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListEFOIntegrationsTypesV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEFOIntegrationsTypesV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEFOChannelsByIntegrationV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationChannelsResponse
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListEFOChannelsByIntegrationV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEFOChannelsByIntegrationV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEFOIntegrationsV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListIntegrationsResponse
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListEFOIntegrationsV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEFOIntegrationsV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateEFOIntegrationV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *IntegrationResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CreateEFOIntegrationV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateEFOIntegrationV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteEFOIntegrationByIdV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteEFOIntegrationByIdV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteEFOIntegrationByIdV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEFOIntegrationByIdV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEFOIntegrationByIdV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEFOIntegrationByIdV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEFOIntegrationByIdV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateEFOIntegrationByIdV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEFOIntegrationByIdV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListEFOIntegrationsTypesV2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *IntegrationTypesResponse
	JSON401      *Unauthorized
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ListEFOIntegrationsTypesV2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListEFOIntegrationsTypesV2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListEventsResponse
	JSON400      *Error
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEventsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Event
	JSON400      *Error
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEventV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventsSupportedFiltersV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SupportedFiltersResponse
	JSON400      *Error
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetEventsSupportedFiltersV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventsSupportedFiltersV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InventoryResourceResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetResourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *InventoryResourceExtended
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetResourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActionExecutionsv1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionExecutions
	JSON400      *struct {
		Details *[]interface{}                  `json:"details,omitempty"`
		Message GetActionExecutionsv1400Message `json:"message"`
		Type    GetActionExecutionsv1400Type    `json:"type"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}
type GetActionExecutionsv1400Message string
type GetActionExecutionsv1400Type string

// Status returns HTTPResponse.Status
func (r GetActionExecutionsv1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActionExecutionsv1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SubmitActionExecutionv1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *ActionExecution
	JSON400      *struct {
		Details *[]interface{} `json:"details,omitempty"`
		Message string         `json:"message"`
		Type    string         `json:"type"`
	}
	JSON401 *Unauthorized
	JSON403 *Forbidden
	JSON429 *TooManyRequests
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SubmitActionExecutionv1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SubmitActionExecutionv1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UndoActionExecutionV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionExecution
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UndoActionExecutionV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UndoActionExecutionV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActionExecutionV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ActionExecution
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetActionExecutionV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActionExecutionV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActionExecutionFileAcquireV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetActionExecutionFileAcquireV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActionExecutionFileAcquireV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActionsV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Actions
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetActionsV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActionsV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSecureVulnerabilityV1BundlesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListBundlesResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSecureVulnerabilityV1BundlesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSecureVulnerabilityV1BundlesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSecureVulnerabilityV1BundlesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GetBundleResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostSecureVulnerabilityV1BundlesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSecureVulnerabilityV1BundlesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSecureVulnerabilityV1BundlesBundleIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteSecureVulnerabilityV1BundlesBundleIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSecureVulnerabilityV1BundlesBundleIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSecureVulnerabilityV1BundlesBundleIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBundleResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSecureVulnerabilityV1BundlesBundleIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSecureVulnerabilityV1BundlesBundleIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutSecureVulnerabilityV1BundlesBundleIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetBundleResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PutSecureVulnerabilityV1BundlesBundleIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutSecureVulnerabilityV1BundlesBundleIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSecureVulnerabilityV1PipelineResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PipelineResultsResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSecureVulnerabilityV1PipelineResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSecureVulnerabilityV1PipelineResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSecureVulnerabilityV1PoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListPoliciesResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSecureVulnerabilityV1PoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSecureVulnerabilityV1PoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSecureVulnerabilityV1PoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *GetPolicyResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostSecureVulnerabilityV1PoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSecureVulnerabilityV1PoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSecureVulnerabilityV1PoliciesPolicyIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteSecureVulnerabilityV1PoliciesPolicyIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSecureVulnerabilityV1PoliciesPolicyIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSecureVulnerabilityV1PoliciesPolicyIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPolicyResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSecureVulnerabilityV1PoliciesPolicyIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSecureVulnerabilityV1PoliciesPolicyIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutSecureVulnerabilityV1PoliciesPolicyIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetPolicyResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PutSecureVulnerabilityV1PoliciesPolicyIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutSecureVulnerabilityV1PoliciesPolicyIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScannerAPIServiceListRegistryResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RegistryResultsResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ScannerAPIServiceListRegistryResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScannerAPIServiceListRegistryResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSecureVulnerabilityV1ResultsResultIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScanResultResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSecureVulnerabilityV1ResultsResultIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSecureVulnerabilityV1ResultsResultIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ScannerAPIServiceListRuntimeResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RuntimeResultsResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ScannerAPIServiceListRuntimeResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ScannerAPIServiceListRuntimeResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAcceptedRisksV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListRiskAcceptedResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAcceptedRisksV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAcceptedRisksV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAcceptedRiskV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *RiskAcceptedResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON409      *Conflict
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r PostAcceptedRiskV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAcceptedRiskV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAcceptedRiskV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteAcceptedRiskV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAcceptedRiskV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAcceptedRiskV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RiskAcceptedResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAcceptedRiskV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAcceptedRiskV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAcceptedRiskV1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RiskAcceptedResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateAcceptedRiskV1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAcceptedRiskV1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSBOMV1beta1Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SbomResultResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON403      *Forbidden
	JSON404      *NotFound
	JSON406      *string
	JSON429      *TooManyRequests
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetSBOMV1beta1Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSBOMV1beta1Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// QuerySysqlGetWithResponse request returning *QuerySysqlGetResponse
func (c *ClientWithResponses) QuerySysqlGetWithResponse(ctx context.Context, params *QuerySysqlGetParams, reqEditors ...RequestEditorFn) (*QuerySysqlGetResponse, error) {
	rsp, err := c.QuerySysqlGet(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQuerySysqlGetResponse(rsp)
}

// QuerySysqlPostWithBodyWithResponse request with arbitrary body returning *QuerySysqlPostResponse
func (c *ClientWithResponses) QuerySysqlPostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*QuerySysqlPostResponse, error) {
	rsp, err := c.QuerySysqlPostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQuerySysqlPostResponse(rsp)
}

func (c *ClientWithResponses) QuerySysqlPostWithResponse(ctx context.Context, body QuerySysqlPostJSONRequestBody, reqEditors ...RequestEditorFn) (*QuerySysqlPostResponse, error) {
	rsp, err := c.QuerySysqlPost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseQuerySysqlPostResponse(rsp)
}

// GetSysqlSchemaWithResponse request returning *GetSysqlSchemaResponse
func (c *ClientWithResponses) GetSysqlSchemaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSysqlSchemaResponse, error) {
	rsp, err := c.GetSysqlSchema(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSysqlSchemaResponse(rsp)
}

// GetInhibitionRulesWithResponse request returning *GetInhibitionRulesResponse
func (c *ClientWithResponses) GetInhibitionRulesWithResponse(ctx context.Context, params *GetInhibitionRulesParams, reqEditors ...RequestEditorFn) (*GetInhibitionRulesResponse, error) {
	rsp, err := c.GetInhibitionRules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInhibitionRulesResponse(rsp)
}

// CreateInhibitionRuleWithBodyWithResponse request with arbitrary body returning *CreateInhibitionRuleResponse
func (c *ClientWithResponses) CreateInhibitionRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateInhibitionRuleResponse, error) {
	rsp, err := c.CreateInhibitionRuleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInhibitionRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateInhibitionRuleWithResponse(ctx context.Context, body CreateInhibitionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateInhibitionRuleResponse, error) {
	rsp, err := c.CreateInhibitionRule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateInhibitionRuleResponse(rsp)
}

// DeleteInhibitionRuleByIdWithResponse request returning *DeleteInhibitionRuleByIdResponse
func (c *ClientWithResponses) DeleteInhibitionRuleByIdWithResponse(ctx context.Context, inhibitionRuleId InhibitionRulePath, reqEditors ...RequestEditorFn) (*DeleteInhibitionRuleByIdResponse, error) {
	rsp, err := c.DeleteInhibitionRuleById(ctx, inhibitionRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteInhibitionRuleByIdResponse(rsp)
}

// GetInhibitionRuleByIdWithResponse request returning *GetInhibitionRuleByIdResponse
func (c *ClientWithResponses) GetInhibitionRuleByIdWithResponse(ctx context.Context, inhibitionRuleId InhibitionRulePath, reqEditors ...RequestEditorFn) (*GetInhibitionRuleByIdResponse, error) {
	rsp, err := c.GetInhibitionRuleById(ctx, inhibitionRuleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInhibitionRuleByIdResponse(rsp)
}

// UpdateInhibitionRuleWithBodyWithResponse request with arbitrary body returning *UpdateInhibitionRuleResponse
func (c *ClientWithResponses) UpdateInhibitionRuleWithBodyWithResponse(ctx context.Context, inhibitionRuleId InhibitionRulePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateInhibitionRuleResponse, error) {
	rsp, err := c.UpdateInhibitionRuleWithBody(ctx, inhibitionRuleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInhibitionRuleResponse(rsp)
}

func (c *ClientWithResponses) UpdateInhibitionRuleWithResponse(ctx context.Context, inhibitionRuleId InhibitionRulePath, body UpdateInhibitionRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateInhibitionRuleResponse, error) {
	rsp, err := c.UpdateInhibitionRule(ctx, inhibitionRuleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateInhibitionRuleResponse(rsp)
}

// GetPricingV1WithResponse request returning *GetPricingV1Response
func (c *ClientWithResponses) GetPricingV1WithResponse(ctx context.Context, params *GetPricingV1Params, reqEditors ...RequestEditorFn) (*GetPricingV1Response, error) {
	rsp, err := c.GetPricingV1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPricingV1Response(rsp)
}

// CreatePricingV1WithBodyWithResponse request with arbitrary body returning *CreatePricingV1Response
func (c *ClientWithResponses) CreatePricingV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePricingV1Response, error) {
	rsp, err := c.CreatePricingV1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePricingV1Response(rsp)
}

func (c *ClientWithResponses) CreatePricingV1WithResponse(ctx context.Context, body CreatePricingV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePricingV1Response, error) {
	rsp, err := c.CreatePricingV1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePricingV1Response(rsp)
}

// DeletePricingByIdV1WithResponse request returning *DeletePricingByIdV1Response
func (c *ClientWithResponses) DeletePricingByIdV1WithResponse(ctx context.Context, pricingId PricingIdPath, reqEditors ...RequestEditorFn) (*DeletePricingByIdV1Response, error) {
	rsp, err := c.DeletePricingByIdV1(ctx, pricingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePricingByIdV1Response(rsp)
}

// GetPricingByIdV1WithResponse request returning *GetPricingByIdV1Response
func (c *ClientWithResponses) GetPricingByIdV1WithResponse(ctx context.Context, pricingId PricingIdPath, reqEditors ...RequestEditorFn) (*GetPricingByIdV1Response, error) {
	rsp, err := c.GetPricingByIdV1(ctx, pricingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPricingByIdV1Response(rsp)
}

// UpdatePricingByIdV1WithBodyWithResponse request with arbitrary body returning *UpdatePricingByIdV1Response
func (c *ClientWithResponses) UpdatePricingByIdV1WithBodyWithResponse(ctx context.Context, pricingId PricingIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePricingByIdV1Response, error) {
	rsp, err := c.UpdatePricingByIdV1WithBody(ctx, pricingId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePricingByIdV1Response(rsp)
}

func (c *ClientWithResponses) UpdatePricingByIdV1WithResponse(ctx context.Context, pricingId PricingIdPath, body UpdatePricingByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePricingByIdV1Response, error) {
	rsp, err := c.UpdatePricingByIdV1(ctx, pricingId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePricingByIdV1Response(rsp)
}

// GetPricingProjectedCostsV1WithResponse request returning *GetPricingProjectedCostsV1Response
func (c *ClientWithResponses) GetPricingProjectedCostsV1WithResponse(ctx context.Context, pricingId PricingIdPath, params *GetPricingProjectedCostsV1Params, reqEditors ...RequestEditorFn) (*GetPricingProjectedCostsV1Response, error) {
	rsp, err := c.GetPricingProjectedCostsV1(ctx, pricingId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPricingProjectedCostsV1Response(rsp)
}

// GetWastedWorkloadDataWithBodyWithResponse request with arbitrary body returning *GetWastedWorkloadDataResponse
func (c *ClientWithResponses) GetWastedWorkloadDataWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetWastedWorkloadDataResponse, error) {
	rsp, err := c.GetWastedWorkloadDataWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWastedWorkloadDataResponse(rsp)
}

func (c *ClientWithResponses) GetWastedWorkloadDataWithResponse(ctx context.Context, body GetWastedWorkloadDataJSONRequestBody, reqEditors ...RequestEditorFn) (*GetWastedWorkloadDataResponse, error) {
	rsp, err := c.GetWastedWorkloadData(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWastedWorkloadDataResponse(rsp)
}

// GetWorkloadCostDataV1WithBodyWithResponse request with arbitrary body returning *GetWorkloadCostDataV1Response
func (c *ClientWithResponses) GetWorkloadCostDataV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetWorkloadCostDataV1Response, error) {
	rsp, err := c.GetWorkloadCostDataV1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkloadCostDataV1Response(rsp)
}

func (c *ClientWithResponses) GetWorkloadCostDataV1WithResponse(ctx context.Context, body GetWorkloadCostDataV1JSONRequestBody, reqEditors ...RequestEditorFn) (*GetWorkloadCostDataV1Response, error) {
	rsp, err := c.GetWorkloadCostDataV1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkloadCostDataV1Response(rsp)
}

// GetWorkloadRightsizingDataWithBodyWithResponse request with arbitrary body returning *GetWorkloadRightsizingDataResponse
func (c *ClientWithResponses) GetWorkloadRightsizingDataWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetWorkloadRightsizingDataResponse, error) {
	rsp, err := c.GetWorkloadRightsizingDataWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkloadRightsizingDataResponse(rsp)
}

func (c *ClientWithResponses) GetWorkloadRightsizingDataWithResponse(ctx context.Context, body GetWorkloadRightsizingDataJSONRequestBody, reqEditors ...RequestEditorFn) (*GetWorkloadRightsizingDataResponse, error) {
	rsp, err := c.GetWorkloadRightsizingData(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWorkloadRightsizingDataResponse(rsp)
}

// GetMonitorEventsV1WithResponse request returning *GetMonitorEventsV1Response
func (c *ClientWithResponses) GetMonitorEventsV1WithResponse(ctx context.Context, params *GetMonitorEventsV1Params, reqEditors ...RequestEditorFn) (*GetMonitorEventsV1Response, error) {
	rsp, err := c.GetMonitorEventsV1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMonitorEventsV1Response(rsp)
}

// GetDisabledMetricsByJobV1WithResponse request returning *GetDisabledMetricsByJobV1Response
func (c *ClientWithResponses) GetDisabledMetricsByJobV1WithResponse(ctx context.Context, params *GetDisabledMetricsByJobV1Params, reqEditors ...RequestEditorFn) (*GetDisabledMetricsByJobV1Response, error) {
	rsp, err := c.GetDisabledMetricsByJobV1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDisabledMetricsByJobV1Response(rsp)
}

// PostDisabledMetricsV1WithBodyWithResponse request with arbitrary body returning *PostDisabledMetricsV1Response
func (c *ClientWithResponses) PostDisabledMetricsV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDisabledMetricsV1Response, error) {
	rsp, err := c.PostDisabledMetricsV1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDisabledMetricsV1Response(rsp)
}

func (c *ClientWithResponses) PostDisabledMetricsV1WithResponse(ctx context.Context, body PostDisabledMetricsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*PostDisabledMetricsV1Response, error) {
	rsp, err := c.PostDisabledMetricsV1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDisabledMetricsV1Response(rsp)
}

// GetCustomPrometheusJobsV1WithResponse request returning *GetCustomPrometheusJobsV1Response
func (c *ClientWithResponses) GetCustomPrometheusJobsV1WithResponse(ctx context.Context, params *GetCustomPrometheusJobsV1Params, reqEditors ...RequestEditorFn) (*GetCustomPrometheusJobsV1Response, error) {
	rsp, err := c.GetCustomPrometheusJobsV1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomPrometheusJobsV1Response(rsp)
}

// DeleteCustomPrometheusJobByIdV1WithResponse request returning *DeleteCustomPrometheusJobByIdV1Response
func (c *ClientWithResponses) DeleteCustomPrometheusJobByIdV1WithResponse(ctx context.Context, jobName JobNamePath, reqEditors ...RequestEditorFn) (*DeleteCustomPrometheusJobByIdV1Response, error) {
	rsp, err := c.DeleteCustomPrometheusJobByIdV1(ctx, jobName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomPrometheusJobByIdV1Response(rsp)
}

// GetCustomPrometheusJobByNameV1WithResponse request returning *GetCustomPrometheusJobByNameV1Response
func (c *ClientWithResponses) GetCustomPrometheusJobByNameV1WithResponse(ctx context.Context, jobName JobNamePath, reqEditors ...RequestEditorFn) (*GetCustomPrometheusJobByNameV1Response, error) {
	rsp, err := c.GetCustomPrometheusJobByNameV1(ctx, jobName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomPrometheusJobByNameV1Response(rsp)
}

// CreateCustomPrometheusJobV1WithBodyWithResponse request with arbitrary body returning *CreateCustomPrometheusJobV1Response
func (c *ClientWithResponses) CreateCustomPrometheusJobV1WithBodyWithResponse(ctx context.Context, jobName JobNamePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomPrometheusJobV1Response, error) {
	rsp, err := c.CreateCustomPrometheusJobV1WithBody(ctx, jobName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomPrometheusJobV1Response(rsp)
}

// UpdateCustomPrometheusJobByIdV1WithBodyWithResponse request with arbitrary body returning *UpdateCustomPrometheusJobByIdV1Response
func (c *ClientWithResponses) UpdateCustomPrometheusJobByIdV1WithBodyWithResponse(ctx context.Context, jobName JobNamePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomPrometheusJobByIdV1Response, error) {
	rsp, err := c.UpdateCustomPrometheusJobByIdV1WithBody(ctx, jobName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomPrometheusJobByIdV1Response(rsp)
}

// GetCustomPrometheusJobEnablementV1WithResponse request returning *GetCustomPrometheusJobEnablementV1Response
func (c *ClientWithResponses) GetCustomPrometheusJobEnablementV1WithResponse(ctx context.Context, jobName JobNamePath, reqEditors ...RequestEditorFn) (*GetCustomPrometheusJobEnablementV1Response, error) {
	rsp, err := c.GetCustomPrometheusJobEnablementV1(ctx, jobName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomPrometheusJobEnablementV1Response(rsp)
}

// UpdateCustomPrometheusJobEnablementV1WithBodyWithResponse request with arbitrary body returning *UpdateCustomPrometheusJobEnablementV1Response
func (c *ClientWithResponses) UpdateCustomPrometheusJobEnablementV1WithBodyWithResponse(ctx context.Context, jobName JobNamePath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomPrometheusJobEnablementV1Response, error) {
	rsp, err := c.UpdateCustomPrometheusJobEnablementV1WithBody(ctx, jobName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomPrometheusJobEnablementV1Response(rsp)
}

func (c *ClientWithResponses) UpdateCustomPrometheusJobEnablementV1WithResponse(ctx context.Context, jobName JobNamePath, body UpdateCustomPrometheusJobEnablementV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomPrometheusJobEnablementV1Response, error) {
	rsp, err := c.UpdateCustomPrometheusJobEnablementV1(ctx, jobName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomPrometheusJobEnablementV1Response(rsp)
}

// GetJiraIntegrationsV1WithResponse request returning *GetJiraIntegrationsV1Response
func (c *ClientWithResponses) GetJiraIntegrationsV1WithResponse(ctx context.Context, params *GetJiraIntegrationsV1Params, reqEditors ...RequestEditorFn) (*GetJiraIntegrationsV1Response, error) {
	rsp, err := c.GetJiraIntegrationsV1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJiraIntegrationsV1Response(rsp)
}

// CreateJiraIntegrationV1WithBodyWithResponse request with arbitrary body returning *CreateJiraIntegrationV1Response
func (c *ClientWithResponses) CreateJiraIntegrationV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJiraIntegrationV1Response, error) {
	rsp, err := c.CreateJiraIntegrationV1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJiraIntegrationV1Response(rsp)
}

func (c *ClientWithResponses) CreateJiraIntegrationV1WithResponse(ctx context.Context, body CreateJiraIntegrationV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJiraIntegrationV1Response, error) {
	rsp, err := c.CreateJiraIntegrationV1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJiraIntegrationV1Response(rsp)
}

// DeleteJiraIntegrationV1WithResponse request returning *DeleteJiraIntegrationV1Response
func (c *ClientWithResponses) DeleteJiraIntegrationV1WithResponse(ctx context.Context, integrationID IntegrationID, reqEditors ...RequestEditorFn) (*DeleteJiraIntegrationV1Response, error) {
	rsp, err := c.DeleteJiraIntegrationV1(ctx, integrationID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteJiraIntegrationV1Response(rsp)
}

// GetJiraIntegrationV1WithResponse request returning *GetJiraIntegrationV1Response
func (c *ClientWithResponses) GetJiraIntegrationV1WithResponse(ctx context.Context, integrationID IntegrationID, reqEditors ...RequestEditorFn) (*GetJiraIntegrationV1Response, error) {
	rsp, err := c.GetJiraIntegrationV1(ctx, integrationID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJiraIntegrationV1Response(rsp)
}

// UpdateJiraIntegrationV1WithBodyWithResponse request with arbitrary body returning *UpdateJiraIntegrationV1Response
func (c *ClientWithResponses) UpdateJiraIntegrationV1WithBodyWithResponse(ctx context.Context, integrationID IntegrationID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateJiraIntegrationV1Response, error) {
	rsp, err := c.UpdateJiraIntegrationV1WithBody(ctx, integrationID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateJiraIntegrationV1Response(rsp)
}

func (c *ClientWithResponses) UpdateJiraIntegrationV1WithResponse(ctx context.Context, integrationID IntegrationID, body UpdateJiraIntegrationV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateJiraIntegrationV1Response, error) {
	rsp, err := c.UpdateJiraIntegrationV1(ctx, integrationID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateJiraIntegrationV1Response(rsp)
}

// GetJiraIssueTypesV1WithResponse request returning *GetJiraIssueTypesV1Response
func (c *ClientWithResponses) GetJiraIssueTypesV1WithResponse(ctx context.Context, integrationID IntegrationID, reqEditors ...RequestEditorFn) (*GetJiraIssueTypesV1Response, error) {
	rsp, err := c.GetJiraIssueTypesV1(ctx, integrationID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJiraIssueTypesV1Response(rsp)
}

// CreateJiraIssueTypeV1WithBodyWithResponse request with arbitrary body returning *CreateJiraIssueTypeV1Response
func (c *ClientWithResponses) CreateJiraIssueTypeV1WithBodyWithResponse(ctx context.Context, integrationID IntegrationID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateJiraIssueTypeV1Response, error) {
	rsp, err := c.CreateJiraIssueTypeV1WithBody(ctx, integrationID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJiraIssueTypeV1Response(rsp)
}

func (c *ClientWithResponses) CreateJiraIssueTypeV1WithResponse(ctx context.Context, integrationID IntegrationID, body CreateJiraIssueTypeV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateJiraIssueTypeV1Response, error) {
	rsp, err := c.CreateJiraIssueTypeV1(ctx, integrationID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateJiraIssueTypeV1Response(rsp)
}

// DeleteJiraIssueTypeV1WithResponse request returning *DeleteJiraIssueTypeV1Response
func (c *ClientWithResponses) DeleteJiraIssueTypeV1WithResponse(ctx context.Context, integrationID IntegrationID, issueTypeID IssueTypeID, reqEditors ...RequestEditorFn) (*DeleteJiraIssueTypeV1Response, error) {
	rsp, err := c.DeleteJiraIssueTypeV1(ctx, integrationID, issueTypeID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteJiraIssueTypeV1Response(rsp)
}

// GetJiraIssueTypeV1WithResponse request returning *GetJiraIssueTypeV1Response
func (c *ClientWithResponses) GetJiraIssueTypeV1WithResponse(ctx context.Context, integrationID IntegrationID, issueTypeID IssueTypeID, reqEditors ...RequestEditorFn) (*GetJiraIssueTypeV1Response, error) {
	rsp, err := c.GetJiraIssueTypeV1(ctx, integrationID, issueTypeID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJiraIssueTypeV1Response(rsp)
}

// UpdateJiraIssueTypeV1WithBodyWithResponse request with arbitrary body returning *UpdateJiraIssueTypeV1Response
func (c *ClientWithResponses) UpdateJiraIssueTypeV1WithBodyWithResponse(ctx context.Context, integrationID IntegrationID, issueTypeID IssueTypeID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateJiraIssueTypeV1Response, error) {
	rsp, err := c.UpdateJiraIssueTypeV1WithBody(ctx, integrationID, issueTypeID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateJiraIssueTypeV1Response(rsp)
}

func (c *ClientWithResponses) UpdateJiraIssueTypeV1WithResponse(ctx context.Context, integrationID IntegrationID, issueTypeID IssueTypeID, body UpdateJiraIssueTypeV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateJiraIssueTypeV1Response, error) {
	rsp, err := c.UpdateJiraIssueTypeV1(ctx, integrationID, issueTypeID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateJiraIssueTypeV1Response(rsp)
}

// ListJobsV1WithResponse request returning *ListJobsV1Response
func (c *ClientWithResponses) ListJobsV1WithResponse(ctx context.Context, params *ListJobsV1Params, reqEditors ...RequestEditorFn) (*ListJobsV1Response, error) {
	rsp, err := c.ListJobsV1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJobsV1Response(rsp)
}

// ListSchedulesV1WithResponse request returning *ListSchedulesV1Response
func (c *ClientWithResponses) ListSchedulesV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSchedulesV1Response, error) {
	rsp, err := c.ListSchedulesV1(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSchedulesV1Response(rsp)
}

// GetAccessKeysV1WithResponse request returning *GetAccessKeysV1Response
func (c *ClientWithResponses) GetAccessKeysV1WithResponse(ctx context.Context, params *GetAccessKeysV1Params, reqEditors ...RequestEditorFn) (*GetAccessKeysV1Response, error) {
	rsp, err := c.GetAccessKeysV1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccessKeysV1Response(rsp)
}

// CreateAccessKeyV1WithBodyWithResponse request with arbitrary body returning *CreateAccessKeyV1Response
func (c *ClientWithResponses) CreateAccessKeyV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccessKeyV1Response, error) {
	rsp, err := c.CreateAccessKeyV1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccessKeyV1Response(rsp)
}

func (c *ClientWithResponses) CreateAccessKeyV1WithResponse(ctx context.Context, body CreateAccessKeyV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccessKeyV1Response, error) {
	rsp, err := c.CreateAccessKeyV1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccessKeyV1Response(rsp)
}

// DeleteAccessKeyByIdV1WithResponse request returning *DeleteAccessKeyByIdV1Response
func (c *ClientWithResponses) DeleteAccessKeyByIdV1WithResponse(ctx context.Context, accessKeyId AccessKeyIdPath, reqEditors ...RequestEditorFn) (*DeleteAccessKeyByIdV1Response, error) {
	rsp, err := c.DeleteAccessKeyByIdV1(ctx, accessKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAccessKeyByIdV1Response(rsp)
}

// GetAccessKeyByIdV1WithResponse request returning *GetAccessKeyByIdV1Response
func (c *ClientWithResponses) GetAccessKeyByIdV1WithResponse(ctx context.Context, accessKeyId AccessKeyIdPath, reqEditors ...RequestEditorFn) (*GetAccessKeyByIdV1Response, error) {
	rsp, err := c.GetAccessKeyByIdV1(ctx, accessKeyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccessKeyByIdV1Response(rsp)
}

// UpdateAccessKeyByIdV1WithBodyWithResponse request with arbitrary body returning *UpdateAccessKeyByIdV1Response
func (c *ClientWithResponses) UpdateAccessKeyByIdV1WithBodyWithResponse(ctx context.Context, accessKeyId AccessKeyIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAccessKeyByIdV1Response, error) {
	rsp, err := c.UpdateAccessKeyByIdV1WithBody(ctx, accessKeyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccessKeyByIdV1Response(rsp)
}

func (c *ClientWithResponses) UpdateAccessKeyByIdV1WithResponse(ctx context.Context, accessKeyId AccessKeyIdPath, body UpdateAccessKeyByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAccessKeyByIdV1Response, error) {
	rsp, err := c.UpdateAccessKeyByIdV1(ctx, accessKeyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAccessKeyByIdV1Response(rsp)
}

// GetCaptureStorageConfigurationV1WithResponse request returning *GetCaptureStorageConfigurationV1Response
func (c *ClientWithResponses) GetCaptureStorageConfigurationV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCaptureStorageConfigurationV1Response, error) {
	rsp, err := c.GetCaptureStorageConfigurationV1(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCaptureStorageConfigurationV1Response(rsp)
}

// UpdateCaptureStorageConfigurationV1WithBodyWithResponse request with arbitrary body returning *UpdateCaptureStorageConfigurationV1Response
func (c *ClientWithResponses) UpdateCaptureStorageConfigurationV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCaptureStorageConfigurationV1Response, error) {
	rsp, err := c.UpdateCaptureStorageConfigurationV1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCaptureStorageConfigurationV1Response(rsp)
}

func (c *ClientWithResponses) UpdateCaptureStorageConfigurationV1WithResponse(ctx context.Context, body UpdateCaptureStorageConfigurationV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCaptureStorageConfigurationV1Response, error) {
	rsp, err := c.UpdateCaptureStorageConfigurationV1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCaptureStorageConfigurationV1Response(rsp)
}

// GetUserDeactivationConfigurationV1WithResponse request returning *GetUserDeactivationConfigurationV1Response
func (c *ClientWithResponses) GetUserDeactivationConfigurationV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserDeactivationConfigurationV1Response, error) {
	rsp, err := c.GetUserDeactivationConfigurationV1(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserDeactivationConfigurationV1Response(rsp)
}

// UpdateUserDeactivationConfigurationByIdV1WithBodyWithResponse request with arbitrary body returning *UpdateUserDeactivationConfigurationByIdV1Response
func (c *ClientWithResponses) UpdateUserDeactivationConfigurationByIdV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserDeactivationConfigurationByIdV1Response, error) {
	rsp, err := c.UpdateUserDeactivationConfigurationByIdV1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserDeactivationConfigurationByIdV1Response(rsp)
}

func (c *ClientWithResponses) UpdateUserDeactivationConfigurationByIdV1WithResponse(ctx context.Context, body UpdateUserDeactivationConfigurationByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserDeactivationConfigurationByIdV1Response, error) {
	rsp, err := c.UpdateUserDeactivationConfigurationByIdV1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserDeactivationConfigurationByIdV1Response(rsp)
}

// GetDefaultRoleByDisplayNameV1WithResponse request returning *GetDefaultRoleByDisplayNameV1Response
func (c *ClientWithResponses) GetDefaultRoleByDisplayNameV1WithResponse(ctx context.Context, roleDisplayName GetDefaultRoleByDisplayNameV1ParamsRoleDisplayName, reqEditors ...RequestEditorFn) (*GetDefaultRoleByDisplayNameV1Response, error) {
	rsp, err := c.GetDefaultRoleByDisplayNameV1(ctx, roleDisplayName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDefaultRoleByDisplayNameV1Response(rsp)
}

// GetGlobaSsoSettingsV1WithResponse request returning *GetGlobaSsoSettingsV1Response
func (c *ClientWithResponses) GetGlobaSsoSettingsV1WithResponse(ctx context.Context, ssoProductId GetGlobaSsoSettingsV1ParamsSsoProductId, reqEditors ...RequestEditorFn) (*GetGlobaSsoSettingsV1Response, error) {
	rsp, err := c.GetGlobaSsoSettingsV1(ctx, ssoProductId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGlobaSsoSettingsV1Response(rsp)
}

// UpdateGlobalSsoSettingsV1WithBodyWithResponse request with arbitrary body returning *UpdateGlobalSsoSettingsV1Response
func (c *ClientWithResponses) UpdateGlobalSsoSettingsV1WithBodyWithResponse(ctx context.Context, ssoProductId UpdateGlobalSsoSettingsV1ParamsSsoProductId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGlobalSsoSettingsV1Response, error) {
	rsp, err := c.UpdateGlobalSsoSettingsV1WithBody(ctx, ssoProductId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGlobalSsoSettingsV1Response(rsp)
}

func (c *ClientWithResponses) UpdateGlobalSsoSettingsV1WithResponse(ctx context.Context, ssoProductId UpdateGlobalSsoSettingsV1ParamsSsoProductId, body UpdateGlobalSsoSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGlobalSsoSettingsV1Response, error) {
	rsp, err := c.UpdateGlobalSsoSettingsV1(ctx, ssoProductId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGlobalSsoSettingsV1Response(rsp)
}

// GetGroupMappingsV1WithResponse request returning *GetGroupMappingsV1Response
func (c *ClientWithResponses) GetGroupMappingsV1WithResponse(ctx context.Context, params *GetGroupMappingsV1Params, reqEditors ...RequestEditorFn) (*GetGroupMappingsV1Response, error) {
	rsp, err := c.GetGroupMappingsV1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupMappingsV1Response(rsp)
}

// CreateGroupMappingV1WithBodyWithResponse request with arbitrary body returning *CreateGroupMappingV1Response
func (c *ClientWithResponses) CreateGroupMappingV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGroupMappingV1Response, error) {
	rsp, err := c.CreateGroupMappingV1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupMappingV1Response(rsp)
}

func (c *ClientWithResponses) CreateGroupMappingV1WithResponse(ctx context.Context, body CreateGroupMappingV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGroupMappingV1Response, error) {
	rsp, err := c.CreateGroupMappingV1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGroupMappingV1Response(rsp)
}

// GetGroupMappingSettingsV1WithResponse request returning *GetGroupMappingSettingsV1Response
func (c *ClientWithResponses) GetGroupMappingSettingsV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGroupMappingSettingsV1Response, error) {
	rsp, err := c.GetGroupMappingSettingsV1(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupMappingSettingsV1Response(rsp)
}

// SaveGroupMappingSettingsV1WithBodyWithResponse request with arbitrary body returning *SaveGroupMappingSettingsV1Response
func (c *ClientWithResponses) SaveGroupMappingSettingsV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveGroupMappingSettingsV1Response, error) {
	rsp, err := c.SaveGroupMappingSettingsV1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveGroupMappingSettingsV1Response(rsp)
}

func (c *ClientWithResponses) SaveGroupMappingSettingsV1WithResponse(ctx context.Context, body SaveGroupMappingSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*SaveGroupMappingSettingsV1Response, error) {
	rsp, err := c.SaveGroupMappingSettingsV1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveGroupMappingSettingsV1Response(rsp)
}

// DeleteGroupMappingByIdV1WithResponse request returning *DeleteGroupMappingByIdV1Response
func (c *ClientWithResponses) DeleteGroupMappingByIdV1WithResponse(ctx context.Context, groupMappingId GroupMappingIdPath, reqEditors ...RequestEditorFn) (*DeleteGroupMappingByIdV1Response, error) {
	rsp, err := c.DeleteGroupMappingByIdV1(ctx, groupMappingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupMappingByIdV1Response(rsp)
}

// GetGroupMappingByIdV1WithResponse request returning *GetGroupMappingByIdV1Response
func (c *ClientWithResponses) GetGroupMappingByIdV1WithResponse(ctx context.Context, groupMappingId GroupMappingIdPath, reqEditors ...RequestEditorFn) (*GetGroupMappingByIdV1Response, error) {
	rsp, err := c.GetGroupMappingByIdV1(ctx, groupMappingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupMappingByIdV1Response(rsp)
}

// UpdateGroupMappingByIdV1WithBodyWithResponse request with arbitrary body returning *UpdateGroupMappingByIdV1Response
func (c *ClientWithResponses) UpdateGroupMappingByIdV1WithBodyWithResponse(ctx context.Context, groupMappingId GroupMappingIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGroupMappingByIdV1Response, error) {
	rsp, err := c.UpdateGroupMappingByIdV1WithBody(ctx, groupMappingId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupMappingByIdV1Response(rsp)
}

func (c *ClientWithResponses) UpdateGroupMappingByIdV1WithResponse(ctx context.Context, groupMappingId GroupMappingIdPath, body UpdateGroupMappingByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGroupMappingByIdV1Response, error) {
	rsp, err := c.UpdateGroupMappingByIdV1(ctx, groupMappingId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGroupMappingByIdV1Response(rsp)
}

// GetIpFiltersV1WithResponse request returning *GetIpFiltersV1Response
func (c *ClientWithResponses) GetIpFiltersV1WithResponse(ctx context.Context, params *GetIpFiltersV1Params, reqEditors ...RequestEditorFn) (*GetIpFiltersV1Response, error) {
	rsp, err := c.GetIpFiltersV1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIpFiltersV1Response(rsp)
}

// CreateIpFilterV1WithBodyWithResponse request with arbitrary body returning *CreateIpFilterV1Response
func (c *ClientWithResponses) CreateIpFilterV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateIpFilterV1Response, error) {
	rsp, err := c.CreateIpFilterV1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIpFilterV1Response(rsp)
}

func (c *ClientWithResponses) CreateIpFilterV1WithResponse(ctx context.Context, body CreateIpFilterV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateIpFilterV1Response, error) {
	rsp, err := c.CreateIpFilterV1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateIpFilterV1Response(rsp)
}

// GetIpFiltersSettingsV1WithResponse request returning *GetIpFiltersSettingsV1Response
func (c *ClientWithResponses) GetIpFiltersSettingsV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetIpFiltersSettingsV1Response, error) {
	rsp, err := c.GetIpFiltersSettingsV1(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIpFiltersSettingsV1Response(rsp)
}

// SaveIpFiltersSettingsV1WithBodyWithResponse request with arbitrary body returning *SaveIpFiltersSettingsV1Response
func (c *ClientWithResponses) SaveIpFiltersSettingsV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveIpFiltersSettingsV1Response, error) {
	rsp, err := c.SaveIpFiltersSettingsV1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveIpFiltersSettingsV1Response(rsp)
}

func (c *ClientWithResponses) SaveIpFiltersSettingsV1WithResponse(ctx context.Context, body SaveIpFiltersSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*SaveIpFiltersSettingsV1Response, error) {
	rsp, err := c.SaveIpFiltersSettingsV1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveIpFiltersSettingsV1Response(rsp)
}

// DeleteIpFilterByIdV1WithResponse request returning *DeleteIpFilterByIdV1Response
func (c *ClientWithResponses) DeleteIpFilterByIdV1WithResponse(ctx context.Context, ipFilterId IpFilterIdPath, reqEditors ...RequestEditorFn) (*DeleteIpFilterByIdV1Response, error) {
	rsp, err := c.DeleteIpFilterByIdV1(ctx, ipFilterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteIpFilterByIdV1Response(rsp)
}

// GetIpFilterByIdV1WithResponse request returning *GetIpFilterByIdV1Response
func (c *ClientWithResponses) GetIpFilterByIdV1WithResponse(ctx context.Context, ipFilterId IpFilterIdPath, reqEditors ...RequestEditorFn) (*GetIpFilterByIdV1Response, error) {
	rsp, err := c.GetIpFilterByIdV1(ctx, ipFilterId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetIpFilterByIdV1Response(rsp)
}

// UpdateIpFilterV1WithBodyWithResponse request with arbitrary body returning *UpdateIpFilterV1Response
func (c *ClientWithResponses) UpdateIpFilterV1WithBodyWithResponse(ctx context.Context, ipFilterId IpFilterIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateIpFilterV1Response, error) {
	rsp, err := c.UpdateIpFilterV1WithBody(ctx, ipFilterId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIpFilterV1Response(rsp)
}

func (c *ClientWithResponses) UpdateIpFilterV1WithResponse(ctx context.Context, ipFilterId IpFilterIdPath, body UpdateIpFilterV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateIpFilterV1Response, error) {
	rsp, err := c.UpdateIpFilterV1(ctx, ipFilterId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateIpFilterV1Response(rsp)
}

// GetNotificationChannelsWithResponse request returning *GetNotificationChannelsResponse
func (c *ClientWithResponses) GetNotificationChannelsWithResponse(ctx context.Context, params *GetNotificationChannelsParams, reqEditors ...RequestEditorFn) (*GetNotificationChannelsResponse, error) {
	rsp, err := c.GetNotificationChannels(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationChannelsResponse(rsp)
}

// CreateNotificationChannelWithBodyWithResponse request with arbitrary body returning *CreateNotificationChannelResponse
func (c *ClientWithResponses) CreateNotificationChannelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateNotificationChannelResponse, error) {
	rsp, err := c.CreateNotificationChannelWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNotificationChannelResponse(rsp)
}

func (c *ClientWithResponses) CreateNotificationChannelWithResponse(ctx context.Context, body CreateNotificationChannelJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateNotificationChannelResponse, error) {
	rsp, err := c.CreateNotificationChannel(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateNotificationChannelResponse(rsp)
}

// DeleteNotificationChannelByIdWithResponse request returning *DeleteNotificationChannelByIdResponse
func (c *ClientWithResponses) DeleteNotificationChannelByIdWithResponse(ctx context.Context, notificationChannelID NotificationChannelID, reqEditors ...RequestEditorFn) (*DeleteNotificationChannelByIdResponse, error) {
	rsp, err := c.DeleteNotificationChannelById(ctx, notificationChannelID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteNotificationChannelByIdResponse(rsp)
}

// GetNotificationChannelByIdWithResponse request returning *GetNotificationChannelByIdResponse
func (c *ClientWithResponses) GetNotificationChannelByIdWithResponse(ctx context.Context, notificationChannelID NotificationChannelID, reqEditors ...RequestEditorFn) (*GetNotificationChannelByIdResponse, error) {
	rsp, err := c.GetNotificationChannelById(ctx, notificationChannelID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNotificationChannelByIdResponse(rsp)
}

// UpdateNotificationChannelByIdWithBodyWithResponse request with arbitrary body returning *UpdateNotificationChannelByIdResponse
func (c *ClientWithResponses) UpdateNotificationChannelByIdWithBodyWithResponse(ctx context.Context, notificationChannelID NotificationChannelID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateNotificationChannelByIdResponse, error) {
	rsp, err := c.UpdateNotificationChannelByIdWithBody(ctx, notificationChannelID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNotificationChannelByIdResponse(rsp)
}

func (c *ClientWithResponses) UpdateNotificationChannelByIdWithResponse(ctx context.Context, notificationChannelID NotificationChannelID, body UpdateNotificationChannelByIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateNotificationChannelByIdResponse, error) {
	rsp, err := c.UpdateNotificationChannelById(ctx, notificationChannelID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateNotificationChannelByIdResponse(rsp)
}

// GetPermissionsV1WithResponse request returning *GetPermissionsV1Response
func (c *ClientWithResponses) GetPermissionsV1WithResponse(ctx context.Context, params *GetPermissionsV1Params, reqEditors ...RequestEditorFn) (*GetPermissionsV1Response, error) {
	rsp, err := c.GetPermissionsV1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPermissionsV1Response(rsp)
}

// GetPlatformAuditEventsV1WithResponse request returning *GetPlatformAuditEventsV1Response
func (c *ClientWithResponses) GetPlatformAuditEventsV1WithResponse(ctx context.Context, params *GetPlatformAuditEventsV1Params, reqEditors ...RequestEditorFn) (*GetPlatformAuditEventsV1Response, error) {
	rsp, err := c.GetPlatformAuditEventsV1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlatformAuditEventsV1Response(rsp)
}

// GetRolesV1WithResponse request returning *GetRolesV1Response
func (c *ClientWithResponses) GetRolesV1WithResponse(ctx context.Context, params *GetRolesV1Params, reqEditors ...RequestEditorFn) (*GetRolesV1Response, error) {
	rsp, err := c.GetRolesV1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRolesV1Response(rsp)
}

// CreateRoleV1WithBodyWithResponse request with arbitrary body returning *CreateRoleV1Response
func (c *ClientWithResponses) CreateRoleV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRoleV1Response, error) {
	rsp, err := c.CreateRoleV1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleV1Response(rsp)
}

func (c *ClientWithResponses) CreateRoleV1WithResponse(ctx context.Context, body CreateRoleV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRoleV1Response, error) {
	rsp, err := c.CreateRoleV1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRoleV1Response(rsp)
}

// DeleteRoleByIdV1WithResponse request returning *DeleteRoleByIdV1Response
func (c *ClientWithResponses) DeleteRoleByIdV1WithResponse(ctx context.Context, roleId RoleIdPath, reqEditors ...RequestEditorFn) (*DeleteRoleByIdV1Response, error) {
	rsp, err := c.DeleteRoleByIdV1(ctx, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRoleByIdV1Response(rsp)
}

// GetRoleByIdV1WithResponse request returning *GetRoleByIdV1Response
func (c *ClientWithResponses) GetRoleByIdV1WithResponse(ctx context.Context, roleId RoleIdPath, reqEditors ...RequestEditorFn) (*GetRoleByIdV1Response, error) {
	rsp, err := c.GetRoleByIdV1(ctx, roleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRoleByIdV1Response(rsp)
}

// UpdateRoleByIdV1WithBodyWithResponse request with arbitrary body returning *UpdateRoleByIdV1Response
func (c *ClientWithResponses) UpdateRoleByIdV1WithBodyWithResponse(ctx context.Context, roleId RoleIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRoleByIdV1Response, error) {
	rsp, err := c.UpdateRoleByIdV1WithBody(ctx, roleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleByIdV1Response(rsp)
}

func (c *ClientWithResponses) UpdateRoleByIdV1WithResponse(ctx context.Context, roleId RoleIdPath, body UpdateRoleByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRoleByIdV1Response, error) {
	rsp, err := c.UpdateRoleByIdV1(ctx, roleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRoleByIdV1Response(rsp)
}

// GetGlobalServiceAccountsV1WithResponse request returning *GetGlobalServiceAccountsV1Response
func (c *ClientWithResponses) GetGlobalServiceAccountsV1WithResponse(ctx context.Context, params *GetGlobalServiceAccountsV1Params, reqEditors ...RequestEditorFn) (*GetGlobalServiceAccountsV1Response, error) {
	rsp, err := c.GetGlobalServiceAccountsV1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGlobalServiceAccountsV1Response(rsp)
}

// CreateGlobalServiceAccountV1WithBodyWithResponse request with arbitrary body returning *CreateGlobalServiceAccountV1Response
func (c *ClientWithResponses) CreateGlobalServiceAccountV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGlobalServiceAccountV1Response, error) {
	rsp, err := c.CreateGlobalServiceAccountV1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGlobalServiceAccountV1Response(rsp)
}

func (c *ClientWithResponses) CreateGlobalServiceAccountV1WithResponse(ctx context.Context, body CreateGlobalServiceAccountV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGlobalServiceAccountV1Response, error) {
	rsp, err := c.CreateGlobalServiceAccountV1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGlobalServiceAccountV1Response(rsp)
}

// DeleteGlobalServiceAccountsNotificationSettingsV1WithResponse request returning *DeleteGlobalServiceAccountsNotificationSettingsV1Response
func (c *ClientWithResponses) DeleteGlobalServiceAccountsNotificationSettingsV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*DeleteGlobalServiceAccountsNotificationSettingsV1Response, error) {
	rsp, err := c.DeleteGlobalServiceAccountsNotificationSettingsV1(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGlobalServiceAccountsNotificationSettingsV1Response(rsp)
}

// GetGlobalServiceAccountsNotificationSettingsV1WithResponse request returning *GetGlobalServiceAccountsNotificationSettingsV1Response
func (c *ClientWithResponses) GetGlobalServiceAccountsNotificationSettingsV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetGlobalServiceAccountsNotificationSettingsV1Response, error) {
	rsp, err := c.GetGlobalServiceAccountsNotificationSettingsV1(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGlobalServiceAccountsNotificationSettingsV1Response(rsp)
}

// CreateGlobalServiceAccountsNotificationSettingsV1WithBodyWithResponse request with arbitrary body returning *CreateGlobalServiceAccountsNotificationSettingsV1Response
func (c *ClientWithResponses) CreateGlobalServiceAccountsNotificationSettingsV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGlobalServiceAccountsNotificationSettingsV1Response, error) {
	rsp, err := c.CreateGlobalServiceAccountsNotificationSettingsV1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGlobalServiceAccountsNotificationSettingsV1Response(rsp)
}

func (c *ClientWithResponses) CreateGlobalServiceAccountsNotificationSettingsV1WithResponse(ctx context.Context, body CreateGlobalServiceAccountsNotificationSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGlobalServiceAccountsNotificationSettingsV1Response, error) {
	rsp, err := c.CreateGlobalServiceAccountsNotificationSettingsV1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGlobalServiceAccountsNotificationSettingsV1Response(rsp)
}

// UpdateGlobalServiceAccountsNotificationSettingsV1WithBodyWithResponse request with arbitrary body returning *UpdateGlobalServiceAccountsNotificationSettingsV1Response
func (c *ClientWithResponses) UpdateGlobalServiceAccountsNotificationSettingsV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateGlobalServiceAccountsNotificationSettingsV1Response, error) {
	rsp, err := c.UpdateGlobalServiceAccountsNotificationSettingsV1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGlobalServiceAccountsNotificationSettingsV1Response(rsp)
}

func (c *ClientWithResponses) UpdateGlobalServiceAccountsNotificationSettingsV1WithResponse(ctx context.Context, body UpdateGlobalServiceAccountsNotificationSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateGlobalServiceAccountsNotificationSettingsV1Response, error) {
	rsp, err := c.UpdateGlobalServiceAccountsNotificationSettingsV1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateGlobalServiceAccountsNotificationSettingsV1Response(rsp)
}

// DeleteGlobalServiceAccountByIdV1WithResponse request returning *DeleteGlobalServiceAccountByIdV1Response
func (c *ClientWithResponses) DeleteGlobalServiceAccountByIdV1WithResponse(ctx context.Context, serviceAccountId ServiceAccountIdPath, reqEditors ...RequestEditorFn) (*DeleteGlobalServiceAccountByIdV1Response, error) {
	rsp, err := c.DeleteGlobalServiceAccountByIdV1(ctx, serviceAccountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGlobalServiceAccountByIdV1Response(rsp)
}

// GetGlobalServiceAccountByIdV1WithResponse request returning *GetGlobalServiceAccountByIdV1Response
func (c *ClientWithResponses) GetGlobalServiceAccountByIdV1WithResponse(ctx context.Context, serviceAccountId ServiceAccountIdPath, reqEditors ...RequestEditorFn) (*GetGlobalServiceAccountByIdV1Response, error) {
	rsp, err := c.GetGlobalServiceAccountByIdV1(ctx, serviceAccountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGlobalServiceAccountByIdV1Response(rsp)
}

// GetSsoSettingsV1WithResponse request returning *GetSsoSettingsV1Response
func (c *ClientWithResponses) GetSsoSettingsV1WithResponse(ctx context.Context, params *GetSsoSettingsV1Params, reqEditors ...RequestEditorFn) (*GetSsoSettingsV1Response, error) {
	rsp, err := c.GetSsoSettingsV1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSsoSettingsV1Response(rsp)
}

// CreateSsoSettingsV1WithBodyWithResponse request with arbitrary body returning *CreateSsoSettingsV1Response
func (c *ClientWithResponses) CreateSsoSettingsV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSsoSettingsV1Response, error) {
	rsp, err := c.CreateSsoSettingsV1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSsoSettingsV1Response(rsp)
}

func (c *ClientWithResponses) CreateSsoSettingsV1WithResponse(ctx context.Context, body CreateSsoSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSsoSettingsV1Response, error) {
	rsp, err := c.CreateSsoSettingsV1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSsoSettingsV1Response(rsp)
}

// DeleteSsoSettingsByIdV1WithResponse request returning *DeleteSsoSettingsByIdV1Response
func (c *ClientWithResponses) DeleteSsoSettingsByIdV1WithResponse(ctx context.Context, ssoSettingsId SsoSettingsIdPath, reqEditors ...RequestEditorFn) (*DeleteSsoSettingsByIdV1Response, error) {
	rsp, err := c.DeleteSsoSettingsByIdV1(ctx, ssoSettingsId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSsoSettingsByIdV1Response(rsp)
}

// GetSsoSettingsByIdV1WithResponse request returning *GetSsoSettingsByIdV1Response
func (c *ClientWithResponses) GetSsoSettingsByIdV1WithResponse(ctx context.Context, ssoSettingsId SsoSettingsIdPath, reqEditors ...RequestEditorFn) (*GetSsoSettingsByIdV1Response, error) {
	rsp, err := c.GetSsoSettingsByIdV1(ctx, ssoSettingsId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSsoSettingsByIdV1Response(rsp)
}

// UpdateSsoSettingsByIdV1WithBodyWithResponse request with arbitrary body returning *UpdateSsoSettingsByIdV1Response
func (c *ClientWithResponses) UpdateSsoSettingsByIdV1WithBodyWithResponse(ctx context.Context, ssoSettingsId SsoSettingsIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSsoSettingsByIdV1Response, error) {
	rsp, err := c.UpdateSsoSettingsByIdV1WithBody(ctx, ssoSettingsId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSsoSettingsByIdV1Response(rsp)
}

func (c *ClientWithResponses) UpdateSsoSettingsByIdV1WithResponse(ctx context.Context, ssoSettingsId SsoSettingsIdPath, body UpdateSsoSettingsByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSsoSettingsByIdV1Response, error) {
	rsp, err := c.UpdateSsoSettingsByIdV1(ctx, ssoSettingsId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSsoSettingsByIdV1Response(rsp)
}

// GetTeamsV1WithResponse request returning *GetTeamsV1Response
func (c *ClientWithResponses) GetTeamsV1WithResponse(ctx context.Context, params *GetTeamsV1Params, reqEditors ...RequestEditorFn) (*GetTeamsV1Response, error) {
	rsp, err := c.GetTeamsV1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamsV1Response(rsp)
}

// CreateTeamV1WithBodyWithResponse request with arbitrary body returning *CreateTeamV1Response
func (c *ClientWithResponses) CreateTeamV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTeamV1Response, error) {
	rsp, err := c.CreateTeamV1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTeamV1Response(rsp)
}

func (c *ClientWithResponses) CreateTeamV1WithResponse(ctx context.Context, body CreateTeamV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTeamV1Response, error) {
	rsp, err := c.CreateTeamV1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTeamV1Response(rsp)
}

// DeleteTeamByIdV1WithResponse request returning *DeleteTeamByIdV1Response
func (c *ClientWithResponses) DeleteTeamByIdV1WithResponse(ctx context.Context, teamId TeamIdPath, reqEditors ...RequestEditorFn) (*DeleteTeamByIdV1Response, error) {
	rsp, err := c.DeleteTeamByIdV1(ctx, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTeamByIdV1Response(rsp)
}

// GetTeamByIdV1WithResponse request returning *GetTeamByIdV1Response
func (c *ClientWithResponses) GetTeamByIdV1WithResponse(ctx context.Context, teamId TeamIdPath, reqEditors ...RequestEditorFn) (*GetTeamByIdV1Response, error) {
	rsp, err := c.GetTeamByIdV1(ctx, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamByIdV1Response(rsp)
}

// UpdateTeamByIdV1WithBodyWithResponse request with arbitrary body returning *UpdateTeamByIdV1Response
func (c *ClientWithResponses) UpdateTeamByIdV1WithBodyWithResponse(ctx context.Context, teamId TeamIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTeamByIdV1Response, error) {
	rsp, err := c.UpdateTeamByIdV1WithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTeamByIdV1Response(rsp)
}

func (c *ClientWithResponses) UpdateTeamByIdV1WithResponse(ctx context.Context, teamId TeamIdPath, body UpdateTeamByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTeamByIdV1Response, error) {
	rsp, err := c.UpdateTeamByIdV1(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTeamByIdV1Response(rsp)
}

// GetTeamServiceAccountsV1WithResponse request returning *GetTeamServiceAccountsV1Response
func (c *ClientWithResponses) GetTeamServiceAccountsV1WithResponse(ctx context.Context, teamId TeamIdPath, params *GetTeamServiceAccountsV1Params, reqEditors ...RequestEditorFn) (*GetTeamServiceAccountsV1Response, error) {
	rsp, err := c.GetTeamServiceAccountsV1(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamServiceAccountsV1Response(rsp)
}

// CreateTeamServiceAccountV1WithBodyWithResponse request with arbitrary body returning *CreateTeamServiceAccountV1Response
func (c *ClientWithResponses) CreateTeamServiceAccountV1WithBodyWithResponse(ctx context.Context, teamId TeamIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTeamServiceAccountV1Response, error) {
	rsp, err := c.CreateTeamServiceAccountV1WithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTeamServiceAccountV1Response(rsp)
}

func (c *ClientWithResponses) CreateTeamServiceAccountV1WithResponse(ctx context.Context, teamId TeamIdPath, body CreateTeamServiceAccountV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTeamServiceAccountV1Response, error) {
	rsp, err := c.CreateTeamServiceAccountV1(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTeamServiceAccountV1Response(rsp)
}

// DeleteServiceAccountsNotificationSettingsV1WithResponse request returning *DeleteServiceAccountsNotificationSettingsV1Response
func (c *ClientWithResponses) DeleteServiceAccountsNotificationSettingsV1WithResponse(ctx context.Context, teamId TeamIdPath, reqEditors ...RequestEditorFn) (*DeleteServiceAccountsNotificationSettingsV1Response, error) {
	rsp, err := c.DeleteServiceAccountsNotificationSettingsV1(ctx, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteServiceAccountsNotificationSettingsV1Response(rsp)
}

// GetServiceAccountsNotificationSettingsV1WithResponse request returning *GetServiceAccountsNotificationSettingsV1Response
func (c *ClientWithResponses) GetServiceAccountsNotificationSettingsV1WithResponse(ctx context.Context, teamId TeamIdPath, reqEditors ...RequestEditorFn) (*GetServiceAccountsNotificationSettingsV1Response, error) {
	rsp, err := c.GetServiceAccountsNotificationSettingsV1(ctx, teamId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetServiceAccountsNotificationSettingsV1Response(rsp)
}

// CreateServiceAccountsNotificationSettingsV1WithBodyWithResponse request with arbitrary body returning *CreateServiceAccountsNotificationSettingsV1Response
func (c *ClientWithResponses) CreateServiceAccountsNotificationSettingsV1WithBodyWithResponse(ctx context.Context, teamId TeamIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateServiceAccountsNotificationSettingsV1Response, error) {
	rsp, err := c.CreateServiceAccountsNotificationSettingsV1WithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceAccountsNotificationSettingsV1Response(rsp)
}

func (c *ClientWithResponses) CreateServiceAccountsNotificationSettingsV1WithResponse(ctx context.Context, teamId TeamIdPath, body CreateServiceAccountsNotificationSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateServiceAccountsNotificationSettingsV1Response, error) {
	rsp, err := c.CreateServiceAccountsNotificationSettingsV1(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateServiceAccountsNotificationSettingsV1Response(rsp)
}

// UpdateServiceAccountsNotificationSettingsV1WithBodyWithResponse request with arbitrary body returning *UpdateServiceAccountsNotificationSettingsV1Response
func (c *ClientWithResponses) UpdateServiceAccountsNotificationSettingsV1WithBodyWithResponse(ctx context.Context, teamId TeamIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateServiceAccountsNotificationSettingsV1Response, error) {
	rsp, err := c.UpdateServiceAccountsNotificationSettingsV1WithBody(ctx, teamId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceAccountsNotificationSettingsV1Response(rsp)
}

func (c *ClientWithResponses) UpdateServiceAccountsNotificationSettingsV1WithResponse(ctx context.Context, teamId TeamIdPath, body UpdateServiceAccountsNotificationSettingsV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateServiceAccountsNotificationSettingsV1Response, error) {
	rsp, err := c.UpdateServiceAccountsNotificationSettingsV1(ctx, teamId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateServiceAccountsNotificationSettingsV1Response(rsp)
}

// DeleteTeamServiceAccountByIdV1WithResponse request returning *DeleteTeamServiceAccountByIdV1Response
func (c *ClientWithResponses) DeleteTeamServiceAccountByIdV1WithResponse(ctx context.Context, teamId TeamIdPath, serviceAccountId ServiceAccountIdPath, reqEditors ...RequestEditorFn) (*DeleteTeamServiceAccountByIdV1Response, error) {
	rsp, err := c.DeleteTeamServiceAccountByIdV1(ctx, teamId, serviceAccountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTeamServiceAccountByIdV1Response(rsp)
}

// GetTeamServiceAccountByIdV1WithResponse request returning *GetTeamServiceAccountByIdV1Response
func (c *ClientWithResponses) GetTeamServiceAccountByIdV1WithResponse(ctx context.Context, teamId TeamIdPath, serviceAccountId ServiceAccountIdPath, reqEditors ...RequestEditorFn) (*GetTeamServiceAccountByIdV1Response, error) {
	rsp, err := c.GetTeamServiceAccountByIdV1(ctx, teamId, serviceAccountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamServiceAccountByIdV1Response(rsp)
}

// GetTeamUsersV1WithResponse request returning *GetTeamUsersV1Response
func (c *ClientWithResponses) GetTeamUsersV1WithResponse(ctx context.Context, teamId TeamIdPath, params *GetTeamUsersV1Params, reqEditors ...RequestEditorFn) (*GetTeamUsersV1Response, error) {
	rsp, err := c.GetTeamUsersV1(ctx, teamId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamUsersV1Response(rsp)
}

// DeleteTeamUserByIdV1WithResponse request returning *DeleteTeamUserByIdV1Response
func (c *ClientWithResponses) DeleteTeamUserByIdV1WithResponse(ctx context.Context, teamId TeamIdPath, userId UserIdPath, reqEditors ...RequestEditorFn) (*DeleteTeamUserByIdV1Response, error) {
	rsp, err := c.DeleteTeamUserByIdV1(ctx, teamId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTeamUserByIdV1Response(rsp)
}

// GetTeamUserByIdV1WithResponse request returning *GetTeamUserByIdV1Response
func (c *ClientWithResponses) GetTeamUserByIdV1WithResponse(ctx context.Context, teamId TeamIdPath, userId UserIdPath, reqEditors ...RequestEditorFn) (*GetTeamUserByIdV1Response, error) {
	rsp, err := c.GetTeamUserByIdV1(ctx, teamId, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeamUserByIdV1Response(rsp)
}

// SaveTeamUserV1WithBodyWithResponse request with arbitrary body returning *SaveTeamUserV1Response
func (c *ClientWithResponses) SaveTeamUserV1WithBodyWithResponse(ctx context.Context, teamId TeamIdPath, userId UserIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SaveTeamUserV1Response, error) {
	rsp, err := c.SaveTeamUserV1WithBody(ctx, teamId, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveTeamUserV1Response(rsp)
}

func (c *ClientWithResponses) SaveTeamUserV1WithResponse(ctx context.Context, teamId TeamIdPath, userId UserIdPath, body SaveTeamUserV1JSONRequestBody, reqEditors ...RequestEditorFn) (*SaveTeamUserV1Response, error) {
	rsp, err := c.SaveTeamUserV1(ctx, teamId, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSaveTeamUserV1Response(rsp)
}

// GetUsersV1WithResponse request returning *GetUsersV1Response
func (c *ClientWithResponses) GetUsersV1WithResponse(ctx context.Context, params *GetUsersV1Params, reqEditors ...RequestEditorFn) (*GetUsersV1Response, error) {
	rsp, err := c.GetUsersV1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersV1Response(rsp)
}

// CreateUserV1WithBodyWithResponse request with arbitrary body returning *CreateUserV1Response
func (c *ClientWithResponses) CreateUserV1WithBodyWithResponse(ctx context.Context, params *CreateUserV1Params, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUserV1Response, error) {
	rsp, err := c.CreateUserV1WithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserV1Response(rsp)
}

func (c *ClientWithResponses) CreateUserV1WithResponse(ctx context.Context, params *CreateUserV1Params, body CreateUserV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUserV1Response, error) {
	rsp, err := c.CreateUserV1(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUserV1Response(rsp)
}

// DeleteUserByIdV1WithResponse request returning *DeleteUserByIdV1Response
func (c *ClientWithResponses) DeleteUserByIdV1WithResponse(ctx context.Context, userId UserIdPath, reqEditors ...RequestEditorFn) (*DeleteUserByIdV1Response, error) {
	rsp, err := c.DeleteUserByIdV1(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserByIdV1Response(rsp)
}

// GetUserByIdV1WithResponse request returning *GetUserByIdV1Response
func (c *ClientWithResponses) GetUserByIdV1WithResponse(ctx context.Context, userId UserIdPath, reqEditors ...RequestEditorFn) (*GetUserByIdV1Response, error) {
	rsp, err := c.GetUserByIdV1(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserByIdV1Response(rsp)
}

// UpdateUserV1WithBodyWithResponse request with arbitrary body returning *UpdateUserV1Response
func (c *ClientWithResponses) UpdateUserV1WithBodyWithResponse(ctx context.Context, userId UserIdPath, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserV1Response, error) {
	rsp, err := c.UpdateUserV1WithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserV1Response(rsp)
}

func (c *ClientWithResponses) UpdateUserV1WithResponse(ctx context.Context, userId UserIdPath, body UpdateUserV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserV1Response, error) {
	rsp, err := c.UpdateUserV1(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserV1Response(rsp)
}

// ListZonesV1WithResponse request returning *ListZonesV1Response
func (c *ClientWithResponses) ListZonesV1WithResponse(ctx context.Context, params *ListZonesV1Params, reqEditors ...RequestEditorFn) (*ListZonesV1Response, error) {
	rsp, err := c.ListZonesV1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListZonesV1Response(rsp)
}

// CreateZoneV1WithBodyWithResponse request with arbitrary body returning *CreateZoneV1Response
func (c *ClientWithResponses) CreateZoneV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateZoneV1Response, error) {
	rsp, err := c.CreateZoneV1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateZoneV1Response(rsp)
}

func (c *ClientWithResponses) CreateZoneV1WithResponse(ctx context.Context, body CreateZoneV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateZoneV1Response, error) {
	rsp, err := c.CreateZoneV1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateZoneV1Response(rsp)
}

// DeleteZoneV1WithResponse request returning *DeleteZoneV1Response
func (c *ClientWithResponses) DeleteZoneV1WithResponse(ctx context.Context, zoneId ZoneId, reqEditors ...RequestEditorFn) (*DeleteZoneV1Response, error) {
	rsp, err := c.DeleteZoneV1(ctx, zoneId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteZoneV1Response(rsp)
}

// GetZoneByIdV1WithResponse request returning *GetZoneByIdV1Response
func (c *ClientWithResponses) GetZoneByIdV1WithResponse(ctx context.Context, zoneId ZoneId, reqEditors ...RequestEditorFn) (*GetZoneByIdV1Response, error) {
	rsp, err := c.GetZoneByIdV1(ctx, zoneId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetZoneByIdV1Response(rsp)
}

// EditZoneV1WithBodyWithResponse request with arbitrary body returning *EditZoneV1Response
func (c *ClientWithResponses) EditZoneV1WithBodyWithResponse(ctx context.Context, zoneId ZoneId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditZoneV1Response, error) {
	rsp, err := c.EditZoneV1WithBody(ctx, zoneId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditZoneV1Response(rsp)
}

func (c *ClientWithResponses) EditZoneV1WithResponse(ctx context.Context, zoneId ZoneId, body EditZoneV1JSONRequestBody, reqEditors ...RequestEditorFn) (*EditZoneV1Response, error) {
	rsp, err := c.EditZoneV1(ctx, zoneId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditZoneV1Response(rsp)
}

// GetActivityAuditEntriesV1WithResponse request returning *GetActivityAuditEntriesV1Response
func (c *ClientWithResponses) GetActivityAuditEntriesV1WithResponse(ctx context.Context, params *GetActivityAuditEntriesV1Params, reqEditors ...RequestEditorFn) (*GetActivityAuditEntriesV1Response, error) {
	rsp, err := c.GetActivityAuditEntriesV1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivityAuditEntriesV1Response(rsp)
}

// GetActivityAuditEntryV1WithResponse request returning *GetActivityAuditEntryV1Response
func (c *ClientWithResponses) GetActivityAuditEntryV1WithResponse(ctx context.Context, entryId EntryId, reqEditors ...RequestEditorFn) (*GetActivityAuditEntryV1Response, error) {
	rsp, err := c.GetActivityAuditEntryV1(ctx, entryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivityAuditEntryV1Response(rsp)
}

// GetActivityAuditEntriesSupportedFiltersV1WithResponse request returning *GetActivityAuditEntriesSupportedFiltersV1Response
func (c *ClientWithResponses) GetActivityAuditEntriesSupportedFiltersV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetActivityAuditEntriesSupportedFiltersV1Response, error) {
	rsp, err := c.GetActivityAuditEntriesSupportedFiltersV1(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActivityAuditEntriesSupportedFiltersV1Response(rsp)
}

// GetCertificatesV1WithResponse request returning *GetCertificatesV1Response
func (c *ClientWithResponses) GetCertificatesV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetCertificatesV1Response, error) {
	rsp, err := c.GetCertificatesV1(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCertificatesV1Response(rsp)
}

// UploadCertificateV1WithBodyWithResponse request with arbitrary body returning *UploadCertificateV1Response
func (c *ClientWithResponses) UploadCertificateV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadCertificateV1Response, error) {
	rsp, err := c.UploadCertificateV1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadCertificateV1Response(rsp)
}

// DeleteCertificateV1WithResponse request returning *DeleteCertificateV1Response
func (c *ClientWithResponses) DeleteCertificateV1WithResponse(ctx context.Context, certId PathCertificateId, reqEditors ...RequestEditorFn) (*DeleteCertificateV1Response, error) {
	rsp, err := c.DeleteCertificateV1(ctx, certId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCertificateV1Response(rsp)
}

// GetCertificateV1WithResponse request returning *GetCertificateV1Response
func (c *ClientWithResponses) GetCertificateV1WithResponse(ctx context.Context, certId PathCertificateId, reqEditors ...RequestEditorFn) (*GetCertificateV1Response, error) {
	rsp, err := c.GetCertificateV1(ctx, certId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCertificateV1Response(rsp)
}

// GetCertificateRegistrationV1WithResponse request returning *GetCertificateRegistrationV1Response
func (c *ClientWithResponses) GetCertificateRegistrationV1WithResponse(ctx context.Context, certId PathCertificateId, reqEditors ...RequestEditorFn) (*GetCertificateRegistrationV1Response, error) {
	rsp, err := c.GetCertificateRegistrationV1(ctx, certId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCertificateRegistrationV1Response(rsp)
}

// CreateCSRV1WithResponse request returning *CreateCSRV1Response
func (c *ClientWithResponses) CreateCSRV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*CreateCSRV1Response, error) {
	rsp, err := c.CreateCSRV1(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCSRV1Response(rsp)
}

// ListEFOChannelsByIntegrationV1WithResponse request returning *ListEFOChannelsByIntegrationV1Response
func (c *ClientWithResponses) ListEFOChannelsByIntegrationV1WithResponse(ctx context.Context, params *ListEFOChannelsByIntegrationV1Params, reqEditors ...RequestEditorFn) (*ListEFOChannelsByIntegrationV1Response, error) {
	rsp, err := c.ListEFOChannelsByIntegrationV1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEFOChannelsByIntegrationV1Response(rsp)
}

// ListEFOIntegrationsV1WithResponse request returning *ListEFOIntegrationsV1Response
func (c *ClientWithResponses) ListEFOIntegrationsV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListEFOIntegrationsV1Response, error) {
	rsp, err := c.ListEFOIntegrationsV1(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEFOIntegrationsV1Response(rsp)
}

// CreateEFOIntegrationV1WithBodyWithResponse request with arbitrary body returning *CreateEFOIntegrationV1Response
func (c *ClientWithResponses) CreateEFOIntegrationV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEFOIntegrationV1Response, error) {
	rsp, err := c.CreateEFOIntegrationV1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEFOIntegrationV1Response(rsp)
}

func (c *ClientWithResponses) CreateEFOIntegrationV1WithResponse(ctx context.Context, body CreateEFOIntegrationV1JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEFOIntegrationV1Response, error) {
	rsp, err := c.CreateEFOIntegrationV1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEFOIntegrationV1Response(rsp)
}

// DeleteEFOIntegrationByIdV1WithResponse request returning *DeleteEFOIntegrationByIdV1Response
func (c *ClientWithResponses) DeleteEFOIntegrationByIdV1WithResponse(ctx context.Context, integrationId IntegrationId, reqEditors ...RequestEditorFn) (*DeleteEFOIntegrationByIdV1Response, error) {
	rsp, err := c.DeleteEFOIntegrationByIdV1(ctx, integrationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEFOIntegrationByIdV1Response(rsp)
}

// GetEFOIntegrationByIdV1WithResponse request returning *GetEFOIntegrationByIdV1Response
func (c *ClientWithResponses) GetEFOIntegrationByIdV1WithResponse(ctx context.Context, integrationId IntegrationId, reqEditors ...RequestEditorFn) (*GetEFOIntegrationByIdV1Response, error) {
	rsp, err := c.GetEFOIntegrationByIdV1(ctx, integrationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEFOIntegrationByIdV1Response(rsp)
}

// UpdateEFOIntegrationByIdV1WithBodyWithResponse request with arbitrary body returning *UpdateEFOIntegrationByIdV1Response
func (c *ClientWithResponses) UpdateEFOIntegrationByIdV1WithBodyWithResponse(ctx context.Context, integrationId IntegrationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEFOIntegrationByIdV1Response, error) {
	rsp, err := c.UpdateEFOIntegrationByIdV1WithBody(ctx, integrationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEFOIntegrationByIdV1Response(rsp)
}

func (c *ClientWithResponses) UpdateEFOIntegrationByIdV1WithResponse(ctx context.Context, integrationId IntegrationId, body UpdateEFOIntegrationByIdV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEFOIntegrationByIdV1Response, error) {
	rsp, err := c.UpdateEFOIntegrationByIdV1(ctx, integrationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEFOIntegrationByIdV1Response(rsp)
}

// ListEFOIntegrationsTypesV1WithResponse request returning *ListEFOIntegrationsTypesV1Response
func (c *ClientWithResponses) ListEFOIntegrationsTypesV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListEFOIntegrationsTypesV1Response, error) {
	rsp, err := c.ListEFOIntegrationsTypesV1(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEFOIntegrationsTypesV1Response(rsp)
}

// ListEFOChannelsByIntegrationV2WithResponse request returning *ListEFOChannelsByIntegrationV2Response
func (c *ClientWithResponses) ListEFOChannelsByIntegrationV2WithResponse(ctx context.Context, params *ListEFOChannelsByIntegrationV2Params, reqEditors ...RequestEditorFn) (*ListEFOChannelsByIntegrationV2Response, error) {
	rsp, err := c.ListEFOChannelsByIntegrationV2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEFOChannelsByIntegrationV2Response(rsp)
}

// ListEFOIntegrationsV2WithResponse request returning *ListEFOIntegrationsV2Response
func (c *ClientWithResponses) ListEFOIntegrationsV2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListEFOIntegrationsV2Response, error) {
	rsp, err := c.ListEFOIntegrationsV2(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEFOIntegrationsV2Response(rsp)
}

// CreateEFOIntegrationV2WithBodyWithResponse request with arbitrary body returning *CreateEFOIntegrationV2Response
func (c *ClientWithResponses) CreateEFOIntegrationV2WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateEFOIntegrationV2Response, error) {
	rsp, err := c.CreateEFOIntegrationV2WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEFOIntegrationV2Response(rsp)
}

func (c *ClientWithResponses) CreateEFOIntegrationV2WithResponse(ctx context.Context, body CreateEFOIntegrationV2JSONRequestBody, reqEditors ...RequestEditorFn) (*CreateEFOIntegrationV2Response, error) {
	rsp, err := c.CreateEFOIntegrationV2(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateEFOIntegrationV2Response(rsp)
}

// DeleteEFOIntegrationByIdV2WithResponse request returning *DeleteEFOIntegrationByIdV2Response
func (c *ClientWithResponses) DeleteEFOIntegrationByIdV2WithResponse(ctx context.Context, integrationId IntegrationId, reqEditors ...RequestEditorFn) (*DeleteEFOIntegrationByIdV2Response, error) {
	rsp, err := c.DeleteEFOIntegrationByIdV2(ctx, integrationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteEFOIntegrationByIdV2Response(rsp)
}

// GetEFOIntegrationByIdV2WithResponse request returning *GetEFOIntegrationByIdV2Response
func (c *ClientWithResponses) GetEFOIntegrationByIdV2WithResponse(ctx context.Context, integrationId IntegrationId, reqEditors ...RequestEditorFn) (*GetEFOIntegrationByIdV2Response, error) {
	rsp, err := c.GetEFOIntegrationByIdV2(ctx, integrationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEFOIntegrationByIdV2Response(rsp)
}

// UpdateEFOIntegrationByIdV2WithBodyWithResponse request with arbitrary body returning *UpdateEFOIntegrationByIdV2Response
func (c *ClientWithResponses) UpdateEFOIntegrationByIdV2WithBodyWithResponse(ctx context.Context, integrationId IntegrationId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEFOIntegrationByIdV2Response, error) {
	rsp, err := c.UpdateEFOIntegrationByIdV2WithBody(ctx, integrationId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEFOIntegrationByIdV2Response(rsp)
}

func (c *ClientWithResponses) UpdateEFOIntegrationByIdV2WithResponse(ctx context.Context, integrationId IntegrationId, body UpdateEFOIntegrationByIdV2JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEFOIntegrationByIdV2Response, error) {
	rsp, err := c.UpdateEFOIntegrationByIdV2(ctx, integrationId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEFOIntegrationByIdV2Response(rsp)
}

// ListEFOIntegrationsTypesV2WithResponse request returning *ListEFOIntegrationsTypesV2Response
func (c *ClientWithResponses) ListEFOIntegrationsTypesV2WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListEFOIntegrationsTypesV2Response, error) {
	rsp, err := c.ListEFOIntegrationsTypesV2(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListEFOIntegrationsTypesV2Response(rsp)
}

// GetEventsV1WithResponse request returning *GetEventsV1Response
func (c *ClientWithResponses) GetEventsV1WithResponse(ctx context.Context, params *GetEventsV1Params, reqEditors ...RequestEditorFn) (*GetEventsV1Response, error) {
	rsp, err := c.GetEventsV1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventsV1Response(rsp)
}

// GetEventV1WithResponse request returning *GetEventV1Response
func (c *ClientWithResponses) GetEventV1WithResponse(ctx context.Context, eventId EventId, reqEditors ...RequestEditorFn) (*GetEventV1Response, error) {
	rsp, err := c.GetEventV1(ctx, eventId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventV1Response(rsp)
}

// GetEventsSupportedFiltersV1WithResponse request returning *GetEventsSupportedFiltersV1Response
func (c *ClientWithResponses) GetEventsSupportedFiltersV1WithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEventsSupportedFiltersV1Response, error) {
	rsp, err := c.GetEventsSupportedFiltersV1(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventsSupportedFiltersV1Response(rsp)
}

// GetResourcesWithResponse request returning *GetResourcesResponse
func (c *ClientWithResponses) GetResourcesWithResponse(ctx context.Context, params *GetResourcesParams, reqEditors ...RequestEditorFn) (*GetResourcesResponse, error) {
	rsp, err := c.GetResources(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourcesResponse(rsp)
}

// GetResourceWithResponse request returning *GetResourceResponse
func (c *ClientWithResponses) GetResourceWithResponse(ctx context.Context, hash string, reqEditors ...RequestEditorFn) (*GetResourceResponse, error) {
	rsp, err := c.GetResource(ctx, hash, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResourceResponse(rsp)
}

// GetActionExecutionsv1WithResponse request returning *GetActionExecutionsv1Response
func (c *ClientWithResponses) GetActionExecutionsv1WithResponse(ctx context.Context, params *GetActionExecutionsv1Params, reqEditors ...RequestEditorFn) (*GetActionExecutionsv1Response, error) {
	rsp, err := c.GetActionExecutionsv1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActionExecutionsv1Response(rsp)
}

// SubmitActionExecutionv1WithBodyWithResponse request with arbitrary body returning *SubmitActionExecutionv1Response
func (c *ClientWithResponses) SubmitActionExecutionv1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SubmitActionExecutionv1Response, error) {
	rsp, err := c.SubmitActionExecutionv1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitActionExecutionv1Response(rsp)
}

func (c *ClientWithResponses) SubmitActionExecutionv1WithResponse(ctx context.Context, body SubmitActionExecutionv1JSONRequestBody, reqEditors ...RequestEditorFn) (*SubmitActionExecutionv1Response, error) {
	rsp, err := c.SubmitActionExecutionv1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSubmitActionExecutionv1Response(rsp)
}

// UndoActionExecutionV1WithResponse request returning *UndoActionExecutionV1Response
func (c *ClientWithResponses) UndoActionExecutionV1WithResponse(ctx context.Context, actionExecutionId ActionExecutionId, params *UndoActionExecutionV1Params, reqEditors ...RequestEditorFn) (*UndoActionExecutionV1Response, error) {
	rsp, err := c.UndoActionExecutionV1(ctx, actionExecutionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUndoActionExecutionV1Response(rsp)
}

// GetActionExecutionV1WithResponse request returning *GetActionExecutionV1Response
func (c *ClientWithResponses) GetActionExecutionV1WithResponse(ctx context.Context, actionExecutionId ActionExecutionId, reqEditors ...RequestEditorFn) (*GetActionExecutionV1Response, error) {
	rsp, err := c.GetActionExecutionV1(ctx, actionExecutionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActionExecutionV1Response(rsp)
}

// GetActionExecutionFileAcquireV1WithResponse request returning *GetActionExecutionFileAcquireV1Response
func (c *ClientWithResponses) GetActionExecutionFileAcquireV1WithResponse(ctx context.Context, actionExecutionId ActionExecutionId, reqEditors ...RequestEditorFn) (*GetActionExecutionFileAcquireV1Response, error) {
	rsp, err := c.GetActionExecutionFileAcquireV1(ctx, actionExecutionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActionExecutionFileAcquireV1Response(rsp)
}

// GetActionsV1WithResponse request returning *GetActionsV1Response
func (c *ClientWithResponses) GetActionsV1WithResponse(ctx context.Context, params *GetActionsV1Params, reqEditors ...RequestEditorFn) (*GetActionsV1Response, error) {
	rsp, err := c.GetActionsV1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActionsV1Response(rsp)
}

// GetSecureVulnerabilityV1BundlesWithResponse request returning *GetSecureVulnerabilityV1BundlesResponse
func (c *ClientWithResponses) GetSecureVulnerabilityV1BundlesWithResponse(ctx context.Context, params *GetSecureVulnerabilityV1BundlesParams, reqEditors ...RequestEditorFn) (*GetSecureVulnerabilityV1BundlesResponse, error) {
	rsp, err := c.GetSecureVulnerabilityV1Bundles(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSecureVulnerabilityV1BundlesResponse(rsp)
}

// PostSecureVulnerabilityV1BundlesWithBodyWithResponse request with arbitrary body returning *PostSecureVulnerabilityV1BundlesResponse
func (c *ClientWithResponses) PostSecureVulnerabilityV1BundlesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSecureVulnerabilityV1BundlesResponse, error) {
	rsp, err := c.PostSecureVulnerabilityV1BundlesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSecureVulnerabilityV1BundlesResponse(rsp)
}

func (c *ClientWithResponses) PostSecureVulnerabilityV1BundlesWithResponse(ctx context.Context, body PostSecureVulnerabilityV1BundlesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSecureVulnerabilityV1BundlesResponse, error) {
	rsp, err := c.PostSecureVulnerabilityV1Bundles(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSecureVulnerabilityV1BundlesResponse(rsp)
}

// DeleteSecureVulnerabilityV1BundlesBundleIdWithResponse request returning *DeleteSecureVulnerabilityV1BundlesBundleIdResponse
func (c *ClientWithResponses) DeleteSecureVulnerabilityV1BundlesBundleIdWithResponse(ctx context.Context, bundleId int64, reqEditors ...RequestEditorFn) (*DeleteSecureVulnerabilityV1BundlesBundleIdResponse, error) {
	rsp, err := c.DeleteSecureVulnerabilityV1BundlesBundleId(ctx, bundleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSecureVulnerabilityV1BundlesBundleIdResponse(rsp)
}

// GetSecureVulnerabilityV1BundlesBundleIdWithResponse request returning *GetSecureVulnerabilityV1BundlesBundleIdResponse
func (c *ClientWithResponses) GetSecureVulnerabilityV1BundlesBundleIdWithResponse(ctx context.Context, bundleId int64, reqEditors ...RequestEditorFn) (*GetSecureVulnerabilityV1BundlesBundleIdResponse, error) {
	rsp, err := c.GetSecureVulnerabilityV1BundlesBundleId(ctx, bundleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSecureVulnerabilityV1BundlesBundleIdResponse(rsp)
}

// PutSecureVulnerabilityV1BundlesBundleIdWithBodyWithResponse request with arbitrary body returning *PutSecureVulnerabilityV1BundlesBundleIdResponse
func (c *ClientWithResponses) PutSecureVulnerabilityV1BundlesBundleIdWithBodyWithResponse(ctx context.Context, bundleId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutSecureVulnerabilityV1BundlesBundleIdResponse, error) {
	rsp, err := c.PutSecureVulnerabilityV1BundlesBundleIdWithBody(ctx, bundleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutSecureVulnerabilityV1BundlesBundleIdResponse(rsp)
}

func (c *ClientWithResponses) PutSecureVulnerabilityV1BundlesBundleIdWithResponse(ctx context.Context, bundleId int64, body PutSecureVulnerabilityV1BundlesBundleIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutSecureVulnerabilityV1BundlesBundleIdResponse, error) {
	rsp, err := c.PutSecureVulnerabilityV1BundlesBundleId(ctx, bundleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutSecureVulnerabilityV1BundlesBundleIdResponse(rsp)
}

// GetSecureVulnerabilityV1PipelineResultsWithResponse request returning *GetSecureVulnerabilityV1PipelineResultsResponse
func (c *ClientWithResponses) GetSecureVulnerabilityV1PipelineResultsWithResponse(ctx context.Context, params *GetSecureVulnerabilityV1PipelineResultsParams, reqEditors ...RequestEditorFn) (*GetSecureVulnerabilityV1PipelineResultsResponse, error) {
	rsp, err := c.GetSecureVulnerabilityV1PipelineResults(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSecureVulnerabilityV1PipelineResultsResponse(rsp)
}

// GetSecureVulnerabilityV1PoliciesWithResponse request returning *GetSecureVulnerabilityV1PoliciesResponse
func (c *ClientWithResponses) GetSecureVulnerabilityV1PoliciesWithResponse(ctx context.Context, params *GetSecureVulnerabilityV1PoliciesParams, reqEditors ...RequestEditorFn) (*GetSecureVulnerabilityV1PoliciesResponse, error) {
	rsp, err := c.GetSecureVulnerabilityV1Policies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSecureVulnerabilityV1PoliciesResponse(rsp)
}

// PostSecureVulnerabilityV1PoliciesWithBodyWithResponse request with arbitrary body returning *PostSecureVulnerabilityV1PoliciesResponse
func (c *ClientWithResponses) PostSecureVulnerabilityV1PoliciesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSecureVulnerabilityV1PoliciesResponse, error) {
	rsp, err := c.PostSecureVulnerabilityV1PoliciesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSecureVulnerabilityV1PoliciesResponse(rsp)
}

func (c *ClientWithResponses) PostSecureVulnerabilityV1PoliciesWithResponse(ctx context.Context, body PostSecureVulnerabilityV1PoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSecureVulnerabilityV1PoliciesResponse, error) {
	rsp, err := c.PostSecureVulnerabilityV1Policies(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSecureVulnerabilityV1PoliciesResponse(rsp)
}

// DeleteSecureVulnerabilityV1PoliciesPolicyIdWithResponse request returning *DeleteSecureVulnerabilityV1PoliciesPolicyIdResponse
func (c *ClientWithResponses) DeleteSecureVulnerabilityV1PoliciesPolicyIdWithResponse(ctx context.Context, policyId int64, reqEditors ...RequestEditorFn) (*DeleteSecureVulnerabilityV1PoliciesPolicyIdResponse, error) {
	rsp, err := c.DeleteSecureVulnerabilityV1PoliciesPolicyId(ctx, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSecureVulnerabilityV1PoliciesPolicyIdResponse(rsp)
}

// GetSecureVulnerabilityV1PoliciesPolicyIdWithResponse request returning *GetSecureVulnerabilityV1PoliciesPolicyIdResponse
func (c *ClientWithResponses) GetSecureVulnerabilityV1PoliciesPolicyIdWithResponse(ctx context.Context, policyId int64, reqEditors ...RequestEditorFn) (*GetSecureVulnerabilityV1PoliciesPolicyIdResponse, error) {
	rsp, err := c.GetSecureVulnerabilityV1PoliciesPolicyId(ctx, policyId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSecureVulnerabilityV1PoliciesPolicyIdResponse(rsp)
}

// PutSecureVulnerabilityV1PoliciesPolicyIdWithBodyWithResponse request with arbitrary body returning *PutSecureVulnerabilityV1PoliciesPolicyIdResponse
func (c *ClientWithResponses) PutSecureVulnerabilityV1PoliciesPolicyIdWithBodyWithResponse(ctx context.Context, policyId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutSecureVulnerabilityV1PoliciesPolicyIdResponse, error) {
	rsp, err := c.PutSecureVulnerabilityV1PoliciesPolicyIdWithBody(ctx, policyId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutSecureVulnerabilityV1PoliciesPolicyIdResponse(rsp)
}

func (c *ClientWithResponses) PutSecureVulnerabilityV1PoliciesPolicyIdWithResponse(ctx context.Context, policyId int64, body PutSecureVulnerabilityV1PoliciesPolicyIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutSecureVulnerabilityV1PoliciesPolicyIdResponse, error) {
	rsp, err := c.PutSecureVulnerabilityV1PoliciesPolicyId(ctx, policyId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutSecureVulnerabilityV1PoliciesPolicyIdResponse(rsp)
}

// ScannerAPIServiceListRegistryResultsWithResponse request returning *ScannerAPIServiceListRegistryResultsResponse
func (c *ClientWithResponses) ScannerAPIServiceListRegistryResultsWithResponse(ctx context.Context, params *ScannerAPIServiceListRegistryResultsParams, reqEditors ...RequestEditorFn) (*ScannerAPIServiceListRegistryResultsResponse, error) {
	rsp, err := c.ScannerAPIServiceListRegistryResults(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannerAPIServiceListRegistryResultsResponse(rsp)
}

// GetSecureVulnerabilityV1ResultsResultIdWithResponse request returning *GetSecureVulnerabilityV1ResultsResultIdResponse
func (c *ClientWithResponses) GetSecureVulnerabilityV1ResultsResultIdWithResponse(ctx context.Context, resultId string, reqEditors ...RequestEditorFn) (*GetSecureVulnerabilityV1ResultsResultIdResponse, error) {
	rsp, err := c.GetSecureVulnerabilityV1ResultsResultId(ctx, resultId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSecureVulnerabilityV1ResultsResultIdResponse(rsp)
}

// ScannerAPIServiceListRuntimeResultsWithResponse request returning *ScannerAPIServiceListRuntimeResultsResponse
func (c *ClientWithResponses) ScannerAPIServiceListRuntimeResultsWithResponse(ctx context.Context, params *ScannerAPIServiceListRuntimeResultsParams, reqEditors ...RequestEditorFn) (*ScannerAPIServiceListRuntimeResultsResponse, error) {
	rsp, err := c.ScannerAPIServiceListRuntimeResults(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseScannerAPIServiceListRuntimeResultsResponse(rsp)
}

// GetAcceptedRisksV1WithResponse request returning *GetAcceptedRisksV1Response
func (c *ClientWithResponses) GetAcceptedRisksV1WithResponse(ctx context.Context, params *GetAcceptedRisksV1Params, reqEditors ...RequestEditorFn) (*GetAcceptedRisksV1Response, error) {
	rsp, err := c.GetAcceptedRisksV1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAcceptedRisksV1Response(rsp)
}

// PostAcceptedRiskV1WithBodyWithResponse request with arbitrary body returning *PostAcceptedRiskV1Response
func (c *ClientWithResponses) PostAcceptedRiskV1WithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAcceptedRiskV1Response, error) {
	rsp, err := c.PostAcceptedRiskV1WithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAcceptedRiskV1Response(rsp)
}

func (c *ClientWithResponses) PostAcceptedRiskV1WithResponse(ctx context.Context, body PostAcceptedRiskV1JSONRequestBody, reqEditors ...RequestEditorFn) (*PostAcceptedRiskV1Response, error) {
	rsp, err := c.PostAcceptedRiskV1(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAcceptedRiskV1Response(rsp)
}

// DeleteAcceptedRiskV1WithResponse request returning *DeleteAcceptedRiskV1Response
func (c *ClientWithResponses) DeleteAcceptedRiskV1WithResponse(ctx context.Context, acceptedRiskID AcceptedRiskID, reqEditors ...RequestEditorFn) (*DeleteAcceptedRiskV1Response, error) {
	rsp, err := c.DeleteAcceptedRiskV1(ctx, acceptedRiskID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAcceptedRiskV1Response(rsp)
}

// GetAcceptedRiskV1WithResponse request returning *GetAcceptedRiskV1Response
func (c *ClientWithResponses) GetAcceptedRiskV1WithResponse(ctx context.Context, acceptedRiskID AcceptedRiskID, reqEditors ...RequestEditorFn) (*GetAcceptedRiskV1Response, error) {
	rsp, err := c.GetAcceptedRiskV1(ctx, acceptedRiskID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAcceptedRiskV1Response(rsp)
}

// UpdateAcceptedRiskV1WithBodyWithResponse request with arbitrary body returning *UpdateAcceptedRiskV1Response
func (c *ClientWithResponses) UpdateAcceptedRiskV1WithBodyWithResponse(ctx context.Context, acceptedRiskID AcceptedRiskID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAcceptedRiskV1Response, error) {
	rsp, err := c.UpdateAcceptedRiskV1WithBody(ctx, acceptedRiskID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAcceptedRiskV1Response(rsp)
}

func (c *ClientWithResponses) UpdateAcceptedRiskV1WithResponse(ctx context.Context, acceptedRiskID AcceptedRiskID, body UpdateAcceptedRiskV1JSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAcceptedRiskV1Response, error) {
	rsp, err := c.UpdateAcceptedRiskV1(ctx, acceptedRiskID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAcceptedRiskV1Response(rsp)
}

// GetSBOMV1beta1WithResponse request returning *GetSBOMV1beta1Response
func (c *ClientWithResponses) GetSBOMV1beta1WithResponse(ctx context.Context, params *GetSBOMV1beta1Params, reqEditors ...RequestEditorFn) (*GetSBOMV1beta1Response, error) {
	rsp, err := c.GetSBOMV1beta1(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSBOMV1beta1Response(rsp)
}

// ParseQuerySysqlGetResponse parses an HTTP response from a QuerySysqlGetWithResponse call
func ParseQuerySysqlGetResponse(rsp *http.Response) (*QuerySysqlGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QuerySysqlGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseQuerySysqlPostResponse parses an HTTP response from a QuerySysqlPostWithResponse call
func ParseQuerySysqlPostResponse(rsp *http.Response) (*QuerySysqlPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &QuerySysqlPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest QueryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSysqlSchemaResponse parses an HTTP response from a GetSysqlSchemaWithResponse call
func ParseGetSysqlSchemaResponse(rsp *http.Response) (*GetSysqlSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSysqlSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetInhibitionRulesResponse parses an HTTP response from a GetInhibitionRulesWithResponse call
func ParseGetInhibitionRulesResponse(rsp *http.Response) (*GetInhibitionRulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInhibitionRulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetInhibitionRulesPaginatedResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateInhibitionRuleResponse parses an HTTP response from a CreateInhibitionRuleWithResponse call
func ParseCreateInhibitionRuleResponse(rsp *http.Response) (*CreateInhibitionRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateInhibitionRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest InhibitionRuleResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteInhibitionRuleByIdResponse parses an HTTP response from a DeleteInhibitionRuleByIdWithResponse call
func ParseDeleteInhibitionRuleByIdResponse(rsp *http.Response) (*DeleteInhibitionRuleByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteInhibitionRuleByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetInhibitionRuleByIdResponse parses an HTTP response from a GetInhibitionRuleByIdWithResponse call
func ParseGetInhibitionRuleByIdResponse(rsp *http.Response) (*GetInhibitionRuleByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInhibitionRuleByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InhibitionRuleResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateInhibitionRuleResponse parses an HTTP response from a UpdateInhibitionRuleWithResponse call
func ParseUpdateInhibitionRuleResponse(rsp *http.Response) (*UpdateInhibitionRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateInhibitionRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InhibitionRuleResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPricingV1Response parses an HTTP response from a GetPricingV1WithResponse call
func ParseGetPricingV1Response(rsp *http.Response) (*GetPricingV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPricingV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPricingPaginatedResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreatePricingV1Response parses an HTTP response from a CreatePricingV1WithResponse call
func ParseCreatePricingV1Response(rsp *http.Response) (*CreatePricingV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePricingV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest PricingResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePricingByIdV1Response parses an HTTP response from a DeletePricingByIdV1WithResponse call
func ParseDeletePricingByIdV1Response(rsp *http.Response) (*DeletePricingByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePricingByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPricingByIdV1Response parses an HTTP response from a GetPricingByIdV1WithResponse call
func ParseGetPricingByIdV1Response(rsp *http.Response) (*GetPricingByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPricingByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PricingResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdatePricingByIdV1Response parses an HTTP response from a UpdatePricingByIdV1WithResponse call
func ParseUpdatePricingByIdV1Response(rsp *http.Response) (*UpdatePricingByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePricingByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PricingResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPricingProjectedCostsV1Response parses an HTTP response from a GetPricingProjectedCostsV1WithResponse call
func ParseGetPricingProjectedCostsV1Response(rsp *http.Response) (*GetPricingProjectedCostsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPricingProjectedCostsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPricingProjectedPaginatedResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWastedWorkloadDataResponse parses an HTTP response from a GetWastedWorkloadDataWithResponse call
func ParseGetWastedWorkloadDataResponse(rsp *http.Response) (*GetWastedWorkloadDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWastedWorkloadDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WastedWorkloadSpendDataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWorkloadCostDataV1Response parses an HTTP response from a GetWorkloadCostDataV1WithResponse call
func ParseGetWorkloadCostDataV1Response(rsp *http.Response) (*GetWorkloadCostDataV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkloadCostDataV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkloadCostTrendsDataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetWorkloadRightsizingDataResponse parses an HTTP response from a GetWorkloadRightsizingDataWithResponse call
func ParseGetWorkloadRightsizingDataResponse(rsp *http.Response) (*GetWorkloadRightsizingDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWorkloadRightsizingDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WorkloadRightsizingDataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMonitorEventsV1Response parses an HTTP response from a GetMonitorEventsV1WithResponse call
func ParseGetMonitorEventsV1Response(rsp *http.Response) (*GetMonitorEventsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMonitorEventsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListMonitorEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDisabledMetricsByJobV1Response parses an HTTP response from a GetDisabledMetricsByJobV1WithResponse call
func ParseGetDisabledMetricsByJobV1Response(rsp *http.Response) (*GetDisabledMetricsByJobV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDisabledMetricsByJobV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseListDisabledMetricsV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostDisabledMetricsV1Response parses an HTTP response from a PostDisabledMetricsV1WithResponse call
func ParsePostDisabledMetricsV1Response(rsp *http.Response) (*PostDisabledMetricsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDisabledMetricsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseListDisabledMetricsV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 207:
		var dest ResponseListDisabledMetricsAndErrorV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON207 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCustomPrometheusJobsV1Response parses an HTTP response from a GetCustomPrometheusJobsV1WithResponse call
func ParseGetCustomPrometheusJobsV1Response(rsp *http.Response) (*GetCustomPrometheusJobsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomPrometheusJobsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCustomJobsPaginatedResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCustomPrometheusJobByIdV1Response parses an HTTP response from a DeleteCustomPrometheusJobByIdV1WithResponse call
func ParseDeleteCustomPrometheusJobByIdV1Response(rsp *http.Response) (*DeleteCustomPrometheusJobByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomPrometheusJobByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCustomPrometheusJobByNameV1Response parses an HTTP response from a GetCustomPrometheusJobByNameV1WithResponse call
func ParseGetCustomPrometheusJobByNameV1Response(rsp *http.Response) (*GetCustomPrometheusJobByNameV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomPrometheusJobByNameV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest CustomJobContentV1
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseCreateCustomPrometheusJobV1Response parses an HTTP response from a CreateCustomPrometheusJobV1WithResponse call
func ParseCreateCustomPrometheusJobV1Response(rsp *http.Response) (*CreateCustomPrometheusJobV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCustomPrometheusJobV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 201:
		var dest CustomJobContentV1
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML201 = &dest

	}

	return response, nil
}

// ParseUpdateCustomPrometheusJobByIdV1Response parses an HTTP response from a UpdateCustomPrometheusJobByIdV1WithResponse call
func ParseUpdateCustomPrometheusJobByIdV1Response(rsp *http.Response) (*UpdateCustomPrometheusJobByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCustomPrometheusJobByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest CustomJobContentV1
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseGetCustomPrometheusJobEnablementV1Response parses an HTTP response from a GetCustomPrometheusJobEnablementV1WithResponse call
func ParseGetCustomPrometheusJobEnablementV1Response(rsp *http.Response) (*GetCustomPrometheusJobEnablementV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomPrometheusJobEnablementV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomJobsEnablementV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateCustomPrometheusJobEnablementV1Response parses an HTTP response from a UpdateCustomPrometheusJobEnablementV1WithResponse call
func ParseUpdateCustomPrometheusJobEnablementV1Response(rsp *http.Response) (*UpdateCustomPrometheusJobEnablementV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCustomPrometheusJobEnablementV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomJobsEnablementV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetJiraIntegrationsV1Response parses an HTTP response from a GetJiraIntegrationsV1WithResponse call
func ParseGetJiraIntegrationsV1Response(rsp *http.Response) (*GetJiraIntegrationsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJiraIntegrationsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PaginatedIntegrationsResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateJiraIntegrationV1Response parses an HTTP response from a CreateJiraIntegrationV1WithResponse call
func ParseCreateJiraIntegrationV1Response(rsp *http.Response) (*CreateJiraIntegrationV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateJiraIntegrationV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IntegrationResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteJiraIntegrationV1Response parses an HTTP response from a DeleteJiraIntegrationV1WithResponse call
func ParseDeleteJiraIntegrationV1Response(rsp *http.Response) (*DeleteJiraIntegrationV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteJiraIntegrationV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetJiraIntegrationV1Response parses an HTTP response from a GetJiraIntegrationV1WithResponse call
func ParseGetJiraIntegrationV1Response(rsp *http.Response) (*GetJiraIntegrationV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJiraIntegrationV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateJiraIntegrationV1Response parses an HTTP response from a UpdateJiraIntegrationV1WithResponse call
func ParseUpdateJiraIntegrationV1Response(rsp *http.Response) (*UpdateJiraIntegrationV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateJiraIntegrationV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetJiraIssueTypesV1Response parses an HTTP response from a GetJiraIssueTypesV1WithResponse call
func ParseGetJiraIssueTypesV1Response(rsp *http.Response) (*GetJiraIssueTypesV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJiraIssueTypesV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IssueTypesResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateJiraIssueTypeV1Response parses an HTTP response from a CreateJiraIssueTypeV1WithResponse call
func ParseCreateJiraIssueTypeV1Response(rsp *http.Response) (*CreateJiraIssueTypeV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateJiraIssueTypeV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IssueTypeResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteJiraIssueTypeV1Response parses an HTTP response from a DeleteJiraIssueTypeV1WithResponse call
func ParseDeleteJiraIssueTypeV1Response(rsp *http.Response) (*DeleteJiraIssueTypeV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteJiraIssueTypeV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetJiraIssueTypeV1Response parses an HTTP response from a GetJiraIssueTypeV1WithResponse call
func ParseGetJiraIssueTypeV1Response(rsp *http.Response) (*GetJiraIssueTypeV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJiraIssueTypeV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IssueTypeResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateJiraIssueTypeV1Response parses an HTTP response from a UpdateJiraIssueTypeV1WithResponse call
func ParseUpdateJiraIssueTypeV1Response(rsp *http.Response) (*UpdateJiraIssueTypeV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateJiraIssueTypeV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IssueTypeResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListJobsV1Response parses an HTTP response from a ListJobsV1WithResponse call
func ParseListJobsV1Response(rsp *http.Response) (*ListJobsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListJobsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListJobs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListSchedulesV1Response parses an HTTP response from a ListSchedulesV1WithResponse call
func ParseListSchedulesV1Response(rsp *http.Response) (*ListSchedulesV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSchedulesV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListSchedules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAccessKeysV1Response parses an HTTP response from a GetAccessKeysV1WithResponse call
func ParseGetAccessKeysV1Response(rsp *http.Response) (*GetAccessKeysV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccessKeysV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAccessKeysPaginatedResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateAccessKeyV1Response parses an HTTP response from a CreateAccessKeyV1WithResponse call
func ParseCreateAccessKeyV1Response(rsp *http.Response) (*CreateAccessKeyV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAccessKeyV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AccessKeyResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAccessKeyByIdV1Response parses an HTTP response from a DeleteAccessKeyByIdV1WithResponse call
func ParseDeleteAccessKeyByIdV1Response(rsp *http.Response) (*DeleteAccessKeyByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAccessKeyByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAccessKeyByIdV1Response parses an HTTP response from a GetAccessKeyByIdV1WithResponse call
func ParseGetAccessKeyByIdV1Response(rsp *http.Response) (*GetAccessKeyByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccessKeyByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccessKeyResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAccessKeyByIdV1Response parses an HTTP response from a UpdateAccessKeyByIdV1WithResponse call
func ParseUpdateAccessKeyByIdV1Response(rsp *http.Response) (*UpdateAccessKeyByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAccessKeyByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccessKeyResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCaptureStorageConfigurationV1Response parses an HTTP response from a GetCaptureStorageConfigurationV1WithResponse call
func ParseGetCaptureStorageConfigurationV1Response(rsp *http.Response) (*GetCaptureStorageConfigurationV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCaptureStorageConfigurationV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CaptureStorageConfigurationResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateCaptureStorageConfigurationV1Response parses an HTTP response from a UpdateCaptureStorageConfigurationV1WithResponse call
func ParseUpdateCaptureStorageConfigurationV1Response(rsp *http.Response) (*UpdateCaptureStorageConfigurationV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCaptureStorageConfigurationV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CaptureStorageConfigurationResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserDeactivationConfigurationV1Response parses an HTTP response from a GetUserDeactivationConfigurationV1WithResponse call
func ParseGetUserDeactivationConfigurationV1Response(rsp *http.Response) (*GetUserDeactivationConfigurationV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserDeactivationConfigurationV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserDeactivationConfigurationResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserDeactivationConfigurationByIdV1Response parses an HTTP response from a UpdateUserDeactivationConfigurationByIdV1WithResponse call
func ParseUpdateUserDeactivationConfigurationByIdV1Response(rsp *http.Response) (*UpdateUserDeactivationConfigurationByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserDeactivationConfigurationByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserDeactivationConfigurationResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetDefaultRoleByDisplayNameV1Response parses an HTTP response from a GetDefaultRoleByDisplayNameV1WithResponse call
func ParseGetDefaultRoleByDisplayNameV1Response(rsp *http.Response) (*GetDefaultRoleByDisplayNameV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDefaultRoleByDisplayNameV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DefaultRoleResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGlobaSsoSettingsV1Response parses an HTTP response from a GetGlobaSsoSettingsV1WithResponse call
func ParseGetGlobaSsoSettingsV1Response(rsp *http.Response) (*GetGlobaSsoSettingsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGlobaSsoSettingsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalSsoSettingsResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateGlobalSsoSettingsV1Response parses an HTTP response from a UpdateGlobalSsoSettingsV1WithResponse call
func ParseUpdateGlobalSsoSettingsV1Response(rsp *http.Response) (*UpdateGlobalSsoSettingsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGlobalSsoSettingsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GlobalSsoSettingsResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupMappingsV1Response parses an HTTP response from a GetGroupMappingsV1WithResponse call
func ParseGetGroupMappingsV1Response(rsp *http.Response) (*GetGroupMappingsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupMappingsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupMappingsPaginatedResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateGroupMappingV1Response parses an HTTP response from a CreateGroupMappingV1WithResponse call
func ParseCreateGroupMappingV1Response(rsp *http.Response) (*CreateGroupMappingV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGroupMappingV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GroupMappingResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupMappingSettingsV1Response parses an HTTP response from a GetGroupMappingSettingsV1WithResponse call
func ParseGetGroupMappingSettingsV1Response(rsp *http.Response) (*GetGroupMappingSettingsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupMappingSettingsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupMappingSettingsV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSaveGroupMappingSettingsV1Response parses an HTTP response from a SaveGroupMappingSettingsV1WithResponse call
func ParseSaveGroupMappingSettingsV1Response(rsp *http.Response) (*SaveGroupMappingSettingsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveGroupMappingSettingsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupMappingSettingsV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteGroupMappingByIdV1Response parses an HTTP response from a DeleteGroupMappingByIdV1WithResponse call
func ParseDeleteGroupMappingByIdV1Response(rsp *http.Response) (*DeleteGroupMappingByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupMappingByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGroupMappingByIdV1Response parses an HTTP response from a GetGroupMappingByIdV1WithResponse call
func ParseGetGroupMappingByIdV1Response(rsp *http.Response) (*GetGroupMappingByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupMappingByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupMappingResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateGroupMappingByIdV1Response parses an HTTP response from a UpdateGroupMappingByIdV1WithResponse call
func ParseUpdateGroupMappingByIdV1Response(rsp *http.Response) (*UpdateGroupMappingByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGroupMappingByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GroupMappingResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetIpFiltersV1Response parses an HTTP response from a GetIpFiltersV1WithResponse call
func ParseGetIpFiltersV1Response(rsp *http.Response) (*GetIpFiltersV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIpFiltersV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IpFiltersPaginatedResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateIpFilterV1Response parses an HTTP response from a CreateIpFilterV1WithResponse call
func ParseCreateIpFilterV1Response(rsp *http.Response) (*CreateIpFilterV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateIpFilterV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IpFilterResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetIpFiltersSettingsV1Response parses an HTTP response from a GetIpFiltersSettingsV1WithResponse call
func ParseGetIpFiltersSettingsV1Response(rsp *http.Response) (*GetIpFiltersSettingsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIpFiltersSettingsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IpFiltersSettingsV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSaveIpFiltersSettingsV1Response parses an HTTP response from a SaveIpFiltersSettingsV1WithResponse call
func ParseSaveIpFiltersSettingsV1Response(rsp *http.Response) (*SaveIpFiltersSettingsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveIpFiltersSettingsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IpFiltersSettingsV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteIpFilterByIdV1Response parses an HTTP response from a DeleteIpFilterByIdV1WithResponse call
func ParseDeleteIpFilterByIdV1Response(rsp *http.Response) (*DeleteIpFilterByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteIpFilterByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetIpFilterByIdV1Response parses an HTTP response from a GetIpFilterByIdV1WithResponse call
func ParseGetIpFilterByIdV1Response(rsp *http.Response) (*GetIpFilterByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetIpFilterByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IpFilterResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateIpFilterV1Response parses an HTTP response from a UpdateIpFilterV1WithResponse call
func ParseUpdateIpFilterV1Response(rsp *http.Response) (*UpdateIpFilterV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateIpFilterV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IpFilterResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNotificationChannelsResponse parses an HTTP response from a GetNotificationChannelsWithResponse call
func ParseGetNotificationChannelsResponse(rsp *http.Response) (*GetNotificationChannelsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationChannelsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetNotificationChannelsPaginatedResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateNotificationChannelResponse parses an HTTP response from a CreateNotificationChannelWithResponse call
func ParseCreateNotificationChannelResponse(rsp *http.Response) (*CreateNotificationChannelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateNotificationChannelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest NotificationChannelResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteNotificationChannelByIdResponse parses an HTTP response from a DeleteNotificationChannelByIdWithResponse call
func ParseDeleteNotificationChannelByIdResponse(rsp *http.Response) (*DeleteNotificationChannelByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteNotificationChannelByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNotificationChannelByIdResponse parses an HTTP response from a GetNotificationChannelByIdWithResponse call
func ParseGetNotificationChannelByIdResponse(rsp *http.Response) (*GetNotificationChannelByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNotificationChannelByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationChannelResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateNotificationChannelByIdResponse parses an HTTP response from a UpdateNotificationChannelByIdWithResponse call
func ParseUpdateNotificationChannelByIdResponse(rsp *http.Response) (*UpdateNotificationChannelByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateNotificationChannelByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NotificationChannelResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPermissionsV1Response parses an HTTP response from a GetPermissionsV1WithResponse call
func ParseGetPermissionsV1Response(rsp *http.Response) (*GetPermissionsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPermissionsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPermissionsResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPlatformAuditEventsV1Response parses an HTTP response from a GetPlatformAuditEventsV1WithResponse call
func ParseGetPlatformAuditEventsV1Response(rsp *http.Response) (*GetPlatformAuditEventsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlatformAuditEventsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAuditEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRolesV1Response parses an HTTP response from a GetRolesV1WithResponse call
func ParseGetRolesV1Response(rsp *http.Response) (*GetRolesV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRolesV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetRolesPaginatedResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateRoleV1Response parses an HTTP response from a CreateRoleV1WithResponse call
func ParseCreateRoleV1Response(rsp *http.Response) (*CreateRoleV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRoleV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RoleResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteRoleByIdV1Response parses an HTTP response from a DeleteRoleByIdV1WithResponse call
func ParseDeleteRoleByIdV1Response(rsp *http.Response) (*DeleteRoleByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRoleByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRoleByIdV1Response parses an HTTP response from a GetRoleByIdV1WithResponse call
func ParseGetRoleByIdV1Response(rsp *http.Response) (*GetRoleByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRoleByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateRoleByIdV1Response parses an HTTP response from a UpdateRoleByIdV1WithResponse call
func ParseUpdateRoleByIdV1Response(rsp *http.Response) (*UpdateRoleByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRoleByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RoleResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGlobalServiceAccountsV1Response parses an HTTP response from a GetGlobalServiceAccountsV1WithResponse call
func ParseGetGlobalServiceAccountsV1Response(rsp *http.Response) (*GetGlobalServiceAccountsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGlobalServiceAccountsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetServiceAccountsPaginatedResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateGlobalServiceAccountV1Response parses an HTTP response from a CreateGlobalServiceAccountV1WithResponse call
func ParseCreateGlobalServiceAccountV1Response(rsp *http.Response) (*CreateGlobalServiceAccountV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGlobalServiceAccountV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServiceAccountWithKeyResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteGlobalServiceAccountsNotificationSettingsV1Response parses an HTTP response from a DeleteGlobalServiceAccountsNotificationSettingsV1WithResponse call
func ParseDeleteGlobalServiceAccountsNotificationSettingsV1Response(rsp *http.Response) (*DeleteGlobalServiceAccountsNotificationSettingsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGlobalServiceAccountsNotificationSettingsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGlobalServiceAccountsNotificationSettingsV1Response parses an HTTP response from a GetGlobalServiceAccountsNotificationSettingsV1WithResponse call
func ParseGetGlobalServiceAccountsNotificationSettingsV1Response(rsp *http.Response) (*GetGlobalServiceAccountsNotificationSettingsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGlobalServiceAccountsNotificationSettingsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceAccountsNotificationSettingsResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateGlobalServiceAccountsNotificationSettingsV1Response parses an HTTP response from a CreateGlobalServiceAccountsNotificationSettingsV1WithResponse call
func ParseCreateGlobalServiceAccountsNotificationSettingsV1Response(rsp *http.Response) (*CreateGlobalServiceAccountsNotificationSettingsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGlobalServiceAccountsNotificationSettingsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServiceAccountsNotificationSettingsResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateGlobalServiceAccountsNotificationSettingsV1Response parses an HTTP response from a UpdateGlobalServiceAccountsNotificationSettingsV1WithResponse call
func ParseUpdateGlobalServiceAccountsNotificationSettingsV1Response(rsp *http.Response) (*UpdateGlobalServiceAccountsNotificationSettingsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateGlobalServiceAccountsNotificationSettingsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceAccountsNotificationSettingsResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteGlobalServiceAccountByIdV1Response parses an HTTP response from a DeleteGlobalServiceAccountByIdV1WithResponse call
func ParseDeleteGlobalServiceAccountByIdV1Response(rsp *http.Response) (*DeleteGlobalServiceAccountByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGlobalServiceAccountByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGlobalServiceAccountByIdV1Response parses an HTTP response from a GetGlobalServiceAccountByIdV1WithResponse call
func ParseGetGlobalServiceAccountByIdV1Response(rsp *http.Response) (*GetGlobalServiceAccountByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGlobalServiceAccountByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceAccountResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSsoSettingsV1Response parses an HTTP response from a GetSsoSettingsV1WithResponse call
func ParseGetSsoSettingsV1Response(rsp *http.Response) (*GetSsoSettingsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSsoSettingsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AllSsoSettingsResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateSsoSettingsV1Response parses an HTTP response from a CreateSsoSettingsV1WithResponse call
func ParseCreateSsoSettingsV1Response(rsp *http.Response) (*CreateSsoSettingsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSsoSettingsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SsoSettingsResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSsoSettingsByIdV1Response parses an HTTP response from a DeleteSsoSettingsByIdV1WithResponse call
func ParseDeleteSsoSettingsByIdV1Response(rsp *http.Response) (*DeleteSsoSettingsByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSsoSettingsByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSsoSettingsByIdV1Response parses an HTTP response from a GetSsoSettingsByIdV1WithResponse call
func ParseGetSsoSettingsByIdV1Response(rsp *http.Response) (*GetSsoSettingsByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSsoSettingsByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SsoSettingsResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateSsoSettingsByIdV1Response parses an HTTP response from a UpdateSsoSettingsByIdV1WithResponse call
func ParseUpdateSsoSettingsByIdV1Response(rsp *http.Response) (*UpdateSsoSettingsByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSsoSettingsByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SsoSettingsResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTeamsV1Response parses an HTTP response from a GetTeamsV1WithResponse call
func ParseGetTeamsV1Response(rsp *http.Response) (*GetTeamsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetTeamsPaginatedResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateTeamV1Response parses an HTTP response from a CreateTeamV1WithResponse call
func ParseCreateTeamV1Response(rsp *http.Response) (*CreateTeamV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTeamV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TeamResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTeamByIdV1Response parses an HTTP response from a DeleteTeamByIdV1WithResponse call
func ParseDeleteTeamByIdV1Response(rsp *http.Response) (*DeleteTeamByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTeamByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTeamByIdV1Response parses an HTTP response from a GetTeamByIdV1WithResponse call
func ParseGetTeamByIdV1Response(rsp *http.Response) (*GetTeamByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateTeamByIdV1Response parses an HTTP response from a UpdateTeamByIdV1WithResponse call
func ParseUpdateTeamByIdV1Response(rsp *http.Response) (*UpdateTeamByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTeamByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTeamServiceAccountsV1Response parses an HTTP response from a GetTeamServiceAccountsV1WithResponse call
func ParseGetTeamServiceAccountsV1Response(rsp *http.Response) (*GetTeamServiceAccountsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamServiceAccountsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetServiceAccountsPaginatedResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateTeamServiceAccountV1Response parses an HTTP response from a CreateTeamServiceAccountV1WithResponse call
func ParseCreateTeamServiceAccountV1Response(rsp *http.Response) (*CreateTeamServiceAccountV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTeamServiceAccountV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServiceAccountWithKeyResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteServiceAccountsNotificationSettingsV1Response parses an HTTP response from a DeleteServiceAccountsNotificationSettingsV1WithResponse call
func ParseDeleteServiceAccountsNotificationSettingsV1Response(rsp *http.Response) (*DeleteServiceAccountsNotificationSettingsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteServiceAccountsNotificationSettingsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetServiceAccountsNotificationSettingsV1Response parses an HTTP response from a GetServiceAccountsNotificationSettingsV1WithResponse call
func ParseGetServiceAccountsNotificationSettingsV1Response(rsp *http.Response) (*GetServiceAccountsNotificationSettingsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetServiceAccountsNotificationSettingsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceAccountsNotificationSettingsResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateServiceAccountsNotificationSettingsV1Response parses an HTTP response from a CreateServiceAccountsNotificationSettingsV1WithResponse call
func ParseCreateServiceAccountsNotificationSettingsV1Response(rsp *http.Response) (*CreateServiceAccountsNotificationSettingsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateServiceAccountsNotificationSettingsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ServiceAccountsNotificationSettingsResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateServiceAccountsNotificationSettingsV1Response parses an HTTP response from a UpdateServiceAccountsNotificationSettingsV1WithResponse call
func ParseUpdateServiceAccountsNotificationSettingsV1Response(rsp *http.Response) (*UpdateServiceAccountsNotificationSettingsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateServiceAccountsNotificationSettingsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceAccountsNotificationSettingsResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTeamServiceAccountByIdV1Response parses an HTTP response from a DeleteTeamServiceAccountByIdV1WithResponse call
func ParseDeleteTeamServiceAccountByIdV1Response(rsp *http.Response) (*DeleteTeamServiceAccountByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTeamServiceAccountByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTeamServiceAccountByIdV1Response parses an HTTP response from a GetTeamServiceAccountByIdV1WithResponse call
func ParseGetTeamServiceAccountByIdV1Response(rsp *http.Response) (*GetTeamServiceAccountByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamServiceAccountByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServiceAccountResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTeamUsersV1Response parses an HTTP response from a GetTeamUsersV1WithResponse call
func ParseGetTeamUsersV1Response(rsp *http.Response) (*GetTeamUsersV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamUsersV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetTeamUsersPaginatedResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteTeamUserByIdV1Response parses an HTTP response from a DeleteTeamUserByIdV1WithResponse call
func ParseDeleteTeamUserByIdV1Response(rsp *http.Response) (*DeleteTeamUserByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTeamUserByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTeamUserByIdV1Response parses an HTTP response from a GetTeamUserByIdV1WithResponse call
func ParseGetTeamUserByIdV1Response(rsp *http.Response) (*GetTeamUserByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeamUserByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamUserResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSaveTeamUserV1Response parses an HTTP response from a SaveTeamUserV1WithResponse call
func ParseSaveTeamUserV1Response(rsp *http.Response) (*SaveTeamUserV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SaveTeamUserV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TeamUserResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TeamUserResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest UnsupportedMediaType
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUsersV1Response parses an HTTP response from a GetUsersV1WithResponse call
func ParseGetUsersV1Response(rsp *http.Response) (*GetUsersV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetUsersPaginatedResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateUserV1Response parses an HTTP response from a CreateUserV1WithResponse call
func ParseCreateUserV1Response(rsp *http.Response) (*CreateUserV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUserV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest UserResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserByIdV1Response parses an HTTP response from a DeleteUserByIdV1WithResponse call
func ParseDeleteUserByIdV1Response(rsp *http.Response) (*DeleteUserByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserByIdV1Response parses an HTTP response from a GetUserByIdV1WithResponse call
func ParseGetUserByIdV1Response(rsp *http.Response) (*GetUserByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserV1Response parses an HTTP response from a UpdateUserV1WithResponse call
func ParseUpdateUserV1Response(rsp *http.Response) (*UpdateUserV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListZonesV1Response parses an HTTP response from a ListZonesV1WithResponse call
func ParseListZonesV1Response(rsp *http.Response) (*ListZonesV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListZonesV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListZonesResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateZoneV1Response parses an HTTP response from a CreateZoneV1WithResponse call
func ParseCreateZoneV1Response(rsp *http.Response) (*CreateZoneV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateZoneV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ZoneResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteZoneV1Response parses an HTTP response from a DeleteZoneV1WithResponse call
func ParseDeleteZoneV1Response(rsp *http.Response) (*DeleteZoneV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteZoneV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetZoneByIdV1Response parses an HTTP response from a GetZoneByIdV1WithResponse call
func ParseGetZoneByIdV1Response(rsp *http.Response) (*GetZoneByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetZoneByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ZoneResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseEditZoneV1Response parses an HTTP response from a EditZoneV1WithResponse call
func ParseEditZoneV1Response(rsp *http.Response) (*EditZoneV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditZoneV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ZoneResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetActivityAuditEntriesV1Response parses an HTTP response from a GetActivityAuditEntriesV1WithResponse call
func ParseGetActivityAuditEntriesV1Response(rsp *http.Response) (*GetActivityAuditEntriesV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivityAuditEntriesV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetActivityAuditEntryV1Response parses an HTTP response from a GetActivityAuditEntryV1WithResponse call
func ParseGetActivityAuditEntryV1Response(rsp *http.Response) (*GetActivityAuditEntryV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivityAuditEntryV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetActivityAuditEntriesSupportedFiltersV1Response parses an HTTP response from a GetActivityAuditEntriesSupportedFiltersV1WithResponse call
func ParseGetActivityAuditEntriesSupportedFiltersV1Response(rsp *http.Response) (*GetActivityAuditEntriesSupportedFiltersV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActivityAuditEntriesSupportedFiltersV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuditSupportedFiltersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCertificatesV1Response parses an HTTP response from a GetCertificatesV1WithResponse call
func ParseGetCertificatesV1Response(rsp *http.Response) (*GetCertificatesV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCertificatesV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CertificatesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUploadCertificateV1Response parses an HTTP response from a UploadCertificateV1WithResponse call
func ParseUploadCertificateV1Response(rsp *http.Response) (*UploadCertificateV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadCertificateV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Certificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Details *[]interface{}                `json:"details,omitempty"`
			Message UploadCertificateV1400Message `json:"message"`
			Type    UploadCertificateV1400Type    `json:"type"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteCertificateV1Response parses an HTTP response from a DeleteCertificateV1WithResponse call
func ParseDeleteCertificateV1Response(rsp *http.Response) (*DeleteCertificateV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCertificateV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCertificateV1Response parses an HTTP response from a GetCertificateV1WithResponse call
func ParseGetCertificateV1Response(rsp *http.Response) (*GetCertificateV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCertificateV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Certificate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCertificateRegistrationV1Response parses an HTTP response from a GetCertificateRegistrationV1WithResponse call
func ParseGetCertificateRegistrationV1Response(rsp *http.Response) (*GetCertificateRegistrationV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCertificateRegistrationV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ServicesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateCSRV1Response parses an HTTP response from a CreateCSRV1WithResponse call
func ParseCreateCSRV1Response(rsp *http.Response) (*CreateCSRV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCSRV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListEFOChannelsByIntegrationV1Response parses an HTTP response from a ListEFOChannelsByIntegrationV1WithResponse call
func ParseListEFOChannelsByIntegrationV1Response(rsp *http.Response) (*ListEFOChannelsByIntegrationV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEFOChannelsByIntegrationV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationChannelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListEFOIntegrationsV1Response parses an HTTP response from a ListEFOIntegrationsV1WithResponse call
func ParseListEFOIntegrationsV1Response(rsp *http.Response) (*ListEFOIntegrationsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEFOIntegrationsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListEfoIntegrationsResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateEFOIntegrationV1Response parses an HTTP response from a CreateEFOIntegrationV1WithResponse call
func ParseCreateEFOIntegrationV1Response(rsp *http.Response) (*CreateEFOIntegrationV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEFOIntegrationV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest EfoIntegrationResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteEFOIntegrationByIdV1Response parses an HTTP response from a DeleteEFOIntegrationByIdV1WithResponse call
func ParseDeleteEFOIntegrationByIdV1Response(rsp *http.Response) (*DeleteEFOIntegrationByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEFOIntegrationByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEFOIntegrationByIdV1Response parses an HTTP response from a GetEFOIntegrationByIdV1WithResponse call
func ParseGetEFOIntegrationByIdV1Response(rsp *http.Response) (*GetEFOIntegrationByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEFOIntegrationByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EfoIntegrationResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateEFOIntegrationByIdV1Response parses an HTTP response from a UpdateEFOIntegrationByIdV1WithResponse call
func ParseUpdateEFOIntegrationByIdV1Response(rsp *http.Response) (*UpdateEFOIntegrationByIdV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEFOIntegrationByIdV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EfoIntegrationResponseV1
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListEFOIntegrationsTypesV1Response parses an HTTP response from a ListEFOIntegrationsTypesV1WithResponse call
func ParseListEFOIntegrationsTypesV1Response(rsp *http.Response) (*ListEFOIntegrationsTypesV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEFOIntegrationsTypesV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationTypesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListEFOChannelsByIntegrationV2Response parses an HTTP response from a ListEFOChannelsByIntegrationV2WithResponse call
func ParseListEFOChannelsByIntegrationV2Response(rsp *http.Response) (*ListEFOChannelsByIntegrationV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEFOChannelsByIntegrationV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationChannelsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListEFOIntegrationsV2Response parses an HTTP response from a ListEFOIntegrationsV2WithResponse call
func ParseListEFOIntegrationsV2Response(rsp *http.Response) (*ListEFOIntegrationsV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEFOIntegrationsV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListIntegrationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseCreateEFOIntegrationV2Response parses an HTTP response from a CreateEFOIntegrationV2WithResponse call
func ParseCreateEFOIntegrationV2Response(rsp *http.Response) (*CreateEFOIntegrationV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateEFOIntegrationV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest IntegrationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteEFOIntegrationByIdV2Response parses an HTTP response from a DeleteEFOIntegrationByIdV2WithResponse call
func ParseDeleteEFOIntegrationByIdV2Response(rsp *http.Response) (*DeleteEFOIntegrationByIdV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteEFOIntegrationByIdV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEFOIntegrationByIdV2Response parses an HTTP response from a GetEFOIntegrationByIdV2WithResponse call
func ParseGetEFOIntegrationByIdV2Response(rsp *http.Response) (*GetEFOIntegrationByIdV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEFOIntegrationByIdV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateEFOIntegrationByIdV2Response parses an HTTP response from a UpdateEFOIntegrationByIdV2WithResponse call
func ParseUpdateEFOIntegrationByIdV2Response(rsp *http.Response) (*UpdateEFOIntegrationByIdV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEFOIntegrationByIdV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseListEFOIntegrationsTypesV2Response parses an HTTP response from a ListEFOIntegrationsTypesV2WithResponse call
func ParseListEFOIntegrationsTypesV2Response(rsp *http.Response) (*ListEFOIntegrationsTypesV2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListEFOIntegrationsTypesV2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest IntegrationTypesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEventsV1Response parses an HTTP response from a GetEventsV1WithResponse call
func ParseGetEventsV1Response(rsp *http.Response) (*GetEventsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListEventsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEventV1Response parses an HTTP response from a GetEventV1WithResponse call
func ParseGetEventV1Response(rsp *http.Response) (*GetEventV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Event
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetEventsSupportedFiltersV1Response parses an HTTP response from a GetEventsSupportedFiltersV1WithResponse call
func ParseGetEventsSupportedFiltersV1Response(rsp *http.Response) (*GetEventsSupportedFiltersV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventsSupportedFiltersV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SupportedFiltersResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetResourcesResponse parses an HTTP response from a GetResourcesWithResponse call
func ParseGetResourcesResponse(rsp *http.Response) (*GetResourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InventoryResourceResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetResourceResponse parses an HTTP response from a GetResourceWithResponse call
func ParseGetResourceResponse(rsp *http.Response) (*GetResourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest InventoryResourceExtended
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetActionExecutionsv1Response parses an HTTP response from a GetActionExecutionsv1WithResponse call
func ParseGetActionExecutionsv1Response(rsp *http.Response) (*GetActionExecutionsv1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActionExecutionsv1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionExecutions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Details *[]interface{}                  `json:"details,omitempty"`
			Message GetActionExecutionsv1400Message `json:"message"`
			Type    GetActionExecutionsv1400Type    `json:"type"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSubmitActionExecutionv1Response parses an HTTP response from a SubmitActionExecutionv1WithResponse call
func ParseSubmitActionExecutionv1Response(rsp *http.Response) (*SubmitActionExecutionv1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SubmitActionExecutionv1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest ActionExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Details *[]interface{} `json:"details,omitempty"`
			Message string         `json:"message"`
			Type    string         `json:"type"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUndoActionExecutionV1Response parses an HTTP response from a UndoActionExecutionV1WithResponse call
func ParseUndoActionExecutionV1Response(rsp *http.Response) (*UndoActionExecutionV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UndoActionExecutionV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetActionExecutionV1Response parses an HTTP response from a GetActionExecutionV1WithResponse call
func ParseGetActionExecutionV1Response(rsp *http.Response) (*GetActionExecutionV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActionExecutionV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ActionExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetActionExecutionFileAcquireV1Response parses an HTTP response from a GetActionExecutionFileAcquireV1WithResponse call
func ParseGetActionExecutionFileAcquireV1Response(rsp *http.Response) (*GetActionExecutionFileAcquireV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActionExecutionFileAcquireV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetActionsV1Response parses an HTTP response from a GetActionsV1WithResponse call
func ParseGetActionsV1Response(rsp *http.Response) (*GetActionsV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActionsV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Actions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSecureVulnerabilityV1BundlesResponse parses an HTTP response from a GetSecureVulnerabilityV1BundlesWithResponse call
func ParseGetSecureVulnerabilityV1BundlesResponse(rsp *http.Response) (*GetSecureVulnerabilityV1BundlesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSecureVulnerabilityV1BundlesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListBundlesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSecureVulnerabilityV1BundlesResponse parses an HTTP response from a PostSecureVulnerabilityV1BundlesWithResponse call
func ParsePostSecureVulnerabilityV1BundlesResponse(rsp *http.Response) (*PostSecureVulnerabilityV1BundlesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSecureVulnerabilityV1BundlesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GetBundleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSecureVulnerabilityV1BundlesBundleIdResponse parses an HTTP response from a DeleteSecureVulnerabilityV1BundlesBundleIdWithResponse call
func ParseDeleteSecureVulnerabilityV1BundlesBundleIdResponse(rsp *http.Response) (*DeleteSecureVulnerabilityV1BundlesBundleIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSecureVulnerabilityV1BundlesBundleIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSecureVulnerabilityV1BundlesBundleIdResponse parses an HTTP response from a GetSecureVulnerabilityV1BundlesBundleIdWithResponse call
func ParseGetSecureVulnerabilityV1BundlesBundleIdResponse(rsp *http.Response) (*GetSecureVulnerabilityV1BundlesBundleIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSecureVulnerabilityV1BundlesBundleIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBundleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutSecureVulnerabilityV1BundlesBundleIdResponse parses an HTTP response from a PutSecureVulnerabilityV1BundlesBundleIdWithResponse call
func ParsePutSecureVulnerabilityV1BundlesBundleIdResponse(rsp *http.Response) (*PutSecureVulnerabilityV1BundlesBundleIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutSecureVulnerabilityV1BundlesBundleIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetBundleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSecureVulnerabilityV1PipelineResultsResponse parses an HTTP response from a GetSecureVulnerabilityV1PipelineResultsWithResponse call
func ParseGetSecureVulnerabilityV1PipelineResultsResponse(rsp *http.Response) (*GetSecureVulnerabilityV1PipelineResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSecureVulnerabilityV1PipelineResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PipelineResultsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSecureVulnerabilityV1PoliciesResponse parses an HTTP response from a GetSecureVulnerabilityV1PoliciesWithResponse call
func ParseGetSecureVulnerabilityV1PoliciesResponse(rsp *http.Response) (*GetSecureVulnerabilityV1PoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSecureVulnerabilityV1PoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListPoliciesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostSecureVulnerabilityV1PoliciesResponse parses an HTTP response from a PostSecureVulnerabilityV1PoliciesWithResponse call
func ParsePostSecureVulnerabilityV1PoliciesResponse(rsp *http.Response) (*PostSecureVulnerabilityV1PoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSecureVulnerabilityV1PoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest GetPolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteSecureVulnerabilityV1PoliciesPolicyIdResponse parses an HTTP response from a DeleteSecureVulnerabilityV1PoliciesPolicyIdWithResponse call
func ParseDeleteSecureVulnerabilityV1PoliciesPolicyIdResponse(rsp *http.Response) (*DeleteSecureVulnerabilityV1PoliciesPolicyIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSecureVulnerabilityV1PoliciesPolicyIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSecureVulnerabilityV1PoliciesPolicyIdResponse parses an HTTP response from a GetSecureVulnerabilityV1PoliciesPolicyIdWithResponse call
func ParseGetSecureVulnerabilityV1PoliciesPolicyIdResponse(rsp *http.Response) (*GetSecureVulnerabilityV1PoliciesPolicyIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSecureVulnerabilityV1PoliciesPolicyIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePutSecureVulnerabilityV1PoliciesPolicyIdResponse parses an HTTP response from a PutSecureVulnerabilityV1PoliciesPolicyIdWithResponse call
func ParsePutSecureVulnerabilityV1PoliciesPolicyIdResponse(rsp *http.Response) (*PutSecureVulnerabilityV1PoliciesPolicyIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutSecureVulnerabilityV1PoliciesPolicyIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetPolicyResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseScannerAPIServiceListRegistryResultsResponse parses an HTTP response from a ScannerAPIServiceListRegistryResultsWithResponse call
func ParseScannerAPIServiceListRegistryResultsResponse(rsp *http.Response) (*ScannerAPIServiceListRegistryResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScannerAPIServiceListRegistryResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RegistryResultsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSecureVulnerabilityV1ResultsResultIdResponse parses an HTTP response from a GetSecureVulnerabilityV1ResultsResultIdWithResponse call
func ParseGetSecureVulnerabilityV1ResultsResultIdResponse(rsp *http.Response) (*GetSecureVulnerabilityV1ResultsResultIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSecureVulnerabilityV1ResultsResultIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScanResultResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseScannerAPIServiceListRuntimeResultsResponse parses an HTTP response from a ScannerAPIServiceListRuntimeResultsWithResponse call
func ParseScannerAPIServiceListRuntimeResultsResponse(rsp *http.Response) (*ScannerAPIServiceListRuntimeResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ScannerAPIServiceListRuntimeResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RuntimeResultsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAcceptedRisksV1Response parses an HTTP response from a GetAcceptedRisksV1WithResponse call
func ParseGetAcceptedRisksV1Response(rsp *http.Response) (*GetAcceptedRisksV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAcceptedRisksV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListRiskAcceptedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParsePostAcceptedRiskV1Response parses an HTTP response from a PostAcceptedRiskV1WithResponse call
func ParsePostAcceptedRiskV1Response(rsp *http.Response) (*PostAcceptedRiskV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAcceptedRiskV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest RiskAcceptedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteAcceptedRiskV1Response parses an HTTP response from a DeleteAcceptedRiskV1WithResponse call
func ParseDeleteAcceptedRiskV1Response(rsp *http.Response) (*DeleteAcceptedRiskV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAcceptedRiskV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAcceptedRiskV1Response parses an HTTP response from a GetAcceptedRiskV1WithResponse call
func ParseGetAcceptedRiskV1Response(rsp *http.Response) (*GetAcceptedRiskV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAcceptedRiskV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RiskAcceptedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateAcceptedRiskV1Response parses an HTTP response from a UpdateAcceptedRiskV1WithResponse call
func ParseUpdateAcceptedRiskV1Response(rsp *http.Response) (*UpdateAcceptedRiskV1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAcceptedRiskV1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RiskAcceptedResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetSBOMV1beta1Response parses an HTTP response from a GetSBOMV1beta1WithResponse call
func ParseGetSBOMV1beta1Response(rsp *http.Response) (*GetSBOMV1beta1Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSBOMV1beta1Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SbomResultResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
